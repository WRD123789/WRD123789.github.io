

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=light>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="John Doe">
  <meta name="keywords" content="">
  
    <meta name="description" content="设备驱动程序 设备驱动程序是一段驻留在操作系统内的代码, 用于管理特定的硬件设备. 驱动程序负责设置好这些硬件设备,  告诉设备要执行什么动作,  处理设备产生的中断,  并与正在等待该设备的上层用户进程进行交互等. 如果操作系统需要关注一些硬件设备, 我们可以配置该设备, 使其能够产生中断. 由于中断是引起 trap 的其中一种方式, 内核的trap handler会注意到有设备发出了中断, 接">
<meta property="og:type" content="article">
<meta property="og:title" content="设备驱动程序">
<meta property="og:url" content="http://example.com/2024/07/04/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="设备驱动程序 设备驱动程序是一段驻留在操作系统内的代码, 用于管理特定的硬件设备. 驱动程序负责设置好这些硬件设备,  告诉设备要执行什么动作,  处理设备产生的中断,  并与正在等待该设备的上层用户进程进行交互等. 如果操作系统需要关注一些硬件设备, 我们可以配置该设备, 使其能够产生中断. 由于中断是引起 trap 的其中一种方式, 内核的trap handler会注意到有设备发出了中断, 接">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/Pictures/20230401104026.png">
<meta property="og:image" content="http://example.com/img/Pictures/20230401105805.png">
<meta property="og:image" content="http://example.com/img/Pictures/20230401110648.png">
<meta property="article:published_time" content="2024-07-04T03:36:45.000Z">
<meta property="article:modified_time" content="2024-07-04T10:39:36.065Z">
<meta property="article:author" content="John Doe">
<meta property="article:tag" content="MIT 6.S081">
<meta property="article:tag" content="操作系统">
<meta property="article:tag" content="Xv6">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://example.com/img/Pictures/20230401104026.png">
  
  
  
  <title>设备驱动程序 - Hexo</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.9.7","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 7.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Wangrd&#39;s Blog</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/bg/1.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="设备驱动程序"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2024-07-04 11:36" pubdate>
          2024年7月4日 中午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          6.2k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          52 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">设备驱动程序</h1>
            
            
              <div class="markdown-body">
                
                <h1>设备驱动程序</h1>
<p>设备驱动程序是一段驻留在操作系统内的代码, 用于管理特定的硬件设备. 驱动程序负责设置好这些硬件设备,  告诉设备要执行什么动作,  处理设备产生的中断,  并与正在等待该设备的上层用户进程进行交互等.</p>
<p>如果操作系统需要关注一些硬件设备, 我们可以配置该设备, 使其能够产生中断. 由于中断是引起 trap 的其中一种方式, 内核的trap handler会注意到有设备发出了中断, 接着内核就为该设备调用特定的中断处理程序. 在 Xv6 中, 所有设备的中断, 都首先经过中断处理程序 devintr (kernel/trap.c) , 再由 devintr 跳转到具体设备的中断处理程序 (如uartintr、virtio_disk_intr等) .</p>
<ul>
<li>设备中断处理程序是用来响应设备中断并进行相关处理的程序. 一般情况下, 设备中断处理程序需要完成以下几个任务:
<ol>
<li>保存 CPU 现场: 当设备发送中断信号时, CPU 会暂停正在执行的程序, 并开始执行设备中断处理程序. 为了确保中断处理程序的执行不会影响到正在执行的程序, 中断处理程序需要保存当前 CPU 的现场, 包括寄存器值、程序计数器等信息.</li>
<li>确认中断源: 中断处理程序需要确定哪个设备发送了中断信号, 从而正确地处理设备发送的数据. 通常, 中断控制器会提供一个中断向量表, 记录每个设备对应的中断处理程序的地址.</li>
<li>处理设备发送的数据: 中断处理程序需要根据设备发送的数据进行相应的处理. 例如, 当磁盘驱动器完成了一个读操作时, 中断处理程序需要将读取的数据从磁盘缓存中复制到内存中.</li>
<li>发送信号到操作系统: 一些设备中断处理程序需要将结果发送给操作系统, 以便操作系统可以继续执行相应的操作. 例如, 当网卡接收到一个数据包时, 中断处理程序需要将数据包传递给操作系统, 由操作系统进一步处理.</li>
<li>恢复 CPU 现场: 当中断处理程序完成相应的处理后, 需要将 CPU 的现场恢复到中断之前的状态, 以便 CPU 可以继续执行之前暂停的程序.</li>
</ol>
</li>
</ul>
<p>大多数的设备驱动程序, 都可以看成一个分上下部分的结构:  bottom half 和 top half</p>
<ul>
<li>bottom half 在中断产生时执行, 通常是中断处理程序. 当一个中断送到 CPU, 并且 CPU 接收了这个中断, CPU 就会调用相应的中断处理程序.</li>
<li>top half 运行在内核空间中, 是用户进程或内核的其他部分调用的接口, 这些接口可以被更高层级的代码调用.</li>
</ul>
<p>当内核希望与设备进行一些交互时, 例如请求 read、write 等系统调用时, 驱动的 top half 就会被调用, top half 会根据相应的请求, 让设备开始执行一些具体的操作. 当设备相关的操作完成时, 设备就会产生中断, 此时驱动程序的 bottom half 开始执行, 它会查看设备完成的是什么工作, 在适当的时候唤醒等待该工作的进程, 同时让硬件执行下一个操作.</p>
<p>一个设备驱动程序的 top half 和 bottom half 可以并发地运行在不同的 CPU 上.</p>
<p>由于设备和 CPU 是并行运行的, 为了让它们之间的数据传输更高效, 在驱动中通常会使用队列 (或缓冲区) 来解耦它们之间的通信.</p>
<ul>
<li><img src="/img/Pictures/20230401104026.png" srcset="/img/loading.gif" lazyload alt=""></li>
<li>驱动程序是在 CPU 上运行的, 负责管理设备并进行数据传输. 驱动程序中的代码通常会将数据从队列 (或缓冲区) 中读取或写入队列 (或缓冲区)中. 当设备接收到数据或完成某个操作时, 它会生成一个中断信号, 中断处理程序会在 CPU 上运行, 以响应设备的中断并进行相关的处理. 中断处理程序也可以从队列 (或缓冲区) 中读取或向队列 (或缓冲区) 中写入数据.</li>
<li>这个队列 (或缓冲区) 可以解耦设备和 CPU 之间的通信, 因为它可以将数据传输的时间与实际处理数据的时间分离开来, 使得设备和 CPU 可以并行进行数据传输和处理, 而不需要互相等待对方完成操作, 从而提高了系统的并发性和响应速度. 具体来说, 设备和 CPU 之间的数据传输通常需要在设备上触发中断, 然后在 CPU 上进行中断处理程序的调用, 这个过程需要时间. 在传统的方式中, 设备必须等待中断处理程序完成后才能发送下一个数据包, 这会浪费许多时间, 影响系统的响应速度. 而使用队列 (或缓冲区) 可以解耦这个过程, 当设备有数据需要传输时, 可以直接将数据放入队列 (或缓冲区) 中, 不必等待中断处理程序的完成, CPU 则可以在空闲时间从队列 (或缓冲区) 中读取数据进行处理, 这样就允许设备和 CPU 并行运行, 提高了系统的整体性能和响应速度.</li>
</ul>
<p>对设备的编程是通过 Memory mapped I/O 完成的. 设备地址出现在物理地址的特定区间内, 这个区间由主板制造商决定. 操作系统需要知道这些设备位于物理地址空间的具体位置, 然后通过普通的 load/store 指令对这些地址进行编程, load/store 指令实际上的工作就是读写设备的控制寄存器, 你需要阅读设备的文档来弄清楚设备的寄存器和相应的行为.</p>
<ul>
<li>
<p>以下是 SiFive 主板中对应设备的物理地址:</p>
<p><img src="/img/Pictures/20230401105805.png" srcset="/img/loading.gif" lazyload alt=""></p>
</li>
<li>
<p>下面是 16550 UART 的文档, QEMU 模拟这个设备来与键盘和控制台进行交互:</p>
<p><img src="/img/Pictures/20230401110648.png" srcset="/img/loading.gif" lazyload alt=""></p>
<ul>
<li>控制寄存器 000, 如果写它会将数据写入到寄存器中并被传输到其他地方, 如果读它可以读出存储在寄存器中的内容.</li>
<li>控制寄存器 001, 可以通过它来控制 UART 是否能产生中断.</li>
<li>…</li>
</ul>
</li>
</ul>
<h2 id="控制台输入">控制台输入</h2>
<p>控制台是与用户进行交互的硬件设备,  它接收用户的输入  (如果键盘输入) ,  将其传递给内核和用户程序,  经过相应的处理,  再将结果输出给用户  (如输出到屏幕上) .</p>
<p>首先, 简单地看总体流程:</p>
<ol>
<li>用户将会通过键盘键入一连串字符, 通过连接到RISC-V上的UART串行端口 (UART Serial-port) 传输, 控制台驱动程序将会顺利地接收这些输入.</li>
<li>控制台驱动程序处理其中的一些特殊字符 (如BackSpace和Ctrl等) , 并不断累积这些输入字符到缓冲区, 直到达到完整的一行 (一般用户键入Enter表示一行的结束) .</li>
<li>用户进程, 例如Shell, 就会使用 read 从控制台中读取这些输入, 然后由 Shell 来具体处理它们.</li>
</ol>
<h3 id="UART-结构">UART 结构</h3>
<p>内核可以访问经内存映射的 UART 控制寄存器. RISC-V 硬件将 UART 设备链接到事先约定好的物理地址上, 对这些固定物理地址的读或写指令, 相当于直接与硬件设备进行交互, 而不是与 RAM 交互.</p>
<p>UART 经内存映射到从物理地址 0x10000000, 它有一小部分控制寄存器, 每个 1 B 大小, 如下所示 (kernel/uart.c):</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// the UART control registers are memory-mapped</span><br><span class="hljs-comment">// at address UART0. this macro returns the</span><br><span class="hljs-comment">// address of one of the registers.</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> Reg(reg) ((volatile unsigned char *)(UART0 + reg))</span><br><br><span class="hljs-comment">// the UART control registers.</span><br><span class="hljs-comment">// some have different meanings for</span><br><span class="hljs-comment">// read vs write.</span><br><span class="hljs-comment">// see http://byterunner.com/16550.html</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> RHR 0                 <span class="hljs-comment">// receive holding register (for input bytes)</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> THR 0                 <span class="hljs-comment">// transmit holding register (for output bytes)</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IER 1                 <span class="hljs-comment">// interrupt enable register</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IER_TX_ENABLE (1&lt;&lt;0)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IER_RX_ENABLE (1&lt;&lt;1)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> FCR 2                 <span class="hljs-comment">// FIFO control register</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> FCR_FIFO_ENABLE (1&lt;&lt;0)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> FCR_FIFO_CLEAR (3&lt;&lt;1) <span class="hljs-comment">// clear the content of the two FIFOs</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ISR 2                 <span class="hljs-comment">// interrupt status register</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LCR 3                 <span class="hljs-comment">// line control register</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LCR_EIGHT_BITS (3&lt;&lt;0)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LCR_BAUD_LATCH (1&lt;&lt;7) <span class="hljs-comment">// special mode to set baud rate</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LSR 5                 <span class="hljs-comment">// line status register</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LSR_RX_READY (1&lt;&lt;0)   <span class="hljs-comment">// input is waiting to be read from RHR</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LSR_TX_IDLE (1&lt;&lt;5)    <span class="hljs-comment">// THR can accept another character to send</span></span><br></code></pre></td></tr></table></figure>
<ul>
<li>RHR 控制寄存器: 保存 UART 接收的输入, 等待内核将其内容取走, 对应内核的 read 指令.</li>
<li>THR 控制寄存器: 保存内核的输入, 等待 UART 将其发送, 对应内核的 write 指令.</li>
<li>LSR 控制寄存器: 包含一些位, LSR_RX_READY 指示 RHR 中是否有输入字符, 等待内核将其读出; 一旦被读出, UART 就将其从内部的 FIFO 缓冲区 中移除, 直到缓冲区为空时置位 LSR_TX_IDLE.</li>
</ul>
<h3 id="键盘输入">键盘输入</h3>
<ol>
<li>当用户在键盘中输入一个字符, 键盘将生成一个中断并且发向 PLIC, PLIC 会将中断路由给一个特定的 CPU 核 (如果这个 CPU 核设置了 SIE 寄存器的 E 位), 然后会发生以下事情:
<ol>
<li>清除 SIE 寄存器相应的位, 这样就可以阻止 CPU 核被其他中断打断, 该 CPU 核就可以专心处理当前中断. 处理完之后再恢复 SIE 寄存器对应的位.</li>
<li>设置 SEPC 寄存器为当前的程序计数器.</li>
<li>保存当前的模式, 中断前为用户模式则保存用户模式; 中断前为内核模式则保存内核模式.</li>
<li>将当前模式设置为内核模式.</li>
<li>将程序计数器的值设置为 STVEC.</li>
</ol>
</li>
<li>由于程序计数器设置为 STVEC, 所以程序会跳转到 uservec, 然后跳转到 usertrap, 然后跳转到 devintr (kernel/trap.c): <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// check if it&#x27;s an external interrupt or software interrupt,</span><br><span class="hljs-comment">// and handle it.</span><br><span class="hljs-comment">// returns 2 if timer interrupt,</span><br><span class="hljs-comment">// 1 if other device,</span><br><span class="hljs-comment">// 0 if not recognized.</span><br><span class="hljs-type">int</span><br><span class="hljs-title function_">devintr</span><span class="hljs-params">()</span><br>&#123;<br>  uint64 scause = r_scause();<br><br>  <span class="hljs-keyword">if</span>((scause &amp; <span class="hljs-number">0x8000000000000000</span>L) &amp;&amp;<br>     (scause &amp; <span class="hljs-number">0xff</span>) == <span class="hljs-number">9</span>)&#123;<br>    <span class="hljs-comment">// this is a supervisor external interrupt, via PLIC.</span><br><br>    <span class="hljs-comment">// irq indicates which device interrupted.</span><br>    <span class="hljs-type">int</span> irq = plic_claim();<br><br>    <span class="hljs-keyword">if</span>(irq == UART0_IRQ)&#123;<br>      uartintr();<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(irq == VIRTIO0_IRQ)&#123;<br>      virtio_disk_intr();<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(irq)&#123;<br>      <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;unexpected interrupt irq=%d\n&quot;</span>, irq);<br>    &#125;<br><br>    <span class="hljs-comment">// the PLIC allows each device to raise at most one</span><br>    <span class="hljs-comment">// interrupt at a time; tell the PLIC the device is</span><br>    <span class="hljs-comment">// now allowed to interrupt again.</span><br>    <span class="hljs-keyword">if</span>(irq)<br>      plic_complete(irq);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(scause == <span class="hljs-number">0x8000000000000001</span>L)&#123;<br>    <span class="hljs-comment">// software interrupt from a machine-mode timer interrupt,</span><br>    <span class="hljs-comment">// forwarded by timervec in kernelvec.S.</span><br><br>    <span class="hljs-keyword">if</span>(cpuid() == <span class="hljs-number">0</span>)&#123;<br>      clockintr();<br>    &#125;<br>    <br>    <span class="hljs-comment">// acknowledge the software interrupt by clearing</span><br>    <span class="hljs-comment">// the SSIP bit in sip.</span><br>    w_sip(r_sip() &amp; ~<span class="hljs-number">2</span>);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li>在该函数中, 通过检查 scause 中的值, 发现该设备中断来自外部设备, 然后由 PLIC (管理所有的外部设备中断) 告诉 CPU 是哪个设备产生中断, 发现是 UART 后, devintr 就会跳转到 UART 的中断处理程序 uartintr (kernel/uart.c), 进行相关的处理.</li>
</ul>
</li>
<li>由 uartintr (kernel/uart.c) 函数进行 UART 中断的处理: <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// handle a uart interrupt, raised because input has</span><br><span class="hljs-comment">// arrived, or the uart is ready for more output, or</span><br><span class="hljs-comment">// both. called from trap.c.</span><br><span class="hljs-type">void</span><br><span class="hljs-title function_">uartintr</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>  <span class="hljs-comment">// read and process incoming characters.</span><br>  <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;<br>    <span class="hljs-type">int</span> c = uartgetc();<br>    <span class="hljs-keyword">if</span>(c == <span class="hljs-number">-1</span>)<br>      <span class="hljs-keyword">break</span>;<br>    consoleintr(c);<br>  &#125;<br><br>  <span class="hljs-comment">// send buffered characters.</span><br>  acquire(&amp;uart_tx_lock);<br>  uartstart();<br>  release(&amp;uart_tx_lock);<br>&#125;<br><br><br><span class="hljs-comment">// read one input character from the UART.</span><br><span class="hljs-comment">// return -1 if none is waiting.</span><br><span class="hljs-type">int</span><br><span class="hljs-title function_">uartgetc</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>  <span class="hljs-keyword">if</span>(ReadReg(LSR) &amp; <span class="hljs-number">0x01</span>)&#123;<br>    <span class="hljs-comment">// input data is ready.</span><br>    <span class="hljs-keyword">return</span> ReadReg(RHR);<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li>uartintr 首先会尝试从控制寄存器 RHR 中读取一个字符
<ul>
<li>如果控制寄存器 RHR 中有字符可读, 则通过 uartgetc 函数获取相应的字符, 然后将该字符交给控制台驱动程序的中断处理程序 consoleintr 来处理 (这只是在 UART 的中断处理程序中直接调用了控制台的中断处理程序, 这并不是通过中断来实现的).
<ul>
<li>consoleintr 函数 (kernel/console.c) 如下:  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//</span><br><span class="hljs-comment">// the console input interrupt handler.</span><br><span class="hljs-comment">// uartintr() calls this for input character.</span><br><span class="hljs-comment">// do erase/kill processing, append to cons.buf,</span><br><span class="hljs-comment">// wake up consoleread() if a whole line has arrived.</span><br><span class="hljs-comment">//</span><br><span class="hljs-type">void</span><br><span class="hljs-title function_">consoleintr</span><span class="hljs-params">(<span class="hljs-type">int</span> c)</span><br>&#123;<br>  acquire(&amp;cons.lock);<br><br>  <span class="hljs-keyword">switch</span>(c)&#123;<br>  <span class="hljs-keyword">case</span> <span class="hljs-title function_">C</span><span class="hljs-params">(<span class="hljs-string">&#x27;P&#x27;</span>)</span>:  <span class="hljs-comment">// Print process list.</span><br>    <span class="hljs-title function_">procdump</span><span class="hljs-params">()</span>;<br>    <span class="hljs-keyword">break</span>;<br>  <span class="hljs-keyword">case</span> <span class="hljs-title function_">C</span><span class="hljs-params">(<span class="hljs-string">&#x27;U&#x27;</span>)</span>:  <span class="hljs-comment">// Kill line.</span><br>    <span class="hljs-title function_">while</span><span class="hljs-params">(cons.e != cons.w &amp;&amp;</span><br><span class="hljs-params">          cons.buf[(cons.e<span class="hljs-number">-1</span>) % INPUT_BUF] != <span class="hljs-string">&#x27;\n&#x27;</span>)</span>&#123;<br>      cons.e--;<br>      consputc(BACKSPACE);<br>    &#125;<br>    <span class="hljs-keyword">break</span>;<br>  <span class="hljs-keyword">case</span> <span class="hljs-title function_">C</span><span class="hljs-params">(<span class="hljs-string">&#x27;H&#x27;</span>)</span>: <span class="hljs-comment">// Backspace</span><br>  <span class="hljs-keyword">case</span> &#x27;\x7f&#x27;:<br>    <span class="hljs-title function_">if</span><span class="hljs-params">(cons.e != cons.w)</span>&#123;<br>      cons.e--;<br>      consputc(BACKSPACE);<br>    &#125;<br>    <span class="hljs-keyword">break</span>;<br>  <span class="hljs-keyword">default</span>:<br>    <span class="hljs-keyword">if</span>(c != <span class="hljs-number">0</span> &amp;&amp; cons.e-cons.r &lt; INPUT_BUF)&#123;<br>      c = (c == <span class="hljs-string">&#x27;\r&#x27;</span>) ? <span class="hljs-string">&#x27;\n&#x27;</span> : c;<br>  <br>      <span class="hljs-comment">// echo back to the user.</span><br>      consputc(c);<br><br>      <span class="hljs-comment">// store for consumption by consoleread().</span><br>      cons.buf[cons.e++ % INPUT_BUF] = c;<br><br>      <span class="hljs-keyword">if</span>(c == <span class="hljs-string">&#x27;\n&#x27;</span> || c == C(<span class="hljs-string">&#x27;D&#x27;</span>) || cons.e == cons.r+INPUT_BUF)&#123;<br>        <span class="hljs-comment">// wake up consoleread() if a whole line (or end-of-file)</span><br>        <span class="hljs-comment">// has arrived.</span><br>        cons.w = cons.e;<br>        wakeup(&amp;cons.r);<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">break</span>;<br>  &#125;<br>  release(&amp;cons.lock);<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li>在该函数中, 默认情况下字符会通过 consputc 输出到控制台上给用户查看, 然后字符会被存放在缓冲区中. 当遇到换行符时, 唤醒之前 sleep 的进程, 它会从缓冲区中读取数据.</li>
</ul>
</li>
</ul>
</li>
<li>如果控制寄存器 RHR 中没有字符可读, uartintr 并不会阻塞地等待那些尚未到达 RHR 的字符, 但也不会因此错过它们, 因为之后新的字符被用户键入时, UART 还会发出中断, 可以等到那时候再处理这些字符.</li>
</ul>
</li>
</ul>
</li>
<li>处理完 RHR 中的字符后, UART 还会接着调用 uartstart (kernel/trap.c) <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// if the UART is idle, and a character is waiting</span><br><span class="hljs-comment">// in the transmit buffer, send it.</span><br><span class="hljs-comment">// caller must hold uart_tx_lock.</span><br><span class="hljs-comment">// called from both the top- and bottom-half.</span><br><span class="hljs-type">void</span><br><span class="hljs-title function_">uartstart</span><span class="hljs-params">()</span><br>&#123;<br>  <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;<br>	<span class="hljs-keyword">if</span>(uart_tx_w == uart_tx_r)&#123;<br>      <span class="hljs-comment">// transmit buffer is empty.</span><br>      <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span>((ReadReg(LSR) &amp; LSR_TX_IDLE) == <span class="hljs-number">0</span>)&#123;<br>      <span class="hljs-comment">// the UART transmit holding register is full,</span><br>      <span class="hljs-comment">// so we cannot give it another byte.</span><br>      <span class="hljs-comment">// it will interrupt when it&#x27;s ready for a new byte.</span><br>      <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-type">int</span> c = uart_tx_buf[uart_tx_r];<br>    uart_tx_r = (uart_tx_r + <span class="hljs-number">1</span>) % UART_TX_BUF_SIZE;<br>    <span class="hljs-comment">// maybe uartputc() is waiting for space in the buffer.</span><br>    wakeup(&amp;uart_tx_r);<br>    WriteReg(THR, c);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li>在该函数中, 首先会检查 UART 的缓冲区里是否有需要 UART 发送的数据, 如果有且控制寄存器 THR 为空, 则将该字符写入到 THR 中, UART 就会发送它.</li>
</ul>
</li>
</ol>
<h3 id="用户进程-如-Shell-从控制台读取输入">用户进程 (如 Shell) 从控制台读取输入</h3>
<p>Xv6 的 Shell 可以主动地从控制台读取输入, Shell 发出 read 系统调用请求后, 最终会导向到控制台驱动程序的 top half 中, 然后执行 consoleread (kernel/console.c):</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">spinlock</span> <span class="hljs-title">lock</span>;</span><br>  <br>  <span class="hljs-comment">// input</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> INPUT_BUF 128</span><br>  <span class="hljs-type">char</span> buf[INPUT_BUF];<br>  uint r;  <span class="hljs-comment">// Read index</span><br>  uint w;  <span class="hljs-comment">// Write index</span><br>  uint e;  <span class="hljs-comment">// Edit index</span><br>&#125; cons;<br><br><span class="hljs-comment">// user read()s from the console go here.</span><br><span class="hljs-comment">// copy (up to) a whole input line to dst.</span><br><span class="hljs-comment">// user_dist indicates whether dst is a user</span><br><span class="hljs-comment">// or kernel address.</span><br><span class="hljs-comment">//</span><br><span class="hljs-type">int</span><br><span class="hljs-title function_">consoleread</span><span class="hljs-params">(<span class="hljs-type">int</span> user_dst, uint64 dst, <span class="hljs-type">int</span> n)</span><br>&#123;<br>  uint target;<br>  <span class="hljs-type">int</span> c;<br>  <span class="hljs-type">char</span> cbuf;<br><br>  target = n;<br>  acquire(&amp;cons.lock);<br>  <span class="hljs-keyword">while</span>(n &gt; <span class="hljs-number">0</span>)&#123;<br>    <span class="hljs-comment">// wait until interrupt handler has put some</span><br>    <span class="hljs-comment">// input into cons.buffer.</span><br>    <span class="hljs-keyword">while</span>(cons.r == cons.w)&#123;<br>      <span class="hljs-keyword">if</span>(myproc()-&gt;killed)&#123;<br>        release(&amp;cons.lock);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>      &#125;<br>      sleep(&amp;cons.r, &amp;cons.lock);<br>    &#125;<br><br>    c = cons.buf[cons.r++ % INPUT_BUF];<br><br>    <span class="hljs-keyword">if</span>(c == C(<span class="hljs-string">&#x27;D&#x27;</span>))&#123;  <span class="hljs-comment">// end-of-file</span><br>      <span class="hljs-keyword">if</span>(n &lt; target)&#123;<br>        <span class="hljs-comment">// Save ^D for next time, to make sure</span><br>        <span class="hljs-comment">// caller gets a 0-byte result.</span><br>        cons.r--;<br>      &#125;<br>      <span class="hljs-keyword">break</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// copy the input byte to the user-space buffer.</span><br>    cbuf = c;<br>    <span class="hljs-keyword">if</span>(either_copyout(user_dst, dst, &amp;cbuf, <span class="hljs-number">1</span>) == <span class="hljs-number">-1</span>)<br>      <span class="hljs-keyword">break</span>;<br><br>    dst++;<br>    --n;<br><br>    <span class="hljs-keyword">if</span>(c == <span class="hljs-string">&#x27;\n&#x27;</span>)&#123;<br>      <span class="hljs-comment">// a whole line has arrived, return to</span><br>      <span class="hljs-comment">// the user-level read().</span><br>      <span class="hljs-keyword">break</span>;<br>    &#125;<br>  &#125;<br>  release(&amp;cons.lock);<br><br>  <span class="hljs-keyword">return</span> target - n;<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li>该函数主要从缓冲区 cons.buf 中读取整行的输入到用户空间中, 如果 cons.buf 中没有字符可读或读完了缓冲区中的所有字符但仍未读到换行符, 那么 Shell 会自己睡眠, 直到满足条件被唤醒.</li>
</ul>
<h3 id="控制台中断处理">控制台中断处理</h3>
<p>如果有输入字符到达控制台, 控制台将会产生中断, 然后跳转到控制台的中断处理程序 consoleintr 中:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// the console input interrupt handler.</span><br><span class="hljs-comment">// uartintr() calls this for input character.</span><br><span class="hljs-comment">// do erase/kill processing, append to cons.buf,</span><br><span class="hljs-comment">// wake up consoleread() if a whole line has arrived.</span><br><span class="hljs-comment">//</span><br><span class="hljs-type">void</span><br><span class="hljs-title function_">consoleintr</span><span class="hljs-params">(<span class="hljs-type">int</span> c)</span><br>&#123;<br>  acquire(&amp;cons.lock);<br><br>  <span class="hljs-keyword">switch</span>(c)&#123;<br>  <span class="hljs-keyword">case</span> <span class="hljs-title function_">C</span><span class="hljs-params">(<span class="hljs-string">&#x27;P&#x27;</span>)</span>:  <span class="hljs-comment">// Print process list.</span><br>    <span class="hljs-title function_">procdump</span><span class="hljs-params">()</span>;<br>    <span class="hljs-keyword">break</span>;<br>  <span class="hljs-keyword">case</span> <span class="hljs-title function_">C</span><span class="hljs-params">(<span class="hljs-string">&#x27;U&#x27;</span>)</span>:  <span class="hljs-comment">// Kill line.</span><br>    <span class="hljs-title function_">while</span><span class="hljs-params">(cons.e != cons.w &amp;&amp;</span><br><span class="hljs-params">          cons.buf[(cons.e<span class="hljs-number">-1</span>) % INPUT_BUF] != <span class="hljs-string">&#x27;\n&#x27;</span>)</span>&#123;<br>      cons.e--;<br>      consputc(BACKSPACE);<br>    &#125;<br>    <span class="hljs-keyword">break</span>;<br>  <span class="hljs-keyword">case</span> <span class="hljs-title function_">C</span><span class="hljs-params">(<span class="hljs-string">&#x27;H&#x27;</span>)</span>: <span class="hljs-comment">// Backspace</span><br>  <span class="hljs-keyword">case</span> &#x27;\x7f&#x27;:<br>    <span class="hljs-title function_">if</span><span class="hljs-params">(cons.e != cons.w)</span>&#123;<br>      cons.e--;<br>      consputc(BACKSPACE);<br>    &#125;<br>    <span class="hljs-keyword">break</span>;<br>  <span class="hljs-keyword">default</span>:<br>    <span class="hljs-keyword">if</span>(c != <span class="hljs-number">0</span> &amp;&amp; cons.e-cons.r &lt; INPUT_BUF)&#123;<br>      c = (c == <span class="hljs-string">&#x27;\r&#x27;</span>) ? <span class="hljs-string">&#x27;\n&#x27;</span> : c;<br><br>      <span class="hljs-comment">// echo back to the user.</span><br>      consputc(c);<br><br>      <span class="hljs-comment">// store for consumption by consoleread().</span><br>      cons.buf[cons.e++ % INPUT_BUF] = c;<br><br>      <span class="hljs-keyword">if</span>(c == <span class="hljs-string">&#x27;\n&#x27;</span> || c == C(<span class="hljs-string">&#x27;D&#x27;</span>) || cons.e == cons.r+INPUT_BUF)&#123;<br>        <span class="hljs-comment">// wake up consoleread() if a whole line (or end-of-file)</span><br>        <span class="hljs-comment">// has arrived.</span><br>        cons.w = cons.e;<br>        wakeup(&amp;cons.r);<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">break</span>;<br>  &#125;<br>  <br>  release(&amp;cons.lock);<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li>该函数会将输入字符缓冲到 cons.buf 中, 直到 cons.buf 里累积了一整行的输入, 如果之前有用户进程因为调用 consoleread 而睡眠, 那么 consoleintr 会唤醒该用户进程的 consoleread, 然后 consoleread 将缓冲在 cons.buf 中的一整行输入拷贝到用户空间中, 再返回到用户进程.
<ul>
<li>当 consoleinstr 唤醒一个进程的 consoleread 时, 该进程之前已经主动地使用 consoleread 读出一行中的部分输入, 现在被唤醒之后, 就可以顺利地读完这行的全部内容 (到换行符 ‘\n’ 或文件结束符 ‘ctrl + D’ 为止).</li>
</ul>
</li>
</ul>
<h2 id="控制台输出">控制台输出</h2>
<p>首先看总体流程: 当用户进程需要产生一些输出到控制台上,    以便通过屏幕显示给用户. 用户进程 (如 Shell) 会通过系统调用 write ,    往 UART 的发送缓冲区写入一些字符,    然后用户进程就可以返回了. UART 会在适当的时候将一个字符写入控制寄存器 THR 中,    最后 UART 会将字符发送到控制台,    控制台呈现输出给用户.</p>
<p>UART 的<strong>发送缓冲区</strong>定义如下,    该发送缓冲区 uart_tx_buf 由 UART 的驱动程序维护:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// the transmit output buffer.</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">spinlock</span> <span class="hljs-title">uart_tx_lock</span>;</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> UART_TX_BUF_SIZE 32</span><br><span class="hljs-type">char</span> uart_tx_buf[UART_TX_BUF_SIZE];<br><span class="hljs-type">int</span> uart_tx_w; <span class="hljs-comment">// write next to uart_tx_buf[uart_tx_w++]</span><br><span class="hljs-type">int</span> uart_tx_r; <span class="hljs-comment">// read next from uart_tx_buf[uar_tx_r++]</span><br></code></pre></td></tr></table></figure>
<p>首先查看 Shell 程序如何将提示符 “$” 发送到 Console 中.</p>
<ol>
<li>首先在 main (kernel/init.c) 中: <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span><br><span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>  <span class="hljs-type">int</span> pid, wpid;<br><br>  <span class="hljs-keyword">if</span>(open(<span class="hljs-string">&quot;console&quot;</span>, O_RDWR) &lt; <span class="hljs-number">0</span>)&#123;<br>    mknod(<span class="hljs-string">&quot;console&quot;</span>, CONSOLE, <span class="hljs-number">0</span>);<br>    open(<span class="hljs-string">&quot;console&quot;</span>, O_RDWR);<br>  &#125;<br>  dup(<span class="hljs-number">0</span>);  <span class="hljs-comment">// stdout</span><br>  dup(<span class="hljs-number">0</span>);  <span class="hljs-comment">// stderr</span><br>  ...<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li>在这里用 mknod 创建了三个控制台的文件描述符.
<ul>
<li>第一个用 open 创建, 后面两个用 dup 复制, 分别对应标准输入、标准输出和标准错误.</li>
</ul>
</li>
</ul>
</li>
<li>Shell 复制了父进程的三个控制台的文件描述符, 然后向文件描述符 2 中打印提示符 “$” (user/sh.c): <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span><br><span class="hljs-title function_">getcmd</span><span class="hljs-params">(<span class="hljs-type">char</span> *buf, <span class="hljs-type">int</span> nbuf)</span><br>&#123;<br>  <span class="hljs-built_in">fprintf</span>(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;$ &quot;</span>);<br>  <span class="hljs-built_in">memset</span>(buf, <span class="hljs-number">0</span>, nbuf);<br>  gets(buf, nbuf);<br>  <span class="hljs-keyword">if</span>(buf[<span class="hljs-number">0</span>] == <span class="hljs-number">0</span>) <span class="hljs-comment">// EOF</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li>fprintf 函数调用 vprintf 函数, 而 vprintf 函数调用 putc 函数 (user/printf.c): <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span><br><span class="hljs-title function_">putc</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, <span class="hljs-type">char</span> c)</span><br>&#123;<br>  write(fd, &amp;c, <span class="hljs-number">1</span>);		<br>&#125;		<br></code></pre></td></tr></table></figure>
<ul>
<li>其中 putc 函数只是调用了 write 系统调用.</li>
</ul>
</li>
<li>此时 Shell 输出的每个字符都会触发一个 write 系统调用, 最终会跳转到 sys_write 函数中 (kernel/sysfile.c): <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c">uint64<br><span class="hljs-title function_">sys_write</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file</span> *<span class="hljs-title">f</span>;</span><br>  <span class="hljs-type">int</span> n;<br>  uint64 p;<br><br>  <span class="hljs-keyword">if</span>(argfd(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, &amp;f) &lt; <span class="hljs-number">0</span> || argint(<span class="hljs-number">2</span>, &amp;n) &lt; <span class="hljs-number">0</span> || argaddr(<span class="hljs-number">1</span>, &amp;p) &lt; <span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br><br>  <span class="hljs-keyword">return</span> filewrite(f, p, n);<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li>这个函数首先对参数做了检查, 然后调用 filewrite 函数.</li>
</ul>
</li>
<li>filewrite 函数: <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Write to file f.</span><br><span class="hljs-comment">// addr is a user virtual address.</span><br><span class="hljs-type">int</span><br><span class="hljs-title function_">filewrite</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> file *f, uint64 addr, <span class="hljs-type">int</span> n)</span><br>&#123;<br>  <span class="hljs-type">int</span> r, ret = <span class="hljs-number">0</span>;<br><br>  <span class="hljs-keyword">if</span>(f-&gt;writable == <span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br><br>  <span class="hljs-keyword">if</span>(f-&gt;type == FD_PIPE)&#123;<br>    ret = pipewrite(f-&gt;pipe, addr, n);<br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(f-&gt;type == FD_DEVICE)&#123;<br>    <span class="hljs-keyword">if</span>(f-&gt;major &lt; <span class="hljs-number">0</span> || f-&gt;major &gt;= NDEV || !devsw[f-&gt;major].write)<br>      <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    ret = devsw[f-&gt;major].write(<span class="hljs-number">1</span>, addr, n);<br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(f-&gt;type == FD_INODE)&#123;<br>    <span class="hljs-comment">// write a few blocks at a time to avoid exceeding</span><br>    <span class="hljs-comment">// the maximum log transaction size, including</span><br>    <span class="hljs-comment">// i-node, indirect block, allocation blocks,</span><br>    <span class="hljs-comment">// and 2 blocks of slop for non-aligned writes.</span><br>    <span class="hljs-comment">// this really belongs lower down, since writei()</span><br>    <span class="hljs-comment">// might be writing a device like the console.</span><br>    <span class="hljs-type">int</span> max = ((MAXOPBLOCKS<span class="hljs-number">-1</span><span class="hljs-number">-1</span><span class="hljs-number">-2</span>) / <span class="hljs-number">2</span>) * BSIZE;<br>    <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(i &lt; n)&#123;<br>      <span class="hljs-type">int</span> n1 = n - i;<br>      <span class="hljs-keyword">if</span>(n1 &gt; max)<br>        n1 = max;<br><br>      begin_op();<br>      ilock(f-&gt;ip);<br>      <span class="hljs-keyword">if</span> ((r = writei(f-&gt;ip, <span class="hljs-number">1</span>, addr + i, f-&gt;off, n1)) &gt; <span class="hljs-number">0</span>)<br>        f-&gt;off += r;<br>      iunlock(f-&gt;ip);<br>      end_op();<br><br>      <span class="hljs-keyword">if</span>(r &lt; <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">break</span>;<br>      <span class="hljs-keyword">if</span>(r != n1)<br>        panic(<span class="hljs-string">&quot;short filewrite&quot;</span>);<br>      i += r;<br>    &#125;<br>    ret = (i == n ? n : <span class="hljs-number">-1</span>);<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    panic(<span class="hljs-string">&quot;filewrite&quot;</span>);<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> ret;<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li>在 filewrite 函数中, 首先会判断文件描述符的类型. 由于 mknod 生成的文件描述符属于设备, 我们会为这个特定的设备执行相应的 write 函数.</li>
</ul>
</li>
<li>由于现在的设备是控制台, 则在 filewrite 函数中会调用 consolewrite 函数 (kernel/console.c): <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//</span><br><span class="hljs-comment">// user write()s to the console go here.</span><br><span class="hljs-comment">//</span><br><span class="hljs-type">int</span><br><span class="hljs-title function_">consolewrite</span><span class="hljs-params">(<span class="hljs-type">int</span> user_src, uint64 src, <span class="hljs-type">int</span> n)</span><br>&#123;<br>  <span class="hljs-type">int</span> i;<br><br>  acquire(&amp;cons.lock);<br>  <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>    <span class="hljs-type">char</span> c;<br>    <span class="hljs-keyword">if</span>(either_copyin(&amp;c, user_src, src+i, <span class="hljs-number">1</span>) == <span class="hljs-number">-1</span>)<br>      <span class="hljs-keyword">break</span>;<br>    uartputc(c);<br>  &#125;<br>  release(&amp;cons.lock);<br><br>  <span class="hljs-keyword">return</span> i;<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li>该函数先调用 either_copyin 将字符拷贝进来, 然后调用 uartputc 函数.</li>
<li>你可以认为 consolewrite 是 UART 驱动程序的 top half.</li>
</ul>
</li>
<li>uartputc 函数 (kernel/uart.c) 将字符写入 UART 设备的缓冲区中: <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// add a character to the output buffer and tell the</span><br><span class="hljs-comment">// UART to start sending if it isn&#x27;t already.</span><br><span class="hljs-comment">// blocks if the output buffer is full.</span><br><span class="hljs-comment">// because it may block,    it can&#x27;t be called</span><br><span class="hljs-comment">// from interrupts; it&#x27;s only suitable for use</span><br><span class="hljs-comment">// by write().</span><br><span class="hljs-type">void</span><br><span class="hljs-title function_">uartputc</span><span class="hljs-params">(<span class="hljs-type">int</span> c)</span><br>&#123;<br>  acquire(&amp;uart_tx_lock);<br><br>  <span class="hljs-keyword">if</span>(panicked)&#123;<br>    <span class="hljs-keyword">for</span>(;;)<br>      ;<br>  &#125;<br><br>  <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;<br>    <span class="hljs-keyword">if</span>(((uart_tx_w + <span class="hljs-number">1</span>) % UART_TX_BUF_SIZE) == uart_tx_r)&#123;<br>      <span class="hljs-comment">// buffer is full.</span><br>      <span class="hljs-comment">// wait for uartstart() to open up space in the buffer.</span><br>      sleep(&amp;uart_tx_r,    &amp;uart_tx_lock);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      uart_tx_buf[uart_tx_w] = c;<br>      uart_tx_w = (uart_tx_w + <span class="hljs-number">1</span>) % UART_TX_BUF_SIZE;<br>      uartstart();<br>      release(&amp;uart_tx_lock);<br>      <span class="hljs-keyword">return</span>;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li>对于用户进程来说, 只需要通过 uartputc 向发送缓冲区中写入一个字符,    并且调用 uartstart. 如果发送缓冲区已满,    驱动程序会暂时将该进程挂起来,  让它睡眠.</li>
<li>显然现在发送缓冲区没有满, 因为 “$” 是我们发送的第一个字符, 所以字符会被写入发送缓冲区中, 然后再调用 uartstart 函数.</li>
</ul>
</li>
<li>uartstart 函数 (kernel/uart.c) 的主要工作是尝试发送一个位于发送缓冲区的字符 (按照 FIFO 的方式). <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// if the UART is idle,    and a character is waiting</span><br><span class="hljs-comment">// in the transmit buffer,    send it.</span><br><span class="hljs-comment">// caller must hold uart_tx_lock.</span><br><span class="hljs-comment">// called from both the top- and bottom-half.</span><br><span class="hljs-type">void</span><br><span class="hljs-title function_">uartstart</span><span class="hljs-params">()</span><br>&#123;<br>  <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;<br>    <span class="hljs-keyword">if</span>(uart_tx_w == uart_tx_r)&#123;<br>      <span class="hljs-comment">// transmit buffer is empty.</span><br>      <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <br>    <span class="hljs-keyword">if</span>((ReadReg(LSR) &amp; LSR_TX_IDLE) == <span class="hljs-number">0</span>)&#123;<br>      <span class="hljs-comment">// the UART transmit holding register is full,   </span><br>      <span class="hljs-comment">// so we cannot give it another byte.</span><br>      <span class="hljs-comment">// it will interrupt when it&#x27;s ready for a new byte.</span><br>      <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <br>    <span class="hljs-type">int</span> c = uart_tx_buf[uart_tx_r];<br>    uart_tx_r = (uart_tx_r + <span class="hljs-number">1</span>) % UART_TX_BUF_SIZE;<br>    <br>    <span class="hljs-comment">// maybe uartputc() is waiting for space in the buffer.</span><br>    wakeup(&amp;uart_tx_r);<br>    <br>    WriteReg(THR,    c);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li>如果发送缓冲区为空或者控制寄存器 THR 还持有字符 (这表明对于上一个字符,    UART 的发送已经就绪,    只是还未发送出去),    那么 uartstart 将直接返回.</li>
<li>如果发送缓冲区不为空且控制寄存器 THR 为空,    则将缓冲区中的一个字符写入寄存器 THR 中, 之后 UART 就会发送 THR 中的字符; 同时唤醒一个可能在睡眠的 uartputc 进程,    因为此时发送缓冲区中有空的位置.</li>
<li>当前情况下设备空闲, 所以会将数据写入 THR 寄存器, 然后系统调用就直接返回, UART 设备会将数据发送出去.</li>
</ul>
</li>
</ol>
<ul>
<li>UART 中断处理程序 uartintr 中也会调用 uartstart, 控制台输入中讨论的情况是接收中断,    这里相关的是发送完成中断: 每当 UART 发送完一个字符之后,    就会产生发送完成中断,    然后通过中断引发 Trap,    内核检查发现是设备中断,    在 devintr 中发现是 UART 中断,    最后又跳转到 UART 中断处理程序 uartintr. 在 uartintr 的后半部分会调用 uartstart,    那么,    当 UART 发送完一个字符,    又会通过中断调用 uartstart 继续发送字符. 一般来说,    如果一个用户进程写入了多个字符,    第一个字符由 uartputc 调用 uartstart 发送,    剩下则的通过发送完成中断发送.</li>
<li>我们可以看到,   无论该字符能不能马上被 UART 发送出去,   uartstart 都会很快就返回,   因此我们可以认为 uartstart 几乎是无阻塞的. 再返回到上一层,   在 uartputc 中,   我们要么会调用uartstart,   要么让当前进程挂起并睡眠,   因此 uartputc 也是很快就返回的. 所以,   UART 暴露给用户程序或内核的 uartputc 接口是异步的,   即调用该接口不会阻塞调用者. 这种异步的特性使得用户程序可以很快地进行后续操作,   或让出 CPU 资源,   从而提高了系统的并发性能.</li>
<li>uartputc 也提供了同步或者说阻塞版本,  uartputc_sync. 该版本的接口,  用于满足那些需要<strong>马上响应</strong>的需求,  因此CPU就阻塞在某处,  直到 THR 中的字符被发送,  然后就把需要发送的新字符写入 THR. 你也可以看到,  该字符不会写入发送缓冲区中. 事实上,  内核的 printf 就使用这个同步的版本,  因为内核打印的消息比较重要,  我们希望能尽快地显示给用户.  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// alternate version of uartputc() that doesn&#x27;t </span><br><span class="hljs-comment">// use interrupts, for use by kernel printf() and</span><br><span class="hljs-comment">// to echo characters. it spins waiting for the uart&#x27;s</span><br><span class="hljs-comment">// output register to be empty.</span><br><span class="hljs-type">void</span><br><span class="hljs-title function_">uartputc_sync</span><span class="hljs-params">(<span class="hljs-type">int</span> c)</span><br>&#123;<br>  push_off();<br><br>  <span class="hljs-keyword">if</span>(panicked)&#123;<br>    <span class="hljs-keyword">for</span>(;;)<br>      ;<br>  &#125;<br><br>  <span class="hljs-comment">// wait for Transmit Holding Empty to be set in LSR.</span><br>  <span class="hljs-keyword">while</span>((ReadReg(LSR) &amp; LSR_TX_IDLE) == <span class="hljs-number">0</span>)<br>    ;<br>  WriteReg(THR, c);<br><br>  pop_off();<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
</ul>
<p>通过控制台输入和控制台输出的两个样例,  我们可以认识到: <strong>设备行为</strong>和<strong>用户进程行为</strong>的<strong>解耦</strong>是一个很好的模式, 这种模式可以利用<strong>缓冲</strong>和<strong>中断</strong>两种机制来实现. 控制台驱动程序可以处理用户输入, 尽管当前没有用户进程想要读取输入, 但即使是以后才发生的读取, 也能看到这些输入; 类似的, 用户进程可以简单地写入数据就马上离开, 而不需要等待设备驱动程序的处理. 这些行为都表现出良好的效率, 因为设备和用户进程的解耦允许它们<strong>并发</strong>地执行, 这会带来很多好处, 尤其是用户进程比设备快得多的时候, 这种思想称为 <strong>I/O并发性</strong>.</p>
<h2 id="驱动程序中的并发性">驱动程序中的并发性</h2>
<p>对于驱动程序中的一些数据结构,   多个进程会并发地访问它们,   因此我们需要锁来保护这些数据结构.</p>
<p>如果不使用锁,   可能存在以下并发问题:</p>
<ul>
<li>两个不同 CPU 上的进程同时调用 consoleread.</li>
<li>硬件可能会在一个 CPU 正在执行 consoleread 时向该 CPU 抛出一个 UART 中断,   此时原进程会在内核中阻塞等待数据的到来,   当 UART 中断发生时,   处理中断的代码可能会修改控制台缓冲区,   这会导致原来执行 consoleread 的进程得到的结果不正确.</li>
<li>当 consoleread 执行时,   硬件可能会向另一个 CPU 抛出一个 UART 中断.</li>
</ul>
<p>还有一种需要注意的情况是,  一个进程可能正在等待设备工作的完成,  但是当该设备的工作完成并产生中断时,  正在运行的是另一个进程. 因为这种原因,  中断处理程序不应该认为当前运行的进程就是它所要交付工作的进程. 因此, 更好的方式是, 中断处理程序只做很小一部分工作, 例如将数据拷贝到缓冲区中, 然后在 top half 中, 唤醒特定的进程来完成剩下的工作.</p>
<h2 id="Reference">Reference</h2>
<section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>MIT 6.S081 Operating System Engineering: <a target="_blank" rel="noopener" href="https://pdos.csail.mit.edu/6.S081/2020/schedule.html">https://pdos.csail.mit.edu/6.S081/2020/schedule.html</a>
<a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span>xv6: a simple, Unix-like teaching operating system: <a target="_blank" rel="noopener" href="https://pdos.csail.mit.edu/6.S081/2020/xv6/book-riscv-rev1.pdf">https://pdos.csail.mit.edu/6.S081/2020/xv6/book-riscv-rev1.pdf</a>
<a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:3" class="footnote-text"><span>Chapter 5: Interrupts and Device Drivers: <a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/352432393">https://zhuanlan.zhihu.com/p/352432393</a>
<a href="#fnref:3" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>
                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/%E7%AC%94%E8%AE%B0/" class="category-chain-item">笔记</a>
  
  
    <span>></span>
    
  <a href="/categories/%E7%AC%94%E8%AE%B0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" class="category-chain-item">操作系统</a>
  
  

  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/MIT-6-S081/" class="print-no-link">#MIT 6.S081</a>
      
        <a href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" class="print-no-link">#操作系统</a>
      
        <a href="/tags/Xv6/" class="print-no-link">#Xv6</a>
      
    </div>
  
</div>


              

              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2024/07/04/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E9%94%81/" title="锁">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">锁</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2024/07/04/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%B0%83%E7%94%A8%E7%BA%A6%E5%AE%9A%E5%92%8C%E5%A0%86%E6%A0%88%E5%B8%A7/" title="调用约定和堆栈帧">
                        <span class="hidden-mobile">调用约定和堆栈帧</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
