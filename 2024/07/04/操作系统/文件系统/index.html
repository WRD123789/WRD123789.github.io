

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=light>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/bg/3.png">
  <link rel="icon" href="/img/bg/3.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Wangrd">
  <meta name="keywords" content="">
  
    <meta name="description" content="文件系统 文件和目录 文件 (File): 文件可以看成一个线性字节数组,  每个字节都可以读出或写入. 每个文件都有某种低级名称,  通常称为 Inode number.  inode (索引节点, Index Node) 是在 Unix&#x2F;Linux 文件系统中用于存储文件元数据的数据结构. 每个文件或目录都与一个唯一的 inode 相关联. inode 包含了文件的详细信息. inode 包含">
<meta property="og:type" content="article">
<meta property="og:title" content="文件系统">
<meta property="og:url" content="http://example.com/2024/07/04/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/index.html">
<meta property="og:site_name" content="Wangrd&#39;s Blog">
<meta property="og:description" content="文件系统 文件和目录 文件 (File): 文件可以看成一个线性字节数组,  每个字节都可以读出或写入. 每个文件都有某种低级名称,  通常称为 Inode number.  inode (索引节点, Index Node) 是在 Unix&#x2F;Linux 文件系统中用于存储文件元数据的数据结构. 每个文件或目录都与一个唯一的 inode 相关联. inode 包含了文件的详细信息. inode 包含">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/Pictures/20230505083854.png">
<meta property="og:image" content="http://example.com/img/Pictures/20230506153309.png">
<meta property="og:image" content="http://example.com/img/Pictures/20230508103101.png">
<meta property="og:image" content="http://example.com/img/Pictures/20230514150429.png">
<meta property="og:image" content="http://example.com/img/Pictures/20230514153932.png">
<meta property="og:image" content="http://example.com/img/Pictures/20230514170129.png">
<meta property="og:image" content="http://example.com/img/Pictures/20230514171743.png">
<meta property="og:image" content="http://example.com/img/Pictures/20230517172047.png">
<meta property="og:image" content="http://example.com/img/Pictures/20230517182738.png">
<meta property="og:image" content="http://example.com/img/Pictures/20230521141331.png">
<meta property="og:image" content="http://example.com/img/Pictures/20230521142048.png">
<meta property="og:image" content="http://example.com/img/Pictures/20230521142850.png">
<meta property="og:image" content="http://example.com/img/Pictures/20230522151105.png">
<meta property="og:image" content="http://example.com/img/Pictures/20230522151749.png">
<meta property="og:image" content="http://example.com/img/Pictures/20230522161514.png">
<meta property="og:image" content="http://example.com/img/Pictures/20230522163216.png">
<meta property="og:image" content="http://example.com/img/Pictures/20230522163337.png">
<meta property="og:image" content="http://example.com/img/Pictures/20230527150857.png">
<meta property="og:image" content="http://example.com/img/Pictures/20230527151825.png">
<meta property="og:image" content="http://example.com/img/Pictures/20230527153219.png">
<meta property="og:image" content="http://example.com/img/Pictures/20230527153354.png">
<meta property="og:image" content="http://example.com/img/Pictures/20230527154441.png">
<meta property="og:image" content="http://example.com/img/Pictures/20230527191412.png">
<meta property="og:image" content="http://example.com/img/Pictures/20230529190019.png">
<meta property="og:image" content="http://example.com/img/Pictures/20230529200244.png">
<meta property="og:image" content="http://example.com/img/Pictures/20231219145450.png">
<meta property="article:published_time" content="2024-07-04T03:56:45.000Z">
<meta property="article:modified_time" content="2024-07-04T10:39:40.330Z">
<meta property="article:author" content="Wangrd">
<meta property="article:tag" content="MIT 6.S081">
<meta property="article:tag" content="操作系统">
<meta property="article:tag" content="Xv6">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://example.com/img/Pictures/20230505083854.png">
  
  
  
  <title>文件系统 - Wangrd&#39;s Blog</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/KaTeX/0.16.2/katex.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.9.7","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 7.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Wangrd&#39;s Blog</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/bg/1.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="文件系统"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2024-07-04 11:56" pubdate>
          2024年7月4日 中午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          32k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          268 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">文件系统</h1>
            
            
              <div class="markdown-body">
                
                <h1>文件系统</h1>
<h2 id="文件和目录">文件和目录</h2>
<p><strong>文件 (File)</strong>: 文件可以看成一个线性字节数组,  每个字节都可以读出或写入. 每个文件都有某种低级名称,  通常称为 Inode number.</p>
<ul>
<li><strong><code>inode</code> (索引节点, Index Node)</strong> 是在 Unix/Linux 文件系统中用于存储文件元数据的数据结构. 每个文件或目录都与一个唯一的 inode 相关联. <code>inode</code> 包含了文件的详细信息. <code>inode</code> 包含的文件元数据信息通常包括:
<ul>
<li><strong>文件类型</strong>: 指定文件是普通文件、目录、软链接等.</li>
<li><strong>文件权限</strong>: 指定文件的访问权限，包括读、写和执行权限.</li>
<li><strong>所有者信息</strong>: 包括文件的用户 ID 和组 ID, 指定文件的所有者和所属组.</li>
<li><strong>文件大小</strong>: 文件中存储的字节数.</li>
<li><strong>时间戳</strong>: 记录文件的创建时间、最后修改时间和最后访问时间.</li>
<li><strong>链接计数</strong>: 记录有多少个文件目录项指向同一个 <code>inode</code>.</li>
<li><strong>数据块指针</strong>: 指向存储文件实际数据的数据块.</li>
</ul>
</li>
<li><strong>目录项</strong>是文件系统中目录中的一个条目, 用于存储有关文件或子目录的信息. 每个文件或子目录都有一个相应的文件目录项. 文件目录项包含文件名、文件类型、权限、时间戳等信息, 以及与之关联的 <code>inode</code> 的 <code>inode</code> 号.</li>
</ul>
<p><strong>目录 (Directory)</strong>: 目录也有 Inode number. 目录的内容更具体: 它包含了<strong>目录项的列表</strong>. 目录中的每个目录项对应着文件系统中的一个文件或子目录.</p>
<p>目录中的每个条目都指向文件或其它目录,  通过将目录放入其它目录中,  用户就可以构建目录层次结构或目录树,  并在该目录树下存储所有文件和目录.</p>
<ul>
<li>
<p>例如:<br>
<img src="/img/Pictures/20230505083854.png" srcset="/img/loading.gif" lazyload alt=""></p>
<p>在 Unix 操作系统中,  目录层次结构通常从<strong>根目录</strong>开始,  一般用 “/” 表示,  并使用 “/” 来分隔后续子目录. 一个目录或文件可以用<strong>绝对路径</strong>或<strong>相对路径</strong>来表示.</p>
<ul>
<li>绝对路径从根目录开始, 因此路径名从 “/” 开始, 如 /foo/bar.txt.</li>
<li>相对路径从当前工作目录开始, 因此路径名从当前工作目录中的目录或文件开始, 例如当前工作目录为 /bar 时, 相对路径可以是 bar、foo、foo/bar.txt.</li>
</ul>
<p>目录和文件可以具有相同的名称, 只要它们位于文件系统树的不同位置, 例如 /foo/bar.txt 和 /bar/foo/bar.txt.</p>
</li>
</ul>
<h3 id="文件描述符">文件描述符</h3>
<p><strong>文件描述符</strong>是一个非负整数, 对于内核而言, 所有打开的文件都通过文件描述符引用. 当打开或创建一个文件时, 内核就向进程返回一个文件描述符, 然后后续的读和写就使用该文件描述符来标识该文件, 将其作为参数传递给 read 和 write 等函数.</p>
<p>按惯例, UNIX 系统 Shell 将 fd0 与进程标准输入关联, fd1 与标准输出关联, fd2 与标准错误关联, 各种 Shell 和应用程序都遵循这个惯例.</p>
<h3 id="文件相关函数">文件相关函数</h3>
<ol>
<li>
<p>open</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">open</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *path,  <span class="hljs-type">int</span> oflag,  ... <span class="hljs-comment">/* mode_t mode */</span>)</span>;<br></code></pre></td></tr></table></figure>
<p>open 用来打开或者创建一个文件. 它返回最小的未用文件描述符, 输入参数如下:</p>
<ul>
<li>path 是要打开或创建文件的名字, 通常为绝对路径, 如果希望使用相对路径, 可以使用 openat 函数.</li>
<li>oflag 用来说明 open 函数的多个选项, 可以用以下一个或多个常量进行或运算构成 oflag 参数:
<ul>
<li>必须且只能指定一个的常量有: O_RDONLY、O_WRONLY、O_RDWR、O_EXEC、O_SEARCH.</li>
<li>可选的部分常量有: O_APPEND、O_CREAT、O_DIRECTORY、O_EXCL、O_SYNC、O_TRUNC等.</li>
</ul>
</li>
<li>mode 仅当创建新文件时使用, 即 oflag 设置了 O_CREAT 时, 它指定了新文件的访问权限位.</li>
</ul>
</li>
<li>
<p>create</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">creat</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *path,  <span class="hljs-type">mode_t</span> mode)</span>;<br><span class="hljs-comment">// 此creat函数等效于:</span><br><span class="hljs-comment">// open(path,  O_WRONLY|O_CREAT|O_TRUNC,  mode);</span><br></code></pre></td></tr></table></figure>
<p>create 用来创建一个新文件, 它只能以只写的形式打开所创建的新文件, 所以不如 open 方便.</p>
</li>
<li>
<p>close</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">close</span><span class="hljs-params">(<span class="hljs-type">int</span> fd)</span>;<br></code></pre></td></tr></table></figure>
<p>close 可以关闭一个已经打开的文件, 同时释放该进程加在该文件上的所有记录锁. 实际上, 当一个进程终止时, 内核自动关闭它的所有打开文件, 很多程序利用这一点而不显式地调用 close 关闭打开文件.</p>
</li>
<li>
<p>Lseek</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-type">off_t</span> <span class="hljs-title function_">lseek</span><span class="hljs-params">(<span class="hljs-type">int</span> fd,   <span class="hljs-type">off_t</span> offset,   <span class="hljs-type">int</span> whence)</span>;<br></code></pre></td></tr></table></figure>
<p>每个打开文件都有一个与其相关联的<strong>当前文件偏移量</strong>,  通常是一个非负整数,  用于度量从文件开始处计算的字节数. 一般读、写操作都从当前文件偏移量处开始,  并使偏移量增加所读写的字节数. 打开一个文件时,  除非指定了 O_APPEND 选项,  否则偏移量设置为 0.</p>
<p>调用 <strong>lseek</strong> 可以显式地对一个打开文件设置偏移量,  参数 <strong>offset</strong> 的解释与 <strong>whence</strong> 的值有关:</p>
<ul>
<li>若 whence 是 SEEK_SET,  偏移量设置为文件开始处 + offset.</li>
<li>若 whence 是 SEEK_CUR,  偏移量设置为当前偏移量值 + offset,  offset 可正可负.</li>
<li>若 whence 是 SEEK_END,  偏移量设置为文件长度 + offset,  offset 可正可负.</li>
</ul>
<p>如果 lseek 成功执行,  则返回新的文件偏移量. 如果文件描述符 fd 指向的是一个管道、FIFO 或网络套接字等不能设置偏移量的文件,  那么 lseek 返回 -1.</p>
<p>lseek 只是将当前的文件偏移量记录在内核中,  本身并不引起任何 I/O 操作,  该偏移量被用于下一个读或写操作.</p>
<p>文件偏移量可以大于文件的当前长度, 此时对该文件的下一次写将加长该文件, 并在文件中构成一个空洞, 即位于文件中但没有被写过的字节都被读为 0. 文件空洞并不要求在磁盘上占用存储区, 具体处理方式与文件系统实现有关.</p>
<ul>
<li>例如当定位超出文件尾端之后写时, 对于新写的数据需要分配磁盘块, 但是位于原文件尾端和新开始写的位置之间的部分, 则不需要分配磁盘块.</li>
</ul>
</li>
<li>
<p>read</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-type">ssize_t</span> <span class="hljs-title function_">read</span><span class="hljs-params">(<span class="hljs-type">int</span> fd,   <span class="hljs-type">void</span> *buf,   <span class="hljs-type">size_t</span> nbytes)</span>;<br></code></pre></td></tr></table></figure>
<p>read 从打开文件中读数据. 如果 read 执行成功,   返回的是读到的字节数; 如果已到达文件的尾端,   则返回 0; 如果出错,   返回 -1.</p>
<p>读操作会从文件的当前偏移量开始,   在成功返回之前,   该偏移量将增加实际读到的字节数. ssize_t类型带符号,  而 size_t 类型不带符号.</p>
<p>有多种情况可以使得实际读到的字节数少于要求读的字节数:</p>
<ul>
<li>读普通文件时,  在读到要求字节数之前就到达了文件尾端.</li>
<li>从终端设备读时,  通常一次最多读一行.</li>
<li>从网络读时,  网络中的缓冲机制可能造成返回值小于所要求读的字节数.</li>
<li>从管道或 FIFO 读时,  若管道包含的字节少于所需的数量,  那么将只返回实际可用字节数.</li>
<li>从某些面向记录的设备（如磁带）读时,  一次最多返回一个记录.</li>
<li>已经读了部分数据,  但是被一个信号造成中断.</li>
</ul>
</li>
<li>
<p>write</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-type">ssize_t</span> <span class="hljs-title function_">write</span><span class="hljs-params">(<span class="hljs-type">int</span> fd,   <span class="hljs-type">const</span> <span class="hljs-type">void</span> *buf,   <span class="hljs-type">size_t</span> nbytes)</span>;<br></code></pre></td></tr></table></figure>
<p>write 向打开文件写数据. 和 read 类似,  write 成功时返回写入的字节数; 否则在出错时返回 -1.</p>
<ul>
<li>write 出错的常见原因是磁盘已经写满,  或者超过了一个给定进程的文件长度限制.</li>
</ul>
<p>对于普通文件,  写操作从文件的当前偏移量处开始. 如果在打开文件时指定了 O_APPEND 选项,  则在每次写操作之前,  都将文件偏移量设置在文件的当前结尾处,  并在一次成功写入之后,  该文件偏移量增加实际写入的字节数.</p>
<p>在文件末尾追加时, 使用 O_APPEND 选项和使用 lseek 定位到文件尾端是不同的, 主要不同在于操作的原子性: O_APPEND 使得内核在每次写操作之前, 都先更新文件的当前偏移量, 这使得写操作和更新偏移量合并成一个<strong>原子操作</strong>, 即使多个进程追加同一文件, 也不会出现覆盖的情况; 而使用 lseek 方法的话, 写操作和更新偏移量是两个不同的函数, 不具有原子性.</p>
<p>如果使用 O_APPEND 选项打开一个文件以便读、写, 那么仍然可以用 lseek 和 read 读取文件中任意一个位置的内容, 但是 write 在写之前会自动将文件偏移量设置为文件尾, 因此写该文件时只能从文件尾端开始.</p>
</li>
<li>
<p>dup</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">dup</span><span class="hljs-params">(<span class="hljs-type">int</span> fd)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">dup2</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, <span class="hljs-type">int</span> fd2)</span>;<br></code></pre></td></tr></table></figure>
<p><strong>dup</strong> 或 <strong>dup2</strong> 都可以复制一个现有的文件描述符, 由 dup 返回的新文件描述符一定是当前可用文件描述符的最小值; 而 dup2 则可以用 fd2 指定新文件描述符的值. 如果 fd2 已经打开, 那么会先将其关闭, 如果 fd = fd2, 则直接返回 fd2, 而不关闭 fd2.</p>
<p>两个函数返回的新文件描述符与原来的 fd 共享同一个文件表项.</p>
<ul>
<li>
<p>例如: 执行完 dup(1) 的结果如下所示:<br>
<img src="/img/Pictures/20230506153309.png" srcset="/img/loading.gif" lazyload alt=""></p>
<p>fd1 和 fd3 指向同一个文件表项, 因此它们共享同一个文件状态标记 (读、写、追加等) 以及同一当前文件偏移量.</p>
</li>
</ul>
</li>
<li>
<p>sync</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">fsync</span><span class="hljs-params">(<span class="hljs-type">int</span> fd)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">fdatasync</span><span class="hljs-params">(<span class="hljs-type">int</span> fd)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">sync</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<br></code></pre></td></tr></table></figure>
<p>传统的 UNIX 系统实现在内核中设有缓冲区高速缓存或页高速缓存, 大多数磁盘 I/O 都通过缓冲区进行. 当我们向文件写入数据时, 内核通常先将数据复制到缓冲区中, 然后排入队列中, 之后再写入磁盘中, 这种方式称为<strong>延迟写</strong>.</p>
<p>UNIX 系统提供了<strong>sync</strong>、<strong>fsync</strong> 和 <strong>fdatasync</strong> 三个函数来保证磁盘中实际文件系统与缓冲区中内容的一致性:</p>
<ul>
<li>sync 将所有修改过的块缓冲区写入队列中, 然后立刻返回, 不等待写磁盘操作完成. 通常, 系统守护进程会周期性地调用 sync, 从而保证定期冲洗内核的块缓冲区.</li>
<li>fsync 只对 fd 指定的一个文件起作用, 并且会阻塞地等待写磁盘操作完成之后才返回. 该函数可被用于需要确保修改过的块立即写入磁盘上的应用程序.</li>
<li>fdatasync 类似 fsync, 但只影响文件的数据部分, 而 fsync 还会更新文件的元数据 (文件修改时间等).</li>
</ul>
</li>
<li>
<p>stat</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/stat.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">stat</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *<span class="hljs-keyword">restrict</span> pathname, <span class="hljs-keyword">struct</span> stat *<span class="hljs-keyword">restrict</span> buf)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">fstat</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, <span class="hljs-keyword">struct</span> stat *buf)</span>;<br></code></pre></td></tr></table></figure>
<p>调用 <strong>stat</strong> 和 <strong>fstat</strong> 可以查看特定文件的元数据, 实际上查看的是与文件关联的 <code>inode</code> 的信息:</p>
<ul>
<li>stat 根据给定 pathname 返回与此命名文件有关的信息结构.</li>
<li>fstat 根据 fd 获取与已打开文件有关的信息结构.</li>
</ul>
<p>第二个参数 buf 时一个用户提供的指针, 函数填充 buf 指向的结构, 该结构的基本形式如下:</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">stat</span>&#123;</span><br>  <span class="hljs-type">mode_t</span> st_mode; <span class="hljs-comment">// permissions</span><br>  <span class="hljs-type">ino_t</span> st_ino;   <span class="hljs-comment">// inode number</span><br>  <span class="hljs-type">dev_t</span> st_dev;   <span class="hljs-comment">// device number</span><br>  <span class="hljs-type">dev_t</span> st_rdev;  <span class="hljs-comment">// device number for special files</span><br>  <span class="hljs-type">nlink_t</span> st_nlink;  <span class="hljs-comment">// number of hard links</span><br>  <span class="hljs-type">uid_t</span> st_uid;   <span class="hljs-comment">// user ID of owner</span><br>  <span class="hljs-type">gid_t</span> st_gid;   <span class="hljs-comment">// group ID of owner</span><br>  <span class="hljs-type">off_t</span> st_size;  <span class="hljs-comment">// total sizes, in bytes</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">timespec</span> <span class="hljs-title">st_atime</span>;</span>  <span class="hljs-comment">// time of last access</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">timespec</span> <span class="hljs-title">st_mtime</span>;</span>  <span class="hljs-comment">// time of last modification</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">timespec</span> <span class="hljs-title">st_ctime</span>;</span>  <span class="hljs-comment">// time of last status change</span><br>  <span class="hljs-type">blksize_t</span> st_blksize;  <span class="hljs-comment">// best block size for file system I/O</span><br>  <span class="hljs-type">blkcnt_t</span> st_blocks;    <span class="hljs-comment">// number of disk blocks allocated</span><br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li>
<p>link</p>
<ul>
<li>
<p>硬链接</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">link</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *existingpath,  <span class="hljs-type">const</span> <span class="hljs-type">char</span> *newpath)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">linkat</span><span class="hljs-params">(<span class="hljs-type">int</span> efd,  <span class="hljs-type">const</span> <span class="hljs-type">char</span> *existingpath,  <span class="hljs-type">int</span> nfd,  <span class="hljs-type">const</span> <span class="hljs-type">char</span> *newpath,  <span class="hljs-type">int</span> flag)</span>;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">unlink</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *pathname)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">unlinkat</span><span class="hljs-params">(<span class="hljs-type">int</span> fd,  <span class="hljs-type">const</span> <span class="hljs-type">char</span> *pathname,  <span class="hljs-type">int</span> flag)</span>;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">remove</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *pathname)</span>;<br></code></pre></td></tr></table></figure>
<p>每个 inode 节点都有一个链接计数, 值是指向该 inode 节点的目录项数, 只有当链接计数减至 0 时, 而且没有进程打开该文件, 才可删除该文件并释放占用的数据块. 因此, 关闭一个文件时, 内核首先检查打开该文件的进程数, 如果是 0, 再去检查文件的硬链接个数, 如果也是 0, 那么就删除该文件的内容. 创建文件的硬链接之后, <strong>原有文件名和新创建的文件名之间没有区别, 它们都指向同一个 inode 节点</strong>.</p>
<p>调用 <strong>link</strong> 可以创建一个指向现有文件的<strong>硬链接</strong>,  而调用 <strong>unlink</strong> 可以删除一个目录项,  并且使 pathname 所引用的文件的硬链接计数减 1,  如果该文件还有其他的硬链接,  则仍然可以通过其他链接访问该文件的数据.</p>
<p>利用 unlink, 可以用以下方式创建一个临时文件: 进程先调用 open 或 create 常见一个文件, 然后立刻调用 unlink, 因为此时文件仍然处于打开状态, 所以内核不会立刻删除该文件的内容, 直到进程显式地关闭该文件 (主动调用 close) 或进程终止时 (内核关闭该进程所有打开的文件), 该文件的内容才会被删除.</p>
</li>
<li>
<p>软链接</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">symlink</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *actualpath, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *sympath)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">symlinkat</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *actualpath, <span class="hljs-type">int</span> fd, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *sympath)</span>;<br></code></pre></td></tr></table></figure>
<p><strong>软链接</strong>也称<strong>符号链接</strong>, 软链接是一种特殊类型的文件, 它只包含另一个文件或目录的路径. 类似于 Windows 系统中的快捷方式.</p>
<p>软链接与硬链接的比较:</p>
<ul>
<li>软连接可以跨越不同的文件系统, 而硬链接只能在同一个文件系统中创建 (inode number 只在一个文件系统内是唯一的).</li>
<li>软链接会存在悬空引用问题, 即删除原始文件后, 会导致软连接指向的路径名不存在, 此时无法访问原来的文件, 而使用硬链接的话, 即使删除多个别名, 只要还存在硬链接, 就能够通过那个链接访问原文件.</li>
<li>软链接文件的大小通常比原始文件小得多, 因为它只包含一个路径名, 而硬链接文件的大小通常和原文件的大小一样.</li>
<li>硬链接不能指向目录 (如果存在目录的硬链接, 可能会导致目录树中存在环), 而软链接可以指向目录.</li>
</ul>
<p>每个 inode 节点都有一个链接计数 nlink, 只有当链接计数减少到 0 时, 才可以删除该文件.</p>
<ul>
<li>如果 inode 是普通文件类型, 那么 nlink 既是链接计数 (因为软链接是另一种文件类型, 不记在原 inode 的 nlink 下), 也是硬链接计数.</li>
<li>如果 inode 是目录类型, 那么 nlink 并不代表硬链接计数, 因为我们不能创建目录的硬链接, 因此此时 nlink 的含义只是链接计数.
<ul>
<li>一个叶目录 (不包含其他目录的目录) 的链接计数为 2: 来自于命名该叶目录的目录项 (目录名 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\rightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">→</span></span></span></span> inode) 和叶目录的 “.” 项 (“.” <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\rightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">→</span></span></span></span> inode).</li>
<li>一个非叶目录 (包含其他目录的目录) 的链接计数至少为 3, 至少有一个额外的链接计数来自于其子目录的 “…” 项.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>mkdir</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">mkdir</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *pathname, <span class="hljs-type">mode_t</span> mode)</span>;<br></code></pre></td></tr></table></figure>
<p>mkdir 可以创建一个空目录, 其中 “.” 和 “…” 条目会自动创建. 传入文件访问权限 (mode) 时, 必须<strong>至少设置一个执行权限位</strong>, 以允许进入 (cd) 该目录, 如果没有执行权限位, 即使具有读权限和写权限也无法进入该目录.</p>
</li>
<li>
<p>rmdir</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">rmdir</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *pathname)</span>;<br></code></pre></td></tr></table></figure>
<p>rmdir 可以删除一个空目录, 空目录只包含 “.” 和 “…” 条目. 如果调用 rmdir 使得该目录的链接计数变为 0, 且没有其他进程打开该目录, 则会释放该目录占用的空间.</p>
</li>
<li>
<p>chdir</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">chdir</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *pathname)</span>;<br></code></pre></td></tr></table></figure>
<p>chdir 可以更改当前工作目录. 当前工作目录是进程的一个属性, 因此它只影响调用 chdir 的进程本身, 并不影响其他进程.</p>
<ul>
<li>为了改变 Shell 自己的工作目录, Shell 应该直接调用 chdir, 所以 Shell 将 cd 命令实现为内建命令 (不会创建一个新的进程来执行该命令).</li>
</ul>
</li>
</ol>
<h3 id="文件类型">文件类型</h3>
<p>UNIX 系统的文件类型包含以下几种, 该信息保存在 stat 结构中的st_mode 字段中:</p>
<ul>
<li>普通文件: 最常用的文件类型, 包含了某种形式的数据, 至于是文本还是二进制数据, 对于 UNIX 内核而言并无区别, 对普通文件内容的解释由应用程序进行.
<ul>
<li>对于二进制可执行文件, 为了能执行程序, 内核必须理解其格式, 因此所有二进制可执行文件都遵循一种标准化的格式, 从而使内核能够确定程序文本和数据的加载位置.</li>
</ul>
</li>
<li>目录文件: 包含了目录项列表. 对一个目录文件有读权限的任一进程都可以读该目录的内容, 但只有内核可以直接写目录文件.</li>
<li>块特殊文件: 块特殊文件代表一种块设备, 通常是磁盘、硬盘或其他类似的设备. 这些设备以固定大小的块为单位进行读写.</li>
<li>字符特殊文件: 字符特殊文件代表一种字符设备, 通常是串口、终端、键盘等设备. 字符设备以字符为单位进行读写.
<ul>
<li>系统中的所有设备要么是块特殊文件, 要么是字符特殊文件.</li>
</ul>
</li>
<li>FIFO: 用于进程间通信, 也称为命名管道.</li>
<li>套接字: 用于进程间的网络通信, 也可用于同一台主机上进程之间的非网络通信.</li>
<li>软链接: 包含另一个文件或目录的路径.</li>
</ul>
<h3 id="用户和组">用户和组</h3>
<p>Linux 系统会对每个用户的身份做唯一标识, 而用户可隶属于多个组.</p>
<h4 id="用户">用户</h4>
<p>Linux 系统的每个用户都拥有唯一的用户名和与之相对应的整数型用户 ID. 系统密码文件 “/etc/passwd” 为每个用户都定义了一行记录, 除了包含上述两项信息外, 该记录还包含如下信息:</p>
<ul>
<li>组 ID: 用户所属第一个组的整数型组 ID.</li>
<li>主目录: 用户登录后打开的初始目录.</li>
<li>登录 shell: 被执行以解释用户命令的程序名称.</li>
</ul>
<p>其中超级用户的用户 ID 为 0, 登录名为 root, 可以访问系统中的所有文件.</p>
<p>用户密码往往单独存储在 shadow 密码文件中.</p>
<h4 id="组">组</h4>
<p>在 Linux 中, 可以对用户进行分组来控制对文件和其他资源的访问, 一个用户可以同时属于多个组. 每个用户组都对应着系统组文件 “/etc/group” 中的一行记录, 该记录包含如下信息:</p>
<ul>
<li>组名: (唯一的) 组名称.</li>
<li>组 ID (GID): 与组相关的整数型 ID.</li>
<li>用户列表: 隶属于该组的用户登录名列表, 以逗号分隔.</li>
</ul>
<h3 id="文件权限">文件权限</h3>
<p>每个文件都有一个与之相关的用户 ID 和组 ID, 分别定义文件的属主和属组. 系统根据文件的所有权来判定用户对文件的访问权限.</p>
<p>为了访问文件, 系统把用户分为 3 类: 文件的属主、与文件组 ID 相匹配的属组成员用户以及其他用户. 可为以上 3 类用户分别设置 3 种权限 (共计 9 种权限位): 只允许查看文件内容的读权限、允许修改文件内容的写权限、允许执行文件的执行权限.</p>
<p>也可针对目录进行上述权限设置, 但意义稍有不同. 读权限允许列出目录内容 (即该目录下的文件名), 写权限允许对目录内容进行更改 (比如, 添加、修改或删除文件名), 执行权限允许访问目录中的文件 (但会受到文件访问权限的约束).</p>
<h2 id="文件系统实现">文件系统实现</h2>
<p>我们设计的极简文件系统的磁盘结构如下图所示:</p>
<p><img src="/img/Pictures/20230508103101.png" srcset="/img/loading.gif" lazyload alt=""></p>
<p>首先, 我们将磁盘分成块, 简单文件系统只用一种块大小, 我们选择常用的 4KB. 因此, 对于一个磁盘分区, 我们只需将其看成一系列的块, 这里我们假设有一个很小的磁盘, 只有 64 块.</p>
<p>对于用户数据, 用于存放用户数据的磁盘区域称为数据区域, 这些块因此称为<strong>数据块 (Data Block)</strong>, 这里将后 56 个数据块作为数据块.</p>
<p>文件系统必须记录关于每个文件的大量信息, 我们将这些数据组织成 <strong>元数据 (Metadata)</strong>, 例如前面我们看到的 struct stat, 元数据包括文件包含哪些数据块、文件大小、文件所有者和访问权限、访问和修改时间等类似信息. 为了存储这些信息, 文件系统通常使用一种叫做 <strong>inode</strong> 的结构 (用户程序通过 stat 系统调用从 inode 中获取部分元数据来填充 struct stat). 存放 inode 所使用的磁盘区域我们称为 <strong>inode 表 (Inode Table 或 Inode Block)</strong>. 它可以看成是一个保存磁盘上 inode 的数组, 在这里, 我们使用了 5 个块作为 inode block.</p>
<p>文件系统还需要记录数据块和 inode 块的空闲或已分配状态, 通过使用 <strong>位图 (Bitmap)</strong> 来实现. 我们使用磁盘上的两个块: 一个作为数据位图, 一个作为 inode 位图. 它用每个位指示相应的块是空闲 (0) 还是已分配 (1).</p>
<p>磁盘上的第一个块, 称为<strong>超级块 (Super Block)</strong>. 超级块包含关于该文件系统的特定信息, 如文件系统有多少个 inode block 和 data block、inode table 的开始位置等.</p>
<p>在挂载文件系统的时候, 操作系统首先读取超级块, 初始化各种参数, 然后将该卷添加到文件系统树上, 当卷中的文件被访问时, 系统就会知道在哪里查找所需的磁盘上的结构.</p>
<h3 id="Inode">Inode</h3>
<p>Inode 是用于保存和描述给定文件的元数据的结构. Inode 号可以用于索引磁盘上的 Inode 数组, 即每个 Inode 都由一个数字隐式引用, 即给定一个 Inode 号, 就能通过计算得到磁盘上对应的 Inode 节点的位置.</p>
<ul>
<li>
<p>例如: 在之前所描述的简单文件系统中, Inode Block 有 5 个, 每个 4KB, 假设每个 Inode 大小为 256B, 那么每个 Inode Block 就可以保存 16 个 Inode, 因此该文件系统有 80 个 Inode. 我们可以得到以下视图:</p>
<p><img src="/img/Pictures/20230514150429.png" srcset="/img/loading.gif" lazyload alt=""></p>
<p>其中特定 Inode 的地址可以根据 Inode Table 的起始地址加上 Inode 区域的偏移量来得到.</p>
<ul>
<li>例如: 要读取 Inode 32, 则该 Inode 的地址为 12KB + 32 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>×</mo></mrow><annotation encoding="application/x-tex">\times</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord">×</span></span></span></span> 256B = 20KB. 当然, <strong>磁盘不是按字节寻址的</strong>, 而是由大量的可寻址扇区组成, 每个扇区的大小通常为 512B, 因此为了读取 Inode 32, 首先我们需要找到该扇区的地址, 扇区号为 20KB ÷ 512B = 40, 所以文件系统将向扇区 40 发出一个读取请求, 然后就会得到 Inode 32 和 Inode 33, 从而获得我们期望的块.</li>
</ul>
</li>
</ul>
<p>一般来说, Inode 块的扇区地址可以计算如下:</p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi><mi>l</mi><mi>k</mi><mtext> </mtext><mo>=</mo><mtext> </mtext><mo stretchy="false">(</mo><mi>i</mi><mi>n</mi><mi>u</mi><mi>m</mi><mi>b</mi><mi>e</mi><mi>r</mi><mo>∗</mo><mi>s</mi><mi>i</mi><mi>z</mi><mi>e</mi><mi>o</mi><mi>f</mi><mo stretchy="false">(</mo><mi>i</mi><mi>n</mi><mi>o</mi><mi>d</mi><mi>e</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mi mathvariant="normal">/</mi><mi>b</mi><mi>l</mi><mi>o</mi><mi>c</mi><mi>k</mi><mi>s</mi><mi>i</mi><mi>z</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">blk \ = \ (inumber * sizeof(inode)) / blocksize</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">b</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace"> </span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace"> </span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">in</span><span class="mord mathnormal">u</span><span class="mord mathnormal">mb</span><span class="mord mathnormal" style="margin-right:0.02778em;">er</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">s</span><span class="mord mathnormal">i</span><span class="mord mathnormal">zeo</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">in</span><span class="mord mathnormal">o</span><span class="mord mathnormal">d</span><span class="mord mathnormal">e</span><span class="mclose">))</span><span class="mord">/</span><span class="mord mathnormal">b</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">oc</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mord mathnormal">s</span><span class="mord mathnormal">i</span><span class="mord mathnormal">ze</span></span></span></span></p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mi>e</mi><mi>c</mi><mi>t</mi><mi>o</mi><mi>r</mi><mtext> </mtext><mo>=</mo><mtext> </mtext><mo stretchy="false">(</mo><mo stretchy="false">(</mo><mi>b</mi><mi>l</mi><mi>k</mi><mo>∗</mo><mi>b</mi><mi>l</mi><mi>o</mi><mi>c</mi><mi>k</mi><mi>s</mi><mi>i</mi><mi>z</mi><mi>e</mi><mo stretchy="false">)</mo><mo>+</mo><mi>i</mi><mi>n</mi><mi>o</mi><mi>d</mi><mi>e</mi><mi>s</mi><mi>t</mi><mi>a</mi><mi>r</mi><mi>t</mi><mi>a</mi><mi>d</mi><mi>d</mi><mi>r</mi><mo stretchy="false">)</mo><mi mathvariant="normal">/</mi><mi>s</mi><mi>e</mi><mi>c</mi><mi>t</mi><mi>o</mi><mi>r</mi><mi>s</mi><mi>i</mi><mi>z</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">sector \ = \ ((blk * blocksize) + inodestartaddr) / sectorsize</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6151em;"></span><span class="mord mathnormal">sec</span><span class="mord mathnormal">t</span><span class="mord mathnormal" style="margin-right:0.02778em;">or</span><span class="mspace"> </span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace"> </span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">((</span><span class="mord mathnormal">b</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">b</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">oc</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mord mathnormal">s</span><span class="mord mathnormal">i</span><span class="mord mathnormal">ze</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">in</span><span class="mord mathnormal">o</span><span class="mord mathnormal">d</span><span class="mord mathnormal">es</span><span class="mord mathnormal">t</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">t</span><span class="mord mathnormal">a</span><span class="mord mathnormal">dd</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mclose">)</span><span class="mord">/</span><span class="mord mathnormal">sec</span><span class="mord mathnormal">t</span><span class="mord mathnormal">ors</span><span class="mord mathnormal">i</span><span class="mord mathnormal">ze</span></span></span></span></p>
<h3 id="多级索引">多级索引</h3>
<p>Inode 包含了有关该文件的数据块驻留在磁盘上位置的信息, 设计 Inode 时, 最重要的决定之一就是如何引用数据块的位置.</p>
<p>一种简单方法是: 在 Inode 中有一个或者多个<strong>直接指针</strong>, 指向磁盘某个地址, 因此, 每个指针都可以指向属于该文件的一个磁盘数据块. 但是如果你的文件非常大, 大于块的大小 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>×</mo></mrow><annotation encoding="application/x-tex">\times</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord">×</span></span></span></span> 直接指针数, 这种方法就不可行.</p>
<p>还有一种方法是使用<strong>间接指针</strong>:</p>
<p><img src="/img/Pictures/20230514153932.png" srcset="/img/loading.gif" lazyload alt=""></p>
<p>间接指针不指向包含用户数据的块, 而是指向包含更多指针的块. 因此, 在设计 Inode 时, 可以有一些固定数量的直接指针和一个或多个间接指针. 间接指针的数量和等级可以基于所需支持的最大文件大小.</p>
<ul>
<li>例如: 假设 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi><mi>l</mi><mi>o</mi><mi>c</mi><mi>k</mi><mi>s</mi><mi>i</mi><mi>z</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">blocksize</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">b</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">oc</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mord mathnormal">s</span><span class="mord mathnormal">i</span><span class="mord mathnormal">ze</span></span></span></span> = 4KB, <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mi>o</mi><mi>i</mi><mi>n</mi><mi>t</mi><mi>e</mi><mi>r</mi><mi>s</mi><mi>i</mi><mi>z</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">pointersize</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.854em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">p</span><span class="mord mathnormal">o</span><span class="mord mathnormal">in</span><span class="mord mathnormal">t</span><span class="mord mathnormal">ers</span><span class="mord mathnormal">i</span><span class="mord mathnormal">ze</span></span></span></span> = 4B, 指针的总数是 13, 有 10 个直接指针、1 个间接指针、1 个双重间接指针和 1 个三重间接指针, 那么它支持的文件最大大小为:<br>
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mn>10</mn><mo>+</mo><mfrac><mrow><mn>4</mn><mi>K</mi><mi>B</mi></mrow><mrow><mn>4</mn><mi>B</mi></mrow></mfrac><mo>+</mo><msup><mfrac><mrow><mn>4</mn><mi>K</mi><mi>B</mi></mrow><mrow><mn>4</mn><mi>B</mi></mrow></mfrac><mn>2</mn></msup><mo>+</mo><msup><mfrac><mrow><mn>4</mn><mi>K</mi><mi>B</mi></mrow><mrow><mn>4</mn><mi>B</mi></mrow></mfrac><mn>3</mn></msup><mo stretchy="false">)</mo><mo>×</mo><mn>4</mn><mi>K</mi><mi>B</mi><mo>≈</mo><mn>4.4</mn><mi>T</mi></mrow><annotation encoding="application/x-tex">(10 + \frac{4KB}{4B} + \frac{4KB}{4B}^2 + \frac{4KB}{4B}^3) \times 4KB ≈ 4.4T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">10</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.2173em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8723em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">4</span><span class="mord mathnormal mtight" style="margin-right:0.05017em;">B</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">4</span><span class="mord mathnormal mtight" style="margin-right:0.07153em;">K</span><span class="mord mathnormal mtight" style="margin-right:0.05017em;">B</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.4213em;vertical-align:-0.345em;"></span><span class="mord"><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8723em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">4</span><span class="mord mathnormal mtight" style="margin-right:0.05017em;">B</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">4</span><span class="mord mathnormal mtight" style="margin-right:0.07153em;">K</span><span class="mord mathnormal mtight" style="margin-right:0.05017em;">B</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:1.0763em;"><span style="top:-3.3252em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.4213em;vertical-align:-0.345em;"></span><span class="mord"><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8723em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">4</span><span class="mord mathnormal mtight" style="margin-right:0.05017em;">B</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">4</span><span class="mord mathnormal mtight" style="margin-right:0.07153em;">K</span><span class="mord mathnormal mtight" style="margin-right:0.05017em;">B</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:1.0763em;"><span style="top:-3.3252em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">4</span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">4.4</span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span></span></span></span></li>
</ul>
<p>使用这样的不平衡树是因为<strong>大多数文件很小</strong>, 即只需要使用少量的直接指针, 就可以解决大部分的文件存储问题, 从而实现性能上的优化; 需要处理大文件时, 再使用一个或多个间接块.</p>
<h3 id="目录组织">目录组织</h3>
<p>一个目录基本上是一个列表, 列表中包含多个目录项, 每个目录项包含了文件名和 <code>inode</code> 号, 以及一些其他的元数据信息, 如文件类型、权限、所有者、所属组、大小、创建时间、修改时间等.</p>
<p>文件系统将目录视为特殊类型的文件, 因此, 目录也有一个 Inode, 该目录具有由 Inode 指向的目录的数据块, 在这些数据块中就保存着上述数据.</p>
<h3 id="访问路径">访问路径</h3>
<p>现在我们关注读取和写入文件系统的过程, 假设文件系统已被挂载, 此时超级块已经在内存中, 而所有其他内容如 Inode、目录等还在磁盘中.</p>
<h4 id="从磁盘读取文件">从磁盘读取文件</h4>
<p>首先我们关注从磁盘读取文件的访问路径, 我们希望打开一个文件 “/foo/bar”, 读取它然后就关闭它, 我们假设文件大小刚好只有 4KB, 下面是这个操作的访问路径:</p>
<ol>
<li>调用 open(“/foo/bar”, O_RDONLY).</li>
<li>遍历从文件系统的根目录开始, 因此第一次磁盘读取的是根目录的 Inode, 而根目录的 Inode 号是已知的, 在 UNIX 系统中是 2.</li>
<li>有了根目录的 Inode, 就可以读取根目录的数据块, 从而读取根目录的内容, 以寻找 foo 条目, 然后我们就可以读取 foo 的 Inode. 以此类推, 我们继续读取 foo 的数据块和 bar 的 Inode, 然后 open 就会分配一个文件描述符给文件 bar, 然后返回给用户.</li>
<li>文件 bar 已被打开, 利用 open 返回的文件描述符, 我们调用 read 来读取文件的数据.</li>
<li>第一个 read 会从偏移量 0 开始, 因此将读取问价的第一个块, 查阅 bar 的 Inode 以找到这个块的位置, 然后读取 bar 的数据块 data[0], 由于需要更新文件的最后访问时间, 所以此时需要更新 bar 的 Inode. 以此类推, 下一次就是 bar 的数据块 data[1]、data[2] …, 每次读取完成都需要更新 bar 的 Inode.</li>
</ol>
<p>上述整个访问路径可以用下图展示:</p>
<p><img src="/img/Pictures/20230514170129.png" srcset="/img/loading.gif" lazyload alt=""></p>
<ul>
<li>从磁盘读取文件的时间线 (向下时间递增)</li>
</ul>
<h4 id="写入磁盘">写入磁盘</h4>
<p>下面我们关注向磁盘写入文件的访问路径, 同样是文件 “/foo/bar”, 文件应该先被打开, 然后程序调用 write 更新文件, 最后关闭文件.</p>
<p>如果写入文件需要分配新的块时, 例如写入一个新创建的文件时, 事情就变得麻烦了. 因为写入一个新文件时, 每次写入操作不仅需要将数据写入磁盘, 还必须先决定将哪个块分配给文件, 从而需要更新磁盘的相应结构, 如位图和 Inode.</p>
<p>因此考虑写入新文件时, 逻辑上会产生 5 次 I/O:</p>
<ul>
<li>读取文件的 Inode.</li>
<li>读取数据位图, 在内存中更新该位图以标记新分配的块被使用.</li>
<li>写入新分配的数据块.</li>
<li>写入数据位图以将其新状态存入磁盘中.</li>
<li>写入文件的 Inode, 更新新数据块的位置以及文件的最后访问时间.</li>
</ul>
<p>如果考虑创建一个新文件时, 需要更多的 I/O:</p>
<ul>
<li>读取文件所在目录的 Inode 和数据块.</li>
<li>读取 Inode 位图, 在内存中更新它 (因为要创建一个新文件, 所以需要创建一个新的 Inode).</li>
<li>写入文件所在目录的数据块, 创建新的目录条目.</li>
<li>写入 Inode 位图, 将其新状态存入磁盘中.</li>
<li>读取新文件的 Inode.</li>
<li>写入新文件的 Inode, 更新其修改/访问时间.</li>
<li>写入文件所在目录的 Inode (因为增加了新条目, 所以需要更新其修改时间).</li>
</ul>
<p>上述整个访问路径可以用下图展示:</p>
<p><img src="/img/Pictures/20230514171743.png" srcset="/img/loading.gif" lazyload alt=""></p>
<ul>
<li>写入磁盘的时间线 (向下时间递增)</li>
</ul>
<h3 id="缓存和缓冲">缓存和缓冲</h3>
<p>通过前面从磁盘读取和写入磁盘的例子, 你可能发现每次对文件的读取和写入, 代价可能会是昂贵的, 会导致很多磁盘 I/O, 如果磁盘是慢速的, 这就是一个巨大的性能问题. 为了弥补这种缺陷, 大多数文件系统积极使用系统的物理内存 DRAM 来<strong>缓存</strong>重要的块.</p>
<p>如果没有缓存, 每个打开的文件都需要对目录层次结构中的每个级别进行至少两次读取 (一次是相关目录的 Inode, 一次是目录的数据块), 特别是, 路径名很长的情况下, 仅仅是为了打开文件, 可能就需要数百次 I/O.</p>
<p>现代系统通常采用动态划分缓存的方法, 将虚拟内存页面和文件系统页面集成到<strong>统一页面缓存</strong>中, 用于保存常用的磁盘块或页面, 虚拟内存和文件系统之间也可以更灵活地分配内存, 这取决于哪个子系统需要更多内存, 同时, 可以用 LRU 等策略决定哪些磁盘块或页面保留在缓存中.</p>
<p>如果我们现在有缓存地打开文件, 那么第一次打开时可能会产生很多 I/O 流量, 但是对同一文件的后续打开, 大部分会命中缓存, 因此大大减少了 I/O 的数量.</p>
<p>考虑完了读取, 我们再考虑缓存对写入的影响. 显然, 因为写入流量是必须进入磁盘的, 所以使用高速缓存并不能减少写入流量. 但是, 我们可以采用另一种方式, 称为<strong>写缓冲</strong>.</p>
<p>写缓冲主要的思想是延迟写入, 即文件系统将一些更新收集成一批, 即将这些单独零散的 I/O 放入一组较小的 I/O 中, 一次往磁盘上写入更多的内容, 从而减少总的 I/O 次数. 此外, 通过将一些写入缓冲在内存中, 操作系统可以调度后续的 I/O, 从而提高性能. 最后, 有一些写入, 通过延迟写入的策略, 可以完全避免, 例如创建一个文件然后又将其删除, 通过将文件创建延迟写入, 相关的 I/O 就可以省略.</p>
<p>因此, 大多数现代文件系统通常将写入在内存中缓冲 5 — 30 秒不等, 这是一种折中的解决方案: 如果系统在这些写入更新到磁盘之前崩溃, 那么更新将丢失; 但通过延迟写入, 将写入缓冲在内存里, 可以通过批处理、调度甚至避免写入来提高性能.</p>
<h2 id="快速文件系统">快速文件系统</h2>
<p>对于老版本的 UNIX 文件系统 (UFS), 其数据结构在磁盘上的分布如下所示:</p>
<p><img src="/img/Pictures/20230517172047.png" srcset="/img/loading.gif" lazyload alt=""></p>
<ul>
<li>其中超级块 S 包含有关整个文件系统的信息, 如卷大小、Inode 数量、指向空闲块列表的头部指针等, Inodes 区域包含所有的 Inode 块, 剩下的区域都用于数据块.</li>
</ul>
<p>该设计性能较差, 问题在于老版 UFS 将磁盘当成随机存取内存, 数据分布在各个地方, 而没有考虑到存储介质是磁盘的事实. 磁盘定位成本很高, 当文件数据远离 Inode 块时, 就会导致昂贵的寻道操作. 且该 UFS 最终会变得碎片化, 在使用一段时间后, 空闲块列表会指向遍布磁盘各处的块, 因而导致分配了新的文件之后, 即使逻辑上连续的文件, 在磁盘上也需要来回访问, 大幅度降低了性能.</p>
<ul>
<li>
<p>例如: 假设 4 个数据块区域分别对应 4 个文件 (A、B、C、D), 现在删除 B 和 D 两个文件, 然后空闲空间将变成分开的两大块, 如果此时分配一个 4 个块大小的文件 E, 最终数据在磁盘中的分布将如下:</p>
<p><img src="/img/Pictures/20230517182738.png" srcset="/img/loading.gif" lazyload alt=""></p>
<p>因为文件 E 分散在磁盘上, 所以访问文件 E 时, 无法获取磁盘峰值性能: 首先读取 E1 和 E2, 然后寻道, 再读取 E3 和 E4. 尽管老版的 UFS 可以通过磁盘碎片整理工具来重新组织磁盘的数据块以连续的形式放置文件, 并让空闲列表称为一个或几个连续的区域, 但是额外的整理会造成麻烦并有一定的开销.</p>
</li>
</ul>
<p>老版的 UFS 的原始块太小 (只有 512B), 导致从磁盘传输数据低效, 虽然小的数据块可以减轻内部碎片的问题.</p>
<p>因此出现了一个更好更快的文件系统, 称为<strong>快速文件系统 (Fast File System)</strong>. FFS 的基本思想是让文件系统的结构和分配具有&quot;磁盘意识&quot;, 从而提高性能.</p>
<p>FFS 以及后来的现代文件系统都遵循现有的接口以保持兼容性, 而改变其内部的实现.</p>
<h3 id="柱面组">柱面组</h3>
<p>FFS 将磁盘划分为一些分组, 称为<strong>柱面组 (Cylinder Group)</strong>. 一个具有 10 个柱面组的磁盘如下所示:</p>
<p><img src="/img/Pictures/20230521141331.png" srcset="/img/loading.gif" lazyload alt=""></p>
<p>使用柱面组是 FFS 用于改善性能的核心机制, 通过在同一组中放置两个或多个文件, FFS 就可以保证先后访问者两个或多个文件时不会导致穿越磁盘的长时间寻道.</p>
<p>柱面组在磁盘驱动器中的位置如下所示, 在同一个柱面组内不需要额外的寻道操作:</p>
<p><img src="/img/Pictures/20230521142048.png" srcset="/img/loading.gif" lazyload alt=""></p>
<ul>
<li>磁盘设备可以包括一个或多个盘片 (platter).</li>
<li>每个盘片有一个或两个存储盘面 (如果是双面盘面, 读写磁头 (read-write head) 设置为上下两个: 上边磁头读正面, 下边磁头读反面. 磁头数和盘面数一致, 一个磁头对应一个盘面).</li>
<li>一个盘面被分为多个磁道 (track).</li>
<li>一个磁道被分为多个扇区 (sector, 物理块), 在传统的磁盘驱动器中, 每个扇区的容量是相同的.</li>
<li>柱面是磁盘上一组同心圆形磁道的集合, 这些磁道在磁盘上沿着垂直于盘片的方向排列. 一个柱面包含了相同编号的各个磁道, 每个磁道都处于不同的盘片上.</li>
</ul>
<p>FFS 需要在每个柱面组内分配文件和目录, 一个柱面组的布局如下所示:</p>
<p><img src="/img/Pictures/20230521142850.png" srcset="/img/loading.gif" lazyload alt=""></p>
<p>为了可靠性, 每个组都有一个超级块 S 的副本, 因此如果一个柱面组的超级块被损坏, 仍可以使用别的副本来访问文件系统. 每个柱面组中, 使用 Inode 位图和数据块位图来记录该柱面组的 Inode 和数据块是否已分配.</p>
<h3 id="分配文件和目录">分配文件和目录</h3>
<p>FFS 的原则是: 将相关的文件和目录以及相关元数据放置在同一个柱面组中, 而不相关的东西则放在不同的柱面组中.</p>
<p>为实现上述目标, FFS 使用一些简单的放置推断方法:</p>
<ul>
<li>对于目录, FFS 找到已分配数量少的柱面组和大量的空闲 Inode, 并将目录数据和 Inode 放置在该分组中.</li>
<li>对于文件, FFS 先确保将文件的数据块分配到与其 Inode 相同的柱面组中, 以防止从 Inode 到数据块的长时间寻道. 其次, FFS 将位于同一个目录中的所有文件放置在他们所处目录的柱面组中.</li>
</ul>
<p>上述放置推断法确保相关文件之间寻道时间很短, 以提高性能.</p>
<h3 id="大文件异常">大文件异常</h3>
<p>FFS 的文件放置策略有一个重要例外情况, 就是大文件的放置. 如果我们继续使用上述的推断来放置大文件, 那么大文件可能会填满第一个放入的柱面组, 然后可能继续填满其他的柱面组, 这将妨碍其他的相关文件放置在这些柱面组中, 从而破坏文件访问的局部性.</p>
<p>因此对于大文件, FFS 先将一定数量的块分配到第一个柱面组中, 然后将文件的下一个大块放入另一个柱面组中, 以此类推.<br>
下面是使用大文件例外策略的前后对比图, 这里大文件大小为 10 个块:</p>
<p><img src="/img/Pictures/20230522151105.png" srcset="/img/loading.gif" lazyload alt=""></p>
<p>我们将大文件以大块的形式分布在磁盘中, 而在磁盘中分散文件块会损害性能. 我们可以通过选择大块的大小来改善这一点.</p>
<p>如果大块大小足够大, 那么大部分时间仍然被花在从磁盘传输数据上, 而在大块之间寻道的时间相对较少, 那么一定时间开销内将可以做更多工作, 这种思想称为<strong>摊销</strong>.</p>
<ul>
<li>
<p>下图展示了使磁盘达到期望的峰值带宽所需的大块大小:</p>
<p><img src="/img/Pictures/20230522151749.png" srcset="/img/loading.gif" lazyload alt=""></p>
<p>假设磁盘的平均定位时间 (寻道 + 旋转) 是 10 ms, 而磁盘以 40 MB/s 的速率传输数据. 如果希望花费一半的时间定位, 一半的时间用于传输, 那么块大小应该为 409.6K; 如果希望花费 90% 的时间在传输上, 那么块的大小应该为 3.69M.</p>
</li>
</ul>
<p>FFS 则基于 Inode 本身的结构: 前 12 个直接块和 Inode 块放在同一组中, 而每个后续的间接块以及它指向的所有数据块都放在不同的组中.</p>
<p>磁盘驱动器的趋势是: 传输速率越来越快, 但是驱动器的与寻道相关的机械方面 (磁盘臂速度和旋转速度等) 则改善缓慢, 因此随着时间推移，机械成本将变得更昂贵, 为了摊销该成本, 应该在寻道之间传输更多数据.</p>
<p>使用 4KB 块虽然有利于传输数据,   但空闲效率不太好. 根据前面的规律总结,   大部分文件大小为 2KB 左右,   这意味着对于小文件可能因内部碎片而导致大约一半的磁盘浪费.</p>
<p>FFS 使用<strong>子块</strong>来解决该问题: 一个子块占 512B,   文件系统可以将它们分配给文件,   随着文件的增长,   当数据的大小达到 4KB 时,   将这些数据分配到一个 4KB 的块中,   并释放之前的子块.</p>
<p>但是由于文件系统需要大量额外的工作 (如复制操作、I/O 操作),   所以会导致效率降低. FFS 的一个解决思路是通过修改 libc 库,   以便缓冲子块的写入操作,   当文件系统积累一定的子块数据后,   以 4KB 数据块的形式发送给文件系统. 这种批量发送的方式可以减少单独子块写入时所产生的额外工作和 I/O 操作的数量.</p>
<p>还有一个问题是磁盘布局带来的: 观察下图的左半部分,   这是将文件放在磁盘的连续扇区的方案</p>
<p><img src="/img/Pictures/20230522161514.png" srcset="/img/loading.gif" lazyload alt=""></p>
<p>在顺序读取文件时,  会出现问题: FFS 发出请求读取块 0,  读取完毕后,  发出请求读取块 1,  但是磁头已经经过块 1 (即没有留出过渡的空间),  现在我们如果要再读取块 1,  需要磁头多旋转一圈,  这是一个很大的开销.</p>
<p>FFS 针对这种性能问题, 优化了磁盘布局, 如上图右半部分所示. 通过每次跳过一块, 在下一块经过磁头之前, FFS 有足够时间可以发出请求. 实际上, 上图的布局不是唯一的, 可以按磁盘的特定性能参数来确定准确的交错磁盘布局, FFS 足够聪明, 可以确定特定磁盘在布局时应该跳过多少块, 以避免额外的旋转, 这种技术称为<strong>参数化</strong>.</p>
<p>这种磁盘布局存在的问题是, 只能获得 50% 的峰值带宽. 现代磁盘能更加聪明地处理这个问题, 它们在内部读取整个磁道并将其缓冲在内部磁盘缓存中, 对于后续对轨道的读取, 磁盘从其高速缓存中返回所需数据.</p>
<h2 id="崩溃一致性问题">崩溃一致性问题</h2>
<p>与运行中程序在内存中的数据结构不同,  文件系统数据结构必须持久,  它们要能够长期存在,  保存在断电也能保存数据的设备上,  如硬盘、基于闪存的 SSD 等.</p>
<p>文件系统面临的一个主要挑战在于: 在出现断电和系统崩溃的情况下, 更新文件系统的数据结构. 需要考虑, 在断电或崩溃时, 更新磁盘结构最后会变成什么结果？是否是我们所希望的？</p>
<ul>
<li>例如, 系统可能在任何两次磁盘写入之间出现断电或崩溃, 因此磁盘上的状态可能只被部分地更新, 那么磁盘上的结构就会处于不一致状态.</li>
</ul>
<p>如何确保文件系统将磁盘上的映像保持在合理的状态？这个问题, 称为<strong>崩溃一致性问题 (Crash-Consistency Problem)</strong>.</p>
<h3 id="更新实例">更新实例</h3>
<p>我们先考虑一种简单的工作负载,   它将单个数据块附加到原有文件中. 因此,   在文件关闭前,   会向文件发出单个 4KB 写入来完成内容的追加.</p>
<p>假设文件更新前的状态如下图所示:</p>
<p><img src="/img/Pictures/20230522163216.png" srcset="/img/loading.gif" lazyload alt=""></p>
<p>向文件追加一个新数据块,  需要更新文件的 Inode、新的数据块 Db 以及数据块位图三个块,  这 3 个块必须被写入磁盘,  因此文件更新完成后的状态可能如下图所示:</p>
<p><img src="/img/Pictures/20230522163337.png" srcset="/img/loading.gif" lazyload alt=""></p>
<p>为了完成这次更新, 文件系统需要对磁盘执行 3 次单独写入. 但是, 这些写操作通常不会立即发生, 很大概率会被延迟写入, 在缓冲区缓存中存在一段时间, 然后文件系统过 5s — 30s 之后再决定将它们写入磁盘. 问题是, 如果在这些写入的一个或两个完成以后发生断电或崩溃, 那么文件系统可能会处于奇怪的状态.</p>
<h3 id="崩溃场景">崩溃场景</h3>
<p>当只有一次写入成功时:</p>
<ul>
<li>只将数据块 Db 写入磁盘. 新数据块 Db 确实被写入了磁盘上,   但是没有指向它的 Inode,   也没有表示该块已分配的位图,   因此,   这个写入就像没有发生过一样.</li>
<li>只将 I[v2] 即更新后的 Inode 块写入磁盘. 这时,  Inode 指向了新数据块 Db 所处的磁盘地址,  但是 Db 没有被写入到磁盘上,  因此,  我们可能会读出该数据块的旧内容,  即垃圾数据.</li>
<li>只将更新后的位图 B[v2] 写入磁盘. 这时, 位图指示新的数据块 Db 已经分配, 但是没有指向它的 Inode, 因此, 可能会导致空间泄露, 因为文件系统将永远不会使用这个块.</li>
</ul>
<p>当只有两次写入成功时:</p>
<ul>
<li>I[v2] 和 B[v2] 成功写入. 虽然文件系统元数据一致, 但问题仍是 Db 的位置可能是垃圾数据.</li>
<li>I[v2] 和 Db 成功写入. Inode 指向了正确的数据块 Db, 但是位图和 Inode 又发生冲突, 因此数据可能会被覆盖, 因为位图指示 Db 未被分配.</li>
<li>B[v2] 和 Db 成功写入. 位图现在指示 Db 已被分配, Inode 和位图再次发生冲突, 虽然位图正确指示了 Db 被分配, 但是我们不知道其属于哪个文件, 因为没有 Inode 指向它.</li>
</ul>
<h3 id="解决方案">解决方案</h3>
<p>下面我们将讨论一些方法, 将文件系统从一个一致状态 (文件更新以前), <strong>原子地</strong>转移到另一个一致状态 (Inode、位图、新数据块都被写入磁盘以后):</p>
<h4 id="文件系统检查">文件系统检查</h4>
<p>早期的文件系统,      使用一种简单的方法来处理崩溃一致性. 它们让这种不一致发生,      等到重启时,      再修复它们. 一个 UNIX 工具 —— <strong>FSCK</strong> (File System Check),      就用于查找这些不一致并且修复它们.</p>
<p>FSCK 可以在很多阶段运行,      例如在文件系统挂载并可用之前运行,      一旦完成运行,      FSCK 确保磁盘上的文件系统是一致的,      可以让用户访问. FSCK的工作总结如下:</p>
<ul>
<li><strong>超级块</strong>: FSCK 首先对超级块进行健全性检查,     如确保文件系统大小大于分配的块数等,     如果找到一个冲突的超级块,     那么可以使用备用副本 (每个柱面组中都有超级块的副本) 来替换它.</li>
<li><strong>空闲块</strong>: 接着 FSCK 扫描  Inode 、间接块、双重间接块等,     了解当前在文件系统中已被分配的块,     利用这些信息生成正确版本的位图. 这说明,     如果位图和  Inode  有冲突,     那么 FSCK 将信任  Inode  的信息.</li>
<li>** Inode  状态**: 检查每个  Inode  是否损坏或有其它问题,    如  Inode  的类型字段是否有效等,    如果  Inode  字段存在问题,    这很难修复,    因此 FSCK 直接清除该  Inode  并且更新位图.</li>
<li>** Inode  链接**: FSCK 还会验证每个已分配  Inode  的链接数,   为此 FSCK 从根目录开始扫描整个目录树,   并为文件系统中每个文件和目录构建自己的链接计数. 如果新的计数和  Inode  中的计数不匹配,   通常修复  Inode  中的计数; 如果发现存在已分配的  Inode ,   但没有目录引用它,   即该  Inode  不存在于任何目录的条目中,   那么将其移到 lost + found 目录下.</li>
<li><strong>重复</strong>:  FSCK 检查重复指针,  当两个或多个不同的 Inode 引用同一个块时,  可能会清除几个 Inode ,  又或者复制指向的块,  从而为多个 Inode 提供自己的副本.</li>
<li><strong>坏块</strong>: 扫描所有指针时, 如果发现有指针的指向超出其有效范围, 那么该指针被认为是坏的, 这时 FSCK 从 Inode 的直接指针或间接指针中删除该指针.</li>
<li><strong>目录检查</strong>: FSCK 对每个目录的内容执行额外的检查, 确保 “.” 和 “…” 是前面的条码, 且确保目录条目中引用的每个 Inode 都已分配, 整个层次结构中没有目录的引用超过一次.</li>
</ul>
<p>FSCK 很难在所有情况下都正常工作, 例如 Inode 指向垃圾数据的情况, 因为 FSCK 只确保文件系统的元数据一致. 且 FSCK 的性能较差, 对于很大的磁盘卷, 扫描整个磁盘、读取整个目录树、查找所有已分配的块这些操作需要较长的时间, 尤其是随着磁盘容量日渐增长, FSCK 的性能问题只会越来越明显.</p>
<h4 id="数据日志">数据日志</h4>
<p>数据日志 (也称为预写日志) 和 FSCK 的思路不同, FSCK 总是尝试在事情发生以后一次性完成所有的补救, 而数据日志虽然为每次的写入都增加一点开销, 但是可以更快地从断电或崩溃中恢复. 现代的文件系统 (例如 Linux 的 ext3、ext4, Windows 的 NTFS) 都使用这种方案.</p>
<p><strong>数据日志的基本思想</strong>是: 每次在更新磁盘, 即将覆写相应数据结构时, 先写下一些记录放在磁盘的其他位置上, 这个记录描述了我们将要做的事情. 在写下记录的这个磁盘位置, 我们就将这些记录组织成日志, 如下图所示:</p>
<p><img src="/img/Pictures/20230527150857.png" srcset="/img/loading.gif" lazyload alt=""></p>
<ul>
<li>没有日志的文件系统 (ext2) 和有日志的文件系统 (ext3) 的磁盘文件系统映像对比</li>
</ul>
<p>通过每次将少量记录写入磁盘, 在更新磁盘上的数据结构发生崩溃时, 可以查看记录, 然后重试这些操作. 因此我们可以在崩溃后通过日志准确地知道需要修复的内容, 而避免了调用 FSCK 扫描整个磁盘所带来的开销. 使用日志的开销是在我们更新期间增加的一点额外工作量.</p>
<p><strong>数据日志的工作原理如下</strong>:</p>
<p>假设需要更新三个块: Inode 块 I[v2]、数据块位图 B[v2] 和新数据块 Db. 在将它们写入磁盘的确切位置之前, 首先将其写入日志, 如下图所示:</p>
<p><img src="/img/Pictures/20230527151825.png" srcset="/img/loading.gif" lazyload alt=""></p>
<ul>
<li>日志的组成 (一个事务)</li>
</ul>
<p>一个事务除了需要包含需要写入的三个块, 还需要包含<strong>事务开始标记 TxB</strong> 和<strong>事务结束标记 TxE</strong>.</p>
<ul>
<li>TxB 告诉我们有关这次更新的信息, 例如三个块最终要写入的地址, 并包含事务标识符 TID.</li>
<li>中间三个块是确切的内容, 我们需要将这三个块写到磁盘的日志上.</li>
<li>TxE 是这次事务结束的标记, 同样需要包含事务标识符 TID.</li>
</ul>
<p>一旦一个事务安全地存储在磁盘的日志上后, 就可以开始覆写磁盘上文件系统的旧数据结构, 这个过程称为<strong>加检查点 (Checkpointing)</strong>. 现在我们开始对文件系统夹检查点, 将 I[v2]、B[v2] 和 Db 写入磁盘的相应位置上, 如果这些写入顺利完成, 那么这个加检查点的过程就成功.</p>
<p>上述两步过程 (日志写入 + 加检查点) 可能会产生一定的问题: 因为延迟写入, 我们往往将 5 个块的写入转换为单个顺序写入. 但是磁盘内部会进行调度, 以任何顺序完成大批写入块, 这意味着我们有可能写成功写入 TxB 和 TxE, 再去写入剩余 3 个实际数据块, 如果在这两个过程之间不幸发生断电或崩溃, 可能导致日志出现问题, 因为 3 个数据块中的一个或几个没有被写入到日志中, 这对于一些情况来说可能是致命的, 例如缺失的块为超级块时, 会导致文件系统无法挂载.</p>
<p>为了解决上述问题, 可以将日志写入分为两步进行:</p>
<ol>
<li>
<p>首先将 TxE 以外的块写入日志, 这些写入可以同时发生, 而不管写入顺序如何.</p>
<p><img src="/img/Pictures/20230527153219.png" srcset="/img/loading.gif" lazyload alt=""></p>
</li>
<li>
<p>在这些块都写入完成后, 文件系统才发出 TxE 的写入, 从而是日志处于一个正确的状态.</p>
<p><img src="/img/Pictures/20230527153354.png" srcset="/img/loading.gif" lazyload alt=""></p>
</li>
</ol>
<p>现在, 数据日志可以分为以下三步:</p>
<ol>
<li>日志写入: 将 TxB、元数据块和数据块写入日志, 等待这些写入完成.</li>
<li>日志提交: 将 TxE 写入日志, 等待写入完成. 一旦完成, 我们认为事务已经完成提交.</li>
<li>加检查点: 将日志中的事务 (元数据和数据更新) 写入磁盘的最终位置上.</li>
</ol>
<p><strong>现在考虑文件系统如何利用日志从断电或崩溃中恢复</strong>:</p>
<ul>
<li>如果崩溃或断电发生在上述第 2 步操作之前, 即事务被提交之前, 那么文件系统将简单地跳过这次更新.</li>
<li>如果崩溃或断电发生在上述第 2 步之后、执行第 3 步的过程中, 那么文件系统可以在系统引导阶段扫描日志并查找到已成功提交的事务, 并重新执行这些事务.</li>
</ul>
<p>此外, 为了降低大量额外的磁盘流量, 一些文件系统不会一次一个向磁盘提交每个更新, 而是将所有更新缓冲到全局事务中, 最后提交包含所有更新的单个全局事务. 因此和延迟写入类似, 通过缓冲更新, 文件系统在很多情况下可以避免对磁盘过多的写入流量.</p>
<p>由于日志位于磁盘上, 所以它的大小是有限的, 如果不断往日志中添加事务, 那么它很快就会被填满. 这可能导致两个问题:</p>
<ul>
<li>随着日志越来越多, 恢复时间越来越长.</li>
<li>当日志变满或接近满时, 无法向磁盘提交事务.</li>
</ul>
<p>为了解决上述问题, 日志文件系统将日志视为循环数据结构, 如下图所示:</p>
<p><img src="/img/Pictures/20230527154441.png" srcset="/img/loading.gif" lazyload alt=""></p>
<ul>
<li>将日志视为循环数据结构, 在日志超级块中标记最旧和最新的事务</li>
</ul>
<p>因此, <strong>数据日志最终可以分为四步</strong>:</p>
<ol>
<li>日志写入: 将事务的内容 (TxB、元数据块和数据块) 写入日志, 等待这些写入完成.</li>
<li>日志提交: 将事务提交块 (包括 TxE) 写入日志, 一旦完成, 我们认为事务已经成功提交.</li>
<li>加检查点: 将日志中的事务 (元数据和数据更新) 写入磁盘的最终位置上.</li>
<li>释放: 一段时间后, 更新日志超级块, 将已完成加检查点的事务标记为空闲.</li>
</ol>
<p>由于需要将每个更新数据块写入磁盘两次, 数据日志方案可能仍然需要昂贵的开销.</p>
<h4 id="元数据日志">元数据日志</h4>
<p>由于将每个数据块写入磁盘的成本很高, 而在数据日志方案中, 每次写入磁盘需要先写入日志, 从而使得写入流量加倍. 因此, 为了提高性能, 使用一种称为<strong>元数据日志 (Metadata Journaling)</strong> 的日志形式.</p>
<p>元数据日志与数据日志的协议几乎相同, 只是<strong>不将用户数据写入日志中</strong>, 以前面的更新例子为例, 元数据日志如下所示:</p>
<p><img src="/img/Pictures/20230527191412.png" srcset="/img/loading.gif" lazyload alt=""></p>
<ul>
<li>元数据日志, 现在用户数据 Db 不再被写入日志中</li>
</ul>
<p>用户数据 Db 没有被写入元数据日志中, 而是直接写入磁盘的最终位置上. 由于磁盘的大多数 I/O 流量是数据, 不需要两次写入用户数据, 将会是显著的性能提升.</p>
<p>还需考虑何时将用户数据写入磁盘上. 如果我们在元数据写入磁盘且事务提交完成后再写入用户数据, 那么在事务提交和写入用户数据之间发生断电或崩溃时, 用户数据将会丢失, 此时, 虽然文件系统的元数据是一致的, 但是它们可能会指向垃圾数据. 为了防止上述情况的发生, 用户数据应该在相关元数据写入磁盘之前完成, 或者, 应该在事务提交之前完成 (此时目录的内容也被视为元数据).</p>
<p><strong>元数据日志的协议</strong>如下:</p>
<ol>
<li>数据写入: 将用户数据写入到磁盘最终位置上, 等待其完成.</li>
<li>日志元数据写入: 将事务的内容 (TxB 和元数据) 写入日志, 等待写入完成.</li>
<li>日志提交: 将事务提交块 (包括 TxE) 写入日志, 一旦完成, 我们认为事务已经成功提交.</li>
<li>对元数据加检查点: 将日志中的事务 (元数据更新) 写入磁盘的最终位置上.</li>
<li>释放: 一段时间后, 更新日志超级块, 将已完成检查点的事务标记为空闲.</li>
</ol>
<p>在该协议下, 元数据被写入磁盘两次, 用户数据被写入磁盘一次. 通过强制先写入用户数据, 文件系统可以保证指正永远不会指向垃圾数据.</p>
<p><strong>对于该协议的第一步, 不一定要阻塞地等待数据写入完成, 可以同时发出用户数据写入、TxB 写入和元数据写入三种请求, 只需要在事务提交发出之前完成数据写入和日志元数据写入即可</strong> (在第三步开始之前, 第一步和第二步必须完成).</p>
<h2 id="层次结构与磁盘布局">层次结构与磁盘布局</h2>
<p><strong>Xv6 文件系统的层次结构</strong>有 7 层, 如下所示:</p>
<p><img src="/img/Pictures/20230529190019.png" srcset="/img/loading.gif" lazyload alt=""></p>
<ul>
<li>磁盘层 (Disk Layer): 与 QEMU 仿真的虚拟磁盘打交道, 往虚拟磁盘上读或写一些块.</li>
<li>缓冲区缓存层 (Buffer Cache Layer): 负责将磁盘块缓存在内存中, 并且在这一层管理所有进程对缓存块的并发访问, 保证一次只有一个进程修改某一缓存块.</li>
<li>日志层 (Logging Layer): 为高层提供更新磁盘的接口, 高层对几个磁盘块的更新将被打包成事务放入日志层, 日志层随后确保这些更新是原子的, 并且能支持崩溃恢复.</li>
<li>Inode 层 (Inode Layer): 为文件层提供接口, 每个文件都是独立的, 且有一个唯一的 Inode 号标识, Inode 里面还有指向文件数据块所在磁盘位置的信息.</li>
<li>目录层 (Directory Layer): 目录被看成是一种特殊的文件, 因此它的 Inode 含义也和普通文件不同, 它的数据是一系列的目录条目, 包含该目录下的文件名和文件的 Inode 号.</li>
<li>路径名层 (Pathname Layer), 提供符合文件系统层次结构的路径名, 处理路径名递归查找.</li>
<li>文件描述符层 (File Descriptor Layer): 文件描述符是对底层所有资源 (管道、设备、普通文件等) 的抽象, 用户对文件描述符的视图是简单而统一的, 这方便了用户程序的编程.</li>
</ul>
<p><strong>Xv6 采用的磁盘布局</strong>如下图所示:</p>
<p><img src="/img/Pictures/20230529200244.png" srcset="/img/loading.gif" lazyload alt=""></p>
<ul>
<li>虽然常见的块的大小为 4KB, 但是在 Xv6 中, 块的大小为 1KB.</li>
<li>Xv6 文件系统不使用块 0, 该块作为引导块.</li>
<li>块 1 是超级块, 它包含关于完整文件系统的元数据, 如文件系统的大小或块数、数据块的数量、Inodes 的数量、日志块的数量等.</li>
<li>块 2 开始到块 31 为止的 30 个块作为日志块.</li>
<li>从块 32 开始是 Inodes, 每一个 Inode Block 上面都有多个 Inodes.</li>
<li>块 45 作为位图, 用于跟踪哪些数据块已被分配.</li>
<li>从块 46 开始后续的全部作为数据块, 包含着文件或目录.</li>
</ul>
<p>超级块中存放的是一个独立的程序, 称为 mkfs (make file system, 位于 mkfs/mkfs.c), 它负责构建并挂载初始的 Xv6 文件系统 (如初始化文件系统的超级块、inodes、位图等元数据结构, 并设置初始的目录结构和文件).</p>
<h3 id="缓冲区缓存层">缓冲区缓存层</h3>
<p>缓冲区缓存主要做两件事:</p>
<ul>
<li>同步所有对磁盘块的并发访问, 保证一个磁盘块要么没有被缓存, 要么在内存中只有一份缓存副本, 并且一次只有一个内核线程可以使用该副本.</li>
<li>缓存磁盘块时, 应该保留那些常被访问的磁盘块不被逐出缓冲区缓存.</li>
</ul>
<p>缓冲区缓存主要向上提供两个重要接口:</p>
<ul>
<li>bread: 获取内存中的一份缓存块, 该缓存块包含了相应磁盘块的副本.</li>
<li>bwrite: 将修改后的缓存块冲刷到磁盘上, 完成相应块的更新.</li>
</ul>
<p>缓冲区缓存对每一个缓存块都维护了一把睡眠锁, 以保证一次只有一个内核线程可以使用该缓存块, 因此一次只有一个内核线程在修改某一磁盘块的副本.</p>
<p>缓冲区缓存有固定数量的槽位, 每个槽位保存一个磁盘块的副本. 如果文件系统希望访问的磁盘块不在缓冲区缓存中, 就需要回收一个已经含有缓存块的槽位, 以满足此次请求, 通常缓冲区缓存使用 LRU 算法来回收这些槽位.</p>
<p><strong>下面是 Xv6 中关于缓冲区缓存的实现</strong>:</p>
<p>缓冲区缓存 (struct bcache) 的定义如下所示:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">spinlock</span> <span class="hljs-title">lock</span>;</span>  <span class="hljs-comment">// Buffer Cache自己有一把自旋锁，而每个缓存块也有一把睡眠锁</span><br>                         <span class="hljs-comment">// Buffer Cache的自旋锁保护哪些块已经被缓存的信息</span><br>                         <span class="hljs-comment">// 而每个缓存块的睡眠锁保护对该块内容的读与写</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">buf</span> <span class="hljs-title">buf</span>[<span class="hljs-title">NBUF</span>];</span>  <span class="hljs-comment">// NBUF = MAXOPBLOCKS * 3 = 30</span><br><br>  <span class="hljs-comment">// Linked list of all buffers, through prev/next.</span><br>  <span class="hljs-comment">// Sorted by how recently the buffer was used.</span><br>  <span class="hljs-comment">// head.next is most recent, head.prev is least.</span><br>  <span class="hljs-comment">// i.e. LRU replace algorithm</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">buf</span> <span class="hljs-title">head</span>;</span><br>&#125; bcache;<br></code></pre></td></tr></table></figure>
<ul>
<li>有一把自旋锁 bcache.lock 来保护整个缓冲区缓存, 主要用来保护链接所有槽位的链表, 这么有 30 个槽位可用.</li>
</ul>
<p>缓冲区缓存的一个槽位 (struct buf)的定义如下所示:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">buf</span> &#123;</span><br>  <span class="hljs-type">int</span> valid;   <span class="hljs-comment">// has data been read from disk?</span><br>               <span class="hljs-comment">// indicates that the buffer contains a copy of the block or not</span><br>  <span class="hljs-type">int</span> disk;    <span class="hljs-comment">// does disk &quot;own&quot; buf?</span><br>               <span class="hljs-comment">// indicates that the buffer content has been handed to the disk</span><br>               <span class="hljs-comment">// if disk == 1, wait for virtio_disk_intr() to say request has finished</span><br>               <span class="hljs-comment">// if disk == 0, then disk is done with buf</span><br>  uint dev;<br>  uint blockno;  <span class="hljs-comment">// block number, but more exactly, is the sector number</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sleeplock</span> <span class="hljs-title">lock</span>;</span>  <span class="hljs-comment">// 每个缓存块一把睡眠锁</span><br>  uint refcnt;   <span class="hljs-comment">// 当前有多少个内核线程在排队等待读这个缓存块</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">buf</span> *<span class="hljs-title">prev</span>;</span>  <span class="hljs-comment">// LRU cache list</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">buf</span> *<span class="hljs-title">next</span>;</span><br>  uchar data[BSIZE];  <span class="hljs-comment">// BSIZE = 1024，xv6的块大小是1024B</span><br>&#125;;<br></code></pre></td></tr></table></figure>
<ul>
<li>每个槽位对应一把睡眠锁, 保护 buf 中的信息.</li>
<li>valid 字段表示该槽位上是否缓存了磁盘块的副本.</li>
<li>disk 字段表示磁盘正在处理该缓存块的读或写请求, 如果磁盘还未处理完成, disk = 1; 如果磁盘处理完成, disk = 0.</li>
<li>blockno 字段表示缓存的磁盘块在磁盘上的位置.</li>
<li>refcnt 字段表示当前有多少个内核线程在使用该缓存块.</li>
</ul>
<p>缓存区缓存的初始化函数 (binit) 实现如下:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span><br><span class="hljs-title function_">binit</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">buf</span> *<span class="hljs-title">b</span>;</span><br><br>  initlock(&amp;bcache.lock, <span class="hljs-string">&quot;bcache&quot;</span>);<br><br>  <span class="hljs-comment">// Create linked list of buffers</span><br>  bcache.head.prev = &amp;bcache.head;<br>  bcache.head.next = &amp;bcache.head;<br>  <span class="hljs-keyword">for</span>(b = bcache.buf; b &lt; bcache.buf+NBUF; b++)&#123;<br>    <span class="hljs-comment">// 头插法</span><br>    b-&gt;next = bcache.head.next;<br>    b-&gt;prev = &amp;bcache.head;<br>    initsleeplock(&amp;b-&gt;lock, <span class="hljs-string">&quot;buffer&quot;</span>);<br>    bcache.head.next-&gt;prev = b;<br>    bcache.head.next = b;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li>该函数首先初始化自旋锁 bcache.lock, 然后将 NBUF 个槽位用头插法连接成一个链表 (双向链表), 初始化之后, 所有对于缓冲区缓存的访问将通过 bcache.head, 而不是静态数组bcache.buf.</li>
</ul>
<p>从缓冲区缓存中读取缓存块的函数 (bread) 实现如下:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Return a locked buf with the contents of the indicated block.</span><br><span class="hljs-keyword">struct</span> buf*<br><span class="hljs-title function_">bread</span><span class="hljs-params">(uint dev, uint blockno)</span><br>&#123;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">buf</span> *<span class="hljs-title">b</span>;</span><br><br>  b = bget(dev, blockno);<br>  <span class="hljs-comment">// b-&gt;valid为0说明这是刚被回收的一个槽位</span><br>  <span class="hljs-comment">// 所以要从磁盘上读取磁盘块到该槽位上</span><br>  <span class="hljs-keyword">if</span>(!b-&gt;valid) &#123;<br>    virtio_disk_rw(b, <span class="hljs-number">0</span>);  <span class="hljs-comment">// 0代表读取磁盘块</span><br>    b-&gt;valid = <span class="hljs-number">1</span>;<br>  &#125;<br>  <span class="hljs-keyword">return</span> b;<br>  <span class="hljs-comment">// 返回的缓存块是上锁的，如果调用者修改了缓存块里面的内容，就需要调用bwrite把它写到磁盘上</span><br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li>该函数通过调用 bget 来获取指定磁盘块的缓存块, 如果 b-&gt;valid = 0, 则说明该槽位没有缓存任何磁盘块, 因此调用 virtio_disk_rw 来从磁盘上读取相应磁盘块并缓存到缓冲区缓存中, 更新 b-&gt;valid.</li>
<li>bread 最后返回的是持有锁的缓存块.</li>
</ul>
<p>bget 实现如下:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Look through buffer cache for block on device dev.</span><br><span class="hljs-comment">// 块槽位，供这个新的缓存块使用</span><br><span class="hljs-comment">// bget返回的是上锁的缓存块</span><br><span class="hljs-type">static</span> <span class="hljs-keyword">struct</span> buf*<br><span class="hljs-title function_">bget</span><span class="hljs-params">(uint dev, uint blockno)</span><br>&#123;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">buf</span> *<span class="hljs-title">b</span>;</span><br>  <br>  <span class="hljs-comment">// 多个线程访问Buffer Cache时，总是在外面等待</span><br>  acquire(&amp;bcache.lock);<br><br>  <span class="hljs-comment">// Is the block already cached?</span><br>  <span class="hljs-comment">// head.next指向最近使用最多的缓存块</span><br>  <span class="hljs-keyword">for</span>(b = bcache.head.next; b != &amp;bcache.head; b = b-&gt;next)&#123;<br>    <span class="hljs-keyword">if</span>(b-&gt;dev == dev &amp;&amp; b-&gt;blockno == blockno)&#123;<br>      <span class="hljs-comment">// Buffer Cache命中！</span><br>      <span class="hljs-comment">// 每当有一个线程希望使用该缓存块时，引用计数就加1</span><br>      b-&gt;refcnt++;<br>      release(&amp;bcache.lock);<br>      <span class="hljs-comment">// 不能同时持有bcache.lock和b.lock，否则在brelse中有可能死锁</span><br>      <span class="hljs-comment">// 返回上锁的缓存块</span><br>      <span class="hljs-comment">// 在bget中获得缓存块的b-&gt;lock，在brelse中释放该b-&gt;lock</span><br>      acquiresleep(&amp;b-&gt;lock);<br>      <span class="hljs-keyword">return</span> b;<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-comment">// Not cached.</span><br>  <span class="hljs-comment">// Recycle the least recently used (LRU) unused buffer.</span><br>  <span class="hljs-comment">// head.prev指向最近使用最少的缓存块</span><br>  <span class="hljs-comment">// Buffer Cache未命中，从head.prev开始寻找可以回收的LRU缓存块</span><br>  <span class="hljs-keyword">for</span>(b = bcache.head.prev; b != &amp;bcache.head; b = b-&gt;prev)&#123;<br>    <span class="hljs-keyword">if</span>(b-&gt;refcnt == <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-comment">// refcnt表示当前正在排队，希望读该缓存块的线程数</span><br>      <span class="hljs-comment">// 如果没有线程要读这个缓存块，而且它是LRU的，那就回收它</span><br>      b-&gt;dev = dev;<br>      b-&gt;blockno = blockno;<br>      <span class="hljs-comment">// 回收之后，原来槽位里的缓存块内容就无效</span><br>      <span class="hljs-comment">// 需要重新从磁盘上读取新的磁盘块内容</span><br>      b-&gt;valid = <span class="hljs-number">0</span>;<br>      <span class="hljs-comment">// 现在本内核线程要使用该缓存块，先将refcnt置1，因此这一块不会马上又被回收</span><br>      b-&gt;refcnt = <span class="hljs-number">1</span>;<br>      release(&amp;bcache.lock);<br>      acquiresleep(&amp;b-&gt;lock);<br>      <span class="hljs-comment">// 返回上锁的缓存块</span><br>      <span class="hljs-keyword">return</span> b;<br>    &#125;<br>  &#125;<br><br>  panic(<span class="hljs-string">&quot;bget: no buffers&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li>根据输入的设备号和块号扫描缓冲区缓存中的所有缓存块.
<ul>
<li>如果缓存命中, bget 更新引用计数 refcnt, 释放 bcache.lock (此时其他线程可以访问缓冲区缓存), 获取该缓存块的睡眠锁 b-&gt;lock 并返回该缓存块.</li>
<li>如果缓存未命中, bget 就要从 head.prev 开始寻找需要驱逐的缓存块, 此处未找到一个目前没有被其他线程使用 (refcnt = 0) 的槽位, 然后更新该槽位的一些元数据, 最后获取该槽位的睡眠锁.</li>
<li>为了保证所有的 bread 可以看到 bwrite 的相应修改, 每个缓存块只能同时被一个内核线程访问.</li>
<li>如果所有的槽位都满了, 即有太多的线程同时执行文件系统操作, 这里 bget 简单地 panic. 一种更合适的做法是: 让相应的线程先挂起睡眠, 直到缓冲区缓存中有了空的槽位再将其唤醒.</li>
</ul>
</li>
</ul>
<p>在内核线程调用 bread, 并且得到它需要的缓存块之后, 线程就能够使用它进行读或写; 一旦线程修改了缓存块的内容, 那么应该在调用 brelse 释放缓存块之前, 调用 bwrite 来将更新冲刷到磁盘上. bwrite 的实现如下:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Write b&#x27;s contents to disk.  Must be locked.</span><br><span class="hljs-type">void</span><br><span class="hljs-title function_">bwrite</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> buf *b)</span><br>&#123;<br>  <span class="hljs-keyword">if</span>(!holdingsleep(&amp;b-&gt;lock))<br>    panic(<span class="hljs-string">&quot;bwrite&quot;</span>);<br>  virtio_disk_rw(b, <span class="hljs-number">1</span>);  <span class="hljs-comment">// 1代表写入磁盘块</span><br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li>该函数首先保证持有该缓存块的睡眠锁, 然后调用 virtio_dist_rw 将更新后的缓存块冲刷到磁盘上的相应位置.</li>
</ul>
<p>当一个内核线程使用完一个缓存块, 就需要调用 brelse 释放它, brelse 的实现如下:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Release a locked buffer.</span><br><span class="hljs-comment">// Move to the head of the most-recently-used list.</span><br><span class="hljs-comment">// A kernel thread must release a buffer by calling brelse when it is done with it. </span><br><span class="hljs-comment">// When the caller is done with a buffer, it must call brelse to release it.</span><br><span class="hljs-comment">// 调用者结束对一个缓存块的处理(读或写)之后，</span><br><span class="hljs-comment">// 调用brelse更新bcache的链表，并且释放对应的缓存块的睡眠锁</span><br><span class="hljs-type">void</span><br><span class="hljs-title function_">brelse</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> buf *b)</span><br>&#123;<br>  <span class="hljs-keyword">if</span>(!holdingsleep(&amp;b-&gt;lock))<br>    panic(<span class="hljs-string">&quot;brelse&quot;</span>);<br><br>  <span class="hljs-comment">//在bget获得缓存块b的锁，在这里释放</span><br>  releasesleep(&amp;b-&gt;lock);<br><br>  acquire(&amp;bcache.lock);<br>  b-&gt;refcnt--;<br>  <span class="hljs-comment">//最近刚刚更新的块b-&gt;refcnt=1</span><br>  <span class="hljs-keyword">if</span> (b-&gt;refcnt == <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-comment">// no one is waiting for it.</span><br>    <span class="hljs-comment">// 这个判断条件是为了减少链表的更新次数</span><br>    <span class="hljs-comment">// 如前面在bget所说，当两个线程希望读b而b之前没有被缓存</span><br>    <span class="hljs-comment">// 那么第一个线程进来之后，refcnt = 2，自减后为1</span><br>    <span class="hljs-comment">// refcnt不为0则说明还有其它的线程在等待要读它</span><br>    <span class="hljs-comment">// 因此之后该缓存块一定会被更新，即链表一定会被更新</span><br>    <span class="hljs-comment">// 因此这次的更新可以跳过，交给最后一个希望读它的线程来完成</span><br>    <span class="hljs-comment">// (最后一个希望读该缓存块的refcnt = 0)</span><br>    b-&gt;next-&gt;prev = b-&gt;prev;<br>    b-&gt;prev-&gt;next = b-&gt;next;<br>    b-&gt;next = bcache.head.next;<br>    b-&gt;prev = &amp;bcache.head;<br>    bcache.head.next-&gt;prev = b;<br>    bcache.head.next = b;<br>  &#125;<br>  <br>  release(&amp;bcache.lock);<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li>该函数首先释放缓存块的睡眠锁, 然后减少该缓存块的引用计数 refcnt, 然后更新链表, 将这一缓存块移动到链表的最前端, 表示该缓存块是最近使用的, 即 bcache.head.next 是最近使用的缓存块, 而 bcache.head.pre 是最近最少使用的缓存块. 这一实现便和前面的 bget 的逻辑对应, bget 的两个循环中, 希望查找已被缓存的磁盘块时, 从 bcache.head.next 开始正向搜索, 而希望查找可以回收的缓存块时, 从 head.prev 开始反向搜索.</li>
</ul>
<p>bpin 和 bunpin 分别对缓存块的引用计数 refcnt 进行加减, 实现如下:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span><br><span class="hljs-title function_">bpin</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> buf *b)</span> &#123;<br>  acquire(&amp;bcache.lock);<br>  b-&gt;refcnt++;<br>  release(&amp;bcache.lock);<br>&#125;<br><br><span class="hljs-type">void</span><br><span class="hljs-title function_">bunpin</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> buf *b)</span> &#123;<br>  acquire(&amp;bcache.lock);<br>  b-&gt;refcnt--;<br>  release(&amp;bcache.lock);<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li>这两个函数在日志层中使用以保证写入日志的缓存块不会被回收.</li>
</ul>
<h3 id="日志层">日志层</h3>
<p>文件系统的重要一部分是崩溃恢复, 很多文件系统操作包含多次的写磁盘操作, 如果崩溃或断电在这些写操作的中间发生, 那么就会导致磁盘上的数据结构处于不一致的状态.</p>
<p>解决崩溃一致问题的常规方案就是使用日志记录. Xv6 的数据日志需要遵循的协议和之前讨论过的一样. 如果系统崩溃或断电, 重启之后, 在启动阶段, 文件系统的恢复程序就会检查日志上是否有已被提交的完整事务. 如果有, 那么就重放它们, 即将日志内容重新写到磁盘上的相应位置; 如果没有, 那么就无视这部分日志. 最后, 恢复程序会清除日志.</p>
<p>Xv6 的日志区域驻留在磁盘的一个固定位置上, 并且在超级块中也有其位置的记录. 日志区域包括了一个日志头块 (Log Header), 以及一系列的日志块, 它们是更新后的缓存块的副本 (Logged Blocks). 磁盘上的 Log Header 包含一个数组, 用于记录每个 Logged Block 要写入的目的磁盘位置 (即扇区号), 以及对 Logged Block 的计数 n. 这个计数 n 要么为 0, 表示日志区中没有事务; 要么不为 0, 表示日志区包含有一个已成功提交的事务, 且该事务要处理的日志块数量为 n.</p>
<p>Xv6 在将所有 Logged Blocks 写入日志之后, 才写入 Log Header, 一旦写入磁盘成功, 就表示该事务被成功提交. 然后在加检查点完成之后对计数 n 进行清零. 若崩溃发生在事务成功提交之前, Log Header 中存储的计数 n 为 0; 若发生在事务提交之后, Log Header 中存储的计数 n 不为 0.</p>
<p>在使用文件系统的系统调用时, 需要指定哪一部分的一系列写磁盘操作应该是原子的. 为了提高文件系统操作的并发性, 如果有多个文件系统调用并发执行, 只要日志区域的空间足够, 日志系统将收集来自多个文件系统调用的多个写磁盘操作, 并将它们组织成一个事务, 因此, 一个事务提交可能包含来自多个文件系统调用的写磁盘请求. 为了避免将一次文件系统调用拆散到多个事务中, 仅在当前没有文件系统调用执行时, 日志系统才提交事务.</p>
<p>这种将多个文件系统调用的事务合并为一个大的事务然后一次性提交的思想称为<strong>组提交 (Group Commit)</strong>. 组提交可以有效减少磁盘操作数.</p>
<p>Xv6 日志系统和真实系统的日志系统很大区别在于并发性. 在数据日志模式下, Xv6 一次只能处理一个事务, 即在完成这次事务的提交之前, 不能执行另一个系统调用; 而以 Linux 的 ext3 为例, 可以在提交一个事务的同时并发地执行另一个系统调用, 写入新的事务.</p>
<p>Xv6 文件系统预留了固定大小的空间给日志系统, 因此文件系统调用在一次事务提交中所需更新的磁盘块的数量不能超过该大小.</p>
<ul>
<li>由于 write 和 unlink 这两个文件系统调用可能会更新大量的磁盘块: 对于一个大文件的写入, 可能需要写入远大于日志空间大小的缓存块; unlink 一个大文件, 可能需要更新大量的数据块位图和文件的 Inode. 对于 Xv6 来说, 会将一个大的 write 拆分成多个符合大小要求的写请求, 而 unlink 不会引起问题, 因为 Xv6 只有一个数据块位图.</li>
<li>对于日志空间大小不足的情况, 如果日志区域中还有旧的事务存留, 且剩余空间不能满足一个新的文件系统调用请求, 那么新的文件系统调用将会阻塞, 直到日志区域中腾出足够的空间为止.</li>
</ul>
<p><strong>下面是 Xv6 中关于日志的实现</strong>:</p>
<p><strong>一个常规的、使用日志系统的文件系统调用, 其代码框架</strong>大致如下:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c">begin_op();<br><span class="hljs-comment">// ...</span><br>bp = bread(...);      <span class="hljs-comment">// read out bp</span><br>bp-&gt;data[...] = ...;  <span class="hljs-comment">// modify bp-&gt;data[]</span><br>log_write(bp);        <span class="hljs-comment">// bp has been modified, so put it in log</span><br>brelse(bp);           <span class="hljs-comment">// release bp</span><br><span class="hljs-comment">// ...</span><br>end_op();<br></code></pre></td></tr></table></figure>
<ul>
<li>这个框架还不够完整 (没有 Inode 层).</li>
</ul>
<p>与日志相关的主要上层接口有三个: begin_op、log_write 和 end_op, 下面我们按上述框架的逻辑顺序, 逐步介绍日志层的实现和工作逻辑.</p>
<p><strong>log 的数据结构</strong>如下所示:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">logheader</span> &#123;</span><br>  <span class="hljs-type">int</span> n;  <span class="hljs-comment">// the count of log blocks</span><br>          <span class="hljs-comment">// n=0代表当前log不包含完整的磁盘操作</span><br>          <span class="hljs-comment">// n不为0代表有log中有n块需要被写到磁盘上</span><br>  <span class="hljs-type">int</span> block[LOGSIZE];  <span class="hljs-comment">// The header block contains an array of sector numbers, one for each of the logged blocks</span><br>                       <span class="hljs-comment">// LOGSIZE = 30，即log可以包含30个blocks</span><br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">log</span> &#123;</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">spinlock</span> <span class="hljs-title">lock</span>;</span><br>  <span class="hljs-type">int</span> start;       <span class="hljs-comment">// Block number of first log block</span><br>  <span class="hljs-type">int</span> size;<br>  <span class="hljs-type">int</span> outstanding; <span class="hljs-comment">// how many FS sys calls are executing.</span><br>                   <span class="hljs-comment">// counts the number of system calls that have reserved log space</span><br>                   <span class="hljs-comment">// the total reserved space = log.outstanding * MAXOPBLOCKS</span><br>                   <span class="hljs-comment">// 和缓存块的refcnt类似，表示当前执行FS syscalls的线程数</span><br>                   <span class="hljs-comment">// 在begin_op中会加1，在end_op中会减1</span><br>                   <span class="hljs-comment">// 等于0时说明当前没有正在执行的FS sys calls，</span><br>                   <span class="hljs-comment">// 如果在end_op中发现该计数为0，说明这时候可以提交log</span><br>  <span class="hljs-type">int</span> committing;  <span class="hljs-comment">// in commit(), please wait.</span><br>  <span class="hljs-type">int</span> dev;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">logheader</span> <span class="hljs-title">lh</span>;</span><br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">log</span> <span class="hljs-title">log</span>;</span><br></code></pre></td></tr></table></figure>
<ul>
<li>这里涉及两个数据结构:
<ul>
<li>struct logheader: 包含前面提到的计数 n 和一个数组 block, 数组指示了每个 logged blocks 要写入的目标磁盘位置.</li>
<li>struct log: 由一把锁、一个 logheader 和一系列标志位组成. 其中 start 记录日志区域开始的磁盘位置, size 是日志区域的总块数, outstanding 表示当前有多少文件系统调用正在使用日志系统, committing 表示日志系统是否正在加检查点.</li>
</ul>
</li>
</ul>
<p><strong>begin_op 函数实现</strong>如下:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// called at the start of each FS system call.</span><br><span class="hljs-type">void</span><br><span class="hljs-title function_">begin_op</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>  acquire(&amp;<span class="hljs-built_in">log</span>.lock);<br>  <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">log</span>.committing)&#123;<br>      <span class="hljs-comment">// 等待当前加检查点的完成</span><br>      sleep(&amp;<span class="hljs-built_in">log</span>, &amp;<span class="hljs-built_in">log</span>.lock);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(<span class="hljs-built_in">log</span>.lh.n + (<span class="hljs-built_in">log</span>.outstanding+<span class="hljs-number">1</span>)*MAXOPBLOCKS &gt; LOGSIZE)&#123;<br>      <span class="hljs-comment">// this op might exhaust log space; wait for commit.</span><br>      <span class="hljs-comment">// until there is enough unreserved log space to hold the writes from this call</span><br>      <span class="hljs-comment">// 如果当前日志区域没有足够空间，先挂起</span><br>      sleep(&amp;<span class="hljs-built_in">log</span>, &amp;<span class="hljs-built_in">log</span>.lock);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-comment">// 现在受理该FS系统调用</span><br>      <span class="hljs-built_in">log</span>.outstanding += <span class="hljs-number">1</span>;<br>      release(&amp;<span class="hljs-built_in">log</span>.lock);<br>      <span class="hljs-keyword">break</span>;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li>该函数应该在每个文件系统调用开始之前被调用. 它等待日志系统加检查点的完成, 且有足够的空间容纳新的事务时, 才会开始处理新的文件系统调用.  当前日志系统中已被使用的空间为 log.outstanding * MAXOPBLOCKS (Xv6 的每次文件系统调用最多只会提交数量为 MAXOPBLOCKS 的日志块). 通过增加 log.outstanding 计数, 不仅能表示该文件系统调用现在占用日志系统的部分空间, 还防止日志系统在文件系统调用的中途就提交事务.</li>
</ul>
<p><strong>log_write 函数实现如下</strong>:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Caller has modified b-&gt;data and is done with the buffer.</span><br><span class="hljs-comment">// Record the block number and pin in the cache by increasing refcnt.</span><br><span class="hljs-comment">// commit()/write_log() will do the disk write.</span><br><span class="hljs-type">void</span><br><span class="hljs-title function_">log_write</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> buf *b)</span><br>&#123;<br>  <span class="hljs-type">int</span> i;<br><br>  <span class="hljs-comment">// 检查当前已经写入log header的log blocks数量，上限为LOGSIZE</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">log</span>.lh.n &gt;= LOGSIZE || <span class="hljs-built_in">log</span>.lh.n &gt;= <span class="hljs-built_in">log</span>.size - <span class="hljs-number">1</span>)<br>    panic(<span class="hljs-string">&quot;too big a transaction&quot;</span>);<br>  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">log</span>.outstanding &lt; <span class="hljs-number">1</span>)<br>    panic(<span class="hljs-string">&quot;log_write outside of trans&quot;</span>);<br><br>  acquire(&amp;<span class="hljs-built_in">log</span>.lock);<br>  <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">log</span>.lh.n; i++) &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">log</span>.lh.block[i] == b-&gt;blockno)   <span class="hljs-comment">// log absorbtion</span><br>      <span class="hljs-comment">// 如果之前已经在log中有提交对同一个块b的更新</span><br>      <span class="hljs-comment">// 就不用分配新的logged block，直接修改上次的即可</span><br>      <span class="hljs-keyword">break</span>;<br>  &#125;<br>  <span class="hljs-comment">// 如果之前没有提交过块b的更新，那么i=log.lh.n</span><br>  <span class="hljs-comment">// 然后紧接着上次写日志的地方，往logheader的block[n]写入块b的目标磁盘位置</span><br>  <span class="hljs-built_in">log</span>.lh.block[i] = b-&gt;blockno;<br>  <span class="hljs-keyword">if</span> (i == <span class="hljs-built_in">log</span>.lh.n) &#123;  <span class="hljs-comment">// Add new block to log?</span><br>    <span class="hljs-comment">// pins the buffer in the block cache to prevent the block cache from evicting it</span><br>    <span class="hljs-comment">// 为了不违反原子性，日志块不应该被逐出，因为逐出会马上被写入到磁盘上</span><br>    <span class="hljs-comment">// 所以调用bpin增加其引用计数refcnt，这样就不会被逐出</span><br>    <span class="hljs-comment">// 在install_trans的时候会bunpin相应的块</span><br>    bpin(b);<br>    <span class="hljs-built_in">log</span>.lh.n++;<br>    <span class="hljs-comment">// 直到调用commit开始提交以前，这些事务块还是位于内存的Buffer Cache中</span><br>  &#125;<br>  release(&amp;<span class="hljs-built_in">log</span>.lock);<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li>假设我们读取了缓存块并更新了, 就需要再写回到磁盘中, 如果我们要使用日志系统, 就应该使用日志系统提供的接口 log_write, 而不是 Buffer Cache 提供的接口 bwrite.</li>
<li>该函数首先检查写日志操作是否合法, 然后记录下每个日志块要写入的磁盘位置, 增加 logheader 的计数 n, 还要用 bpin 增加对应的缓存块的引用计数 refcnt, 这样它们就不会被逐出, 因此不会被提前写入磁盘.</li>
<li>如果一个缓存块被提交多次, 不会额外分配日志空间, 而是继续使用日志区域中相同的槽位. 最终, 每个缓存块只有一份更新后的副本会被写入磁盘上, 这种优化被称为<strong>吸收 (Absorption)</strong>.</li>
</ul>
<p><strong>end_op 函数的实现</strong>如下:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// called at the end of each FS system call.</span><br><span class="hljs-comment">// commits if this was the last outstanding operation.</span><br><span class="hljs-type">void</span><br><span class="hljs-title function_">end_op</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>  <span class="hljs-type">int</span> do_commit = <span class="hljs-number">0</span>;<br><br>  acquire(&amp;<span class="hljs-built_in">log</span>.lock);<br>  <span class="hljs-comment">// FS sys calls is ending, decrease log.outstanding</span><br>  <span class="hljs-built_in">log</span>.outstanding -= <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">if</span>(<span class="hljs-built_in">log</span>.committing)<br>    panic(<span class="hljs-string">&quot;log.committing&quot;</span>);  <span class="hljs-comment">// 没有事务能够在还有FS调用的情况下就被提交</span><br>                              <span class="hljs-comment">// 如果发生了，就是panic</span><br>  <span class="hljs-keyword">if</span>(<span class="hljs-built_in">log</span>.outstanding == <span class="hljs-number">0</span>)&#123;<br>    <span class="hljs-comment">// 当前没有FS sys calls，可以开始事务提交</span><br>    do_commit = <span class="hljs-number">1</span>;<br>    <span class="hljs-built_in">log</span>.committing = <span class="hljs-number">1</span>;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// begin_op() may be waiting for log space,</span><br>    <span class="hljs-comment">// and decrementing log.outstanding has decreased the amount of reserved space.</span><br>    <span class="hljs-comment">// 如果当前还有其它FS调用正在执行，那么我们先不急着提交</span><br>    <span class="hljs-comment">// 而是留给最后一个FS调用负责提交所有事务，这是group commit</span><br>    <span class="hljs-comment">// 此外，可能有其它FS调用在begin_op时因空间不足而被挂起</span><br>    <span class="hljs-comment">// 现在可能有空间可用，唤醒一个被挂起的FS调用</span><br>    wakeup(&amp;<span class="hljs-built_in">log</span>);<br>  &#125;<br>  release(&amp;<span class="hljs-built_in">log</span>.lock);<br><br>  <span class="hljs-keyword">if</span>(do_commit)&#123;<br>    <span class="hljs-comment">// call commit w/o holding locks, since not allowed</span><br>    <span class="hljs-comment">// to sleep with locks.</span><br>    commit();<br>    <span class="hljs-comment">// 修改commit状态，需要锁保护</span><br>    acquire(&amp;<span class="hljs-built_in">log</span>.lock);<br>    <span class="hljs-comment">// 全部提交完毕后committing重置0</span><br>    <span class="hljs-comment">// 唤醒一个被挂起的FS调用，它的begin_op现在可以继续</span><br>    <span class="hljs-built_in">log</span>.committing = <span class="hljs-number">0</span>;<br>    wakeup(&amp;<span class="hljs-built_in">log</span>);<br>    release(&amp;<span class="hljs-built_in">log</span>.lock);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li>该函数标志着本次文件系统调用的结束, 准备提交事务. 它首先减少计数 outstanding, 表示当前文件系统调用处理结束. 然后检查自己是否是最后一个文件系统调用 (outstanding 是否为 0), 如果是, 则调用 commit 提交当前日志区域中的所有事务.</li>
</ul>
<p><strong>commit 函数的实现如下</strong>所示:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// xv6 writes the header block when a transaction commits, but not before, </span><br><span class="hljs-comment">// and sets the count to zero after copying the logged blocks to the file system.</span><br><span class="hljs-comment">// a crash midway through a transaction will result in a count of zero in the log’s header block----thus will not recovery</span><br><span class="hljs-comment">// a crash after a commit will result in a non-zero count----thus is to be recovery</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span><br><span class="hljs-title function_">commit</span><span class="hljs-params">()</span><br>&#123;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">log</span>.lh.n &gt; <span class="hljs-number">0</span>) &#123;<br>    write_log();     <span class="hljs-comment">// Write modified blocks from cache to log</span><br>    write_head();    <span class="hljs-comment">// Write header to disk -- the real commit</span><br>                     <span class="hljs-comment">// this is the commit point, and a crash after the write will result in recovery replaying the transaction’s writes from the log</span><br>                     <span class="hljs-comment">// 更新的logheader成功写进磁盘后，代表事务提交成功</span><br>                     <span class="hljs-comment">// 因此从这里开始，到更新完成日志被清除之前，</span><br>                     <span class="hljs-comment">// 如果发生了crash，那么恢复时就会重复log中的操作</span><br>    install_trans(); <span class="hljs-comment">// Now install writes to home locations</span><br>                     <span class="hljs-comment">// 加检查点</span><br>    <span class="hljs-built_in">log</span>.lh.n = <span class="hljs-number">0</span>;    <span class="hljs-comment">// this has to happen before the next transaction starts writing logged blocks, </span><br>                     <span class="hljs-comment">// so that a crash doesn’t result in recovery using one transaction’s header with the subsequent transaction’s logged blocks.</span><br>                     <span class="hljs-comment">// 到这里重新设n=0时，加检查点已经顺利完成了，但n=0还没有写到磁盘的logheader上</span><br>    write_head();    <span class="hljs-comment">// Erase the transaction from the log</span><br>                     <span class="hljs-comment">// 将更新后的n=0写入到磁盘的logheader上，因此旧的日志将被释放/重用</span><br>                     <span class="hljs-comment">// 对logheader更新必须在下一次事务写入log之前发生，</span><br>                     <span class="hljs-comment">// 否则恢复的时候会用下一个事务的log来进行恢复</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li>整个 commit 的过程可以分为四个阶段:
<ol>
<li>write_log 函数实现如下: <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Copy modified blocks from cache to log.</span><br><span class="hljs-comment">// copies each block modified in the transaction from the buffer cache to its slot in the log on disk.</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span><br><span class="hljs-title function_">write_log</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>  <span class="hljs-type">int</span> tail;<br><br>  <span class="hljs-keyword">for</span> (tail = <span class="hljs-number">0</span>; tail &lt; <span class="hljs-built_in">log</span>.lh.n; tail++) &#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">buf</span> *<span class="hljs-title">to</span> =</span> bread(<span class="hljs-built_in">log</span>.dev, <span class="hljs-built_in">log</span>.start+tail+<span class="hljs-number">1</span>); <span class="hljs-comment">// log block</span><br>    <span class="hljs-comment">// 从磁盘上按顺序读出日志区域的磁盘块，额外加1是跳过logheader</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">buf</span> *<span class="hljs-title">from</span> =</span> bread(<span class="hljs-built_in">log</span>.dev, <span class="hljs-built_in">log</span>.lh.block[tail]); <span class="hljs-comment">// cache block</span><br>    <span class="hljs-comment">// 从Buffer Cache中读出更新后的缓存块</span><br>    memmove(to-&gt;data, from-&gt;data, BSIZE);<br>    <span class="hljs-comment">// 从from复制到to，使用memmove后，现在两个缓存块副本都是更新后的状态</span><br>    bwrite(to);  <span class="hljs-comment">// write the log</span><br>    <span class="hljs-comment">// 将更新后的logged block写回磁盘的日志区域上</span><br>    brelse(from);<br>    brelse(to);<br>    <span class="hljs-comment">// 两个缓存块都使用完毕，调用brelse更新链表</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li>该函数将所有位于内存中的、更新后的缓存块按顺序写入到磁盘的日志区域中. 这里对应数据日志四阶段中的日志写入.</li>
</ul>
</li>
<li>write_head函数实现如下: <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Write in-memory log header to disk.</span><br><span class="hljs-comment">// This is the true point at which the</span><br><span class="hljs-comment">// current transaction commits.</span><br><span class="hljs-comment">// writes the header block to disk</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span><br><span class="hljs-title function_">write_head</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">buf</span> *<span class="hljs-title">buf</span> =</span> bread(<span class="hljs-built_in">log</span>.dev, <span class="hljs-built_in">log</span>.start);<br>  <span class="hljs-comment">// 通过bread，获得logheader的缓存块</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">logheader</span> *<span class="hljs-title">hb</span> =</span> (<span class="hljs-keyword">struct</span> logheader *) (buf-&gt;data);<br>  <span class="hljs-type">int</span> i;<br>  <span class="hljs-comment">// 更新磁盘上logheader的n</span><br>  hb-&gt;n = <span class="hljs-built_in">log</span>.lh.n;<br>  <span class="hljs-comment">// 更新每个log block对应的data block的块号</span><br>  <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">log</span>.lh.n; i++) &#123;<br>    hb-&gt;block[i] = <span class="hljs-built_in">log</span>.lh.block[i];<br>  &#125;<br>  <span class="hljs-comment">// 将更新后的logheader写回磁盘上</span><br>  bwrite(buf);<br>  <span class="hljs-comment">// 从这里开始，事务提交真正完成，因此这里开始发生的crash可以恢复</span><br>  brelse(buf);<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li>该函数将 logheader 写入磁盘中, 如果这一步成功完成, 表示事务被正式提交, 对应数据日志四阶段中的日志提交.</li>
</ul>
</li>
<li>install_trans 实现如下: <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Copy committed blocks from log to their home location</span><br><span class="hljs-comment">// reads each block from the log and writes it to the proper place in the file system</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span><br><span class="hljs-title function_">install_trans</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>  <span class="hljs-type">int</span> tail;<br><br>  <span class="hljs-keyword">for</span> (tail = <span class="hljs-number">0</span>; tail &lt; <span class="hljs-built_in">log</span>.lh.n; tail++) &#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">buf</span> *<span class="hljs-title">lbuf</span> =</span> bread(<span class="hljs-built_in">log</span>.dev, <span class="hljs-built_in">log</span>.start+tail+<span class="hljs-number">1</span>); <span class="hljs-comment">// read log block</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">buf</span> *<span class="hljs-title">dbuf</span> =</span> bread(<span class="hljs-built_in">log</span>.dev, <span class="hljs-built_in">log</span>.lh.block[tail]); <span class="hljs-comment">// read dst</span><br>    <span class="hljs-comment">// 和write_log不同之处在于，写入磁盘时的目的地不同</span><br>    <span class="hljs-comment">// write_log写入的是磁盘上的日志区域logged blocks，</span><br>    <span class="hljs-comment">// install_trans写入的是logged block最终应该被写入的data blocks的位置</span><br>    memmove(dbuf-&gt;data, lbuf-&gt;data, BSIZE);  <span class="hljs-comment">// copy block to dst</span><br>    bwrite(dbuf);  <span class="hljs-comment">// write dst to disk</span><br>    <span class="hljs-comment">// 在log_write中bpin了相应的缓存块，这里bunpin它</span><br>    <span class="hljs-comment">// 因此在这之后，这一缓存块可以被Buffer Cache回收</span><br>    bunpin(dbuf);<br>    brelse(lbuf);<br>    brelse(dbuf);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li>该函数根据 logheader 的指示, 将每个 logged blocks 写到目的磁盘位置上, 然后调用 bunpin 它, 这样 Buffer Cache 就可以回收它了, 这一步对应数据日志四阶段中的加检查点.</li>
<li>一旦这一步完成, 本次事务就成功更新到磁盘上, 可以准备释放日志块.</li>
</ul>
</li>
<li>清除日志, 将 logheader 的计数 n 重置为 0, 并且写入磁盘中完成更新, 对应数据日志四阶段中的释放, 因为 n 被标记为 0, 所以日志区域中的块可以被重用. <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span><br><span class="hljs-title function_">commit</span><span class="hljs-params">()</span><br>&#123;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">log</span>.lh.n &gt; <span class="hljs-number">0</span>) &#123;<br>	...<br>    install_trans(); <span class="hljs-comment">// Now install writes to home locations</span><br>                     <span class="hljs-comment">// 加检查点</span><br>    <span class="hljs-built_in">log</span>.lh.n = <span class="hljs-number">0</span>;    <span class="hljs-comment">// this has to happen before the next transaction starts writing logged blocks, </span><br>                     <span class="hljs-comment">// so that a crash doesn’t result in recovery using one transaction’s header with the subsequent transaction’s logged blocks.</span><br>                     <span class="hljs-comment">// 到这里重新设n=0时，加检查点已经顺利完成了，但n=0还没有写到磁盘的logheader上</span><br>    write_head();    <span class="hljs-comment">// Erase the transaction from the log</span><br>                     <span class="hljs-comment">// 将更新后的n=0写入到磁盘的logheader上，因此旧的日志将被释放/重用</span><br>                     <span class="hljs-comment">// 对logheader更新必须在下一次事务写入log之前发生，</span><br>                     <span class="hljs-comment">// 否则恢复的时候会用下一个事务的log来进行恢复</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ul>
<p><strong>当 Crash 发生时, 文件系统如何恢复?</strong></p>
<p>在系统的启动阶段, 第一个用户进程 init 会调用 fsinit 初始化文件系统, 在 fsinit 函数中, 调用了 initlog 来初始化日志系统:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// A fork child&#x27;s very first scheduling by scheduler()</span><br><span class="hljs-comment">// will swtch to forkret.</span><br><span class="hljs-type">void</span><br><span class="hljs-title function_">forkret</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>  <span class="hljs-type">static</span> <span class="hljs-type">int</span> first = <span class="hljs-number">1</span>;<br><br>  <span class="hljs-comment">// Still holding p-&gt;lock from scheduler.</span><br>  release(&amp;myproc()-&gt;lock);<br><br>  <span class="hljs-keyword">if</span> (first) &#123;<br>    <span class="hljs-comment">// File system initialization must be run in the context of a</span><br>    <span class="hljs-comment">// regular process (e.g., because it calls sleep), and thus cannot</span><br>    <span class="hljs-comment">// be run from main().</span><br>    first = <span class="hljs-number">0</span>;<br>    fsinit(ROOTDEV);<br>  &#125;<br><br>  usertrapret();<br>&#125;<br><br><span class="hljs-comment">// Init fs</span><br><span class="hljs-type">void</span><br><span class="hljs-title function_">fsinit</span><span class="hljs-params">(<span class="hljs-type">int</span> dev)</span> &#123;<br>  readsb(dev, &amp;sb);<br>  <span class="hljs-keyword">if</span>(sb.magic != FSMAGIC)<br>    panic(<span class="hljs-string">&quot;invalid file system&quot;</span>);<br>  initlog(dev, &amp;sb);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>initlog 的实现如下所示:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span><br><span class="hljs-title function_">initlog</span><span class="hljs-params">(<span class="hljs-type">int</span> dev, <span class="hljs-keyword">struct</span> superblock *sb)</span><br>&#123;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> logheader) &gt;= BSIZE)<br>    panic(<span class="hljs-string">&quot;initlog: too big logheader&quot;</span>);<br><br>  initlock(&amp;<span class="hljs-built_in">log</span>.lock, <span class="hljs-string">&quot;log&quot;</span>);<br>  <span class="hljs-built_in">log</span>.start = sb-&gt;logstart;<br>  <span class="hljs-built_in">log</span>.size = sb-&gt;nlog;<br>  <span class="hljs-built_in">log</span>.dev = dev;<br>  recover_from_log();<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li>该函数从超级块上读取关于日志系统的信息, 包括日志区域的起始位置、日志区域的大小等. 然后它就调用 recover_from_log 开始恢复.</li>
</ul>
<p>recover_from_log 函数的实现如下:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span><br><span class="hljs-title function_">recover_from_log</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>  read_head();  <span class="hljs-comment">// 读出logheader</span><br>  <span class="hljs-comment">// log.lh.n表示需要写入磁盘的log blocks的数量</span><br>  <span class="hljs-comment">// 如果不需要恢复，为0，自动跳出install_trans的循环</span><br>  <span class="hljs-comment">// 如果&gt;0，install_trans会重新将logged blocks写入到磁盘的相应位置</span><br>  install_trans(); <span class="hljs-comment">// if committed, copy from log to disk</span><br>  <span class="hljs-comment">// 清除旧日志</span><br>  <span class="hljs-built_in">log</span>.lh.n = <span class="hljs-number">0</span>;<br>  write_head(); <span class="hljs-comment">// clear the log</span><br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li>该函数从磁盘中读取 logheader, 如果 n = 0, 表示日志系统不需要进行恢复, 因此跳过 recovery 继续启动; 如果 n 不为 0, 表示有需要重放的日志, 因此回到数据日志四阶段中的加检查点, 即再次调用 install_trans 重新执行加检查点过程, 最后在函数退出前清除旧日志.</li>
</ul>
<h4 id="块分配器">块分配器</h4>
<p>文件和目录都保存在磁盘块上, 这意味着我们需要某种与内存分配器 kalloc 相似的机制来分配和管理这些磁盘块.</p>
<p>Xv6 的磁盘块分配器在磁盘上维护一个位图, 该位图的每一位都表示一个块是否被分配, 其中 1 表示已分配, 而 0 表示空闲. 负责挂在文件系统的程序 mkfs 会设置好这些位.</p>
<p>磁盘块分配器主要有两个接口:</p>
<ul>
<li><strong>balloc 实现如下</strong>:  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> BSIZE 1024  <span class="hljs-comment">// block size</span></span><br><br><span class="hljs-comment">// Bitmap bits per block</span><br><span class="hljs-comment">// 计算每个BLOCK可以包含多少个bitmap位</span><br><span class="hljs-comment">// BLOCK SIZE = 1024，所以一个BLOCK可以包含8192个bit</span><br><span class="hljs-comment">// 即BPB = 8192</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> BPB           (BSIZE*8)</span><br><br><span class="hljs-comment">// Block of free map containing bit for block b</span><br><span class="hljs-comment">// 给定block number b，b/BPB表示该块的bitmap位应该在哪个bitmap block上</span><br><span class="hljs-comment">// 再加上bitmap区域的起始位置，得到最终的bitmap block number</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> BBLOCK(b, sb) ((b)/BPB + sb.bmapstart)</span><br><br><span class="hljs-comment">// Allocate a zeroed disk block.</span><br><span class="hljs-type">static</span> uint<br><span class="hljs-title function_">balloc</span><span class="hljs-params">(uint dev)</span><br>&#123;<br>  <span class="hljs-type">int</span> b, bi, m;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">buf</span> *<span class="hljs-title">bp</span>;</span><br><br>  bp = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span>(b = <span class="hljs-number">0</span>; b &lt; sb.size; b += BPB)&#123;<br>    <span class="hljs-comment">// 外层循环选中一个bitmap block</span><br>    <span class="hljs-comment">// 在bread中就隐含了同步机制，所以这里不需要再额外添加一把锁</span><br>    <span class="hljs-comment">// 给定block number b，返回所在的bitmap block number</span><br>    <span class="hljs-comment">// 然后读出相应的bitmap block到缓存</span><br>    bp = bread(dev, BBLOCK(b, sb));<br>    <span class="hljs-keyword">for</span>(bi = <span class="hljs-number">0</span>; bi &lt; BPB &amp;&amp; b + bi &lt; sb.size; bi++)&#123;<br>      <span class="hljs-comment">// 内层循环一个个检查bitmap block里面的位</span><br>      <span class="hljs-comment">// bi表示8192个位的哪一个</span><br>      m = <span class="hljs-number">1</span> &lt;&lt; (bi % <span class="hljs-number">8</span>);<br>      <span class="hljs-comment">// m表示在一个字节内部8位的哪一个位上</span><br>      <span class="hljs-keyword">if</span>((bp-&gt;data[bi/<span class="hljs-number">8</span>] &amp; m) == <span class="hljs-number">0</span>)&#123;  <span class="hljs-comment">// Is block free?</span><br>        <span class="hljs-comment">// bi/8表示在1024个位置里面的第几个位置</span><br>        <span class="hljs-comment">// 如果空闲，将对应的磁盘块设为已分配</span><br>        bp-&gt;data[bi/<span class="hljs-number">8</span>] |= m;  <span class="hljs-comment">// Mark block in use.</span><br>        log_write(bp);<br>        brelse(bp);<br>        bzero(dev, b + bi);  <span class="hljs-comment">// 清0新分配的磁盘块，防止旧内容或垃圾数据被使用</span><br>	<span class="hljs-comment">// balloc修改的是bitmap block的内容</span><br>	<span class="hljs-comment">// 返回的是新分配磁盘块的块号</span><br>        <span class="hljs-keyword">return</span> b + bi;<br>      &#125;<br>    &#125;<br>    brelse(bp);<br>  &#125;<br>  panic(<span class="hljs-string">&quot;balloc: out of blocks&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li>该函数会分配一块新的磁盘块, 它会扫描所有的块, 找到一个空闲的磁盘块 (在位图上标记为 0), 然后更新位图并返回该磁盘块.</li>
<li>该函数有两层循环, 外循环遍历每个位图块, 内循环对于给定位图块, 遍历其所有的位, 直到找到一个标记为 0 的位 (对应一个空闲的磁盘块).</li>
</ul>
</li>
<li><strong>bfree 的实现如下</strong>:  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Free a disk block.</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span><br><span class="hljs-title function_">bfree</span><span class="hljs-params">(<span class="hljs-type">int</span> dev, uint b)</span><br>&#123;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">buf</span> *<span class="hljs-title">bp</span>;</span><br>  <span class="hljs-type">int</span> bi, m;<br><br>  <span class="hljs-comment">// 同样地，这里也隐含了同步机制</span><br>  <span class="hljs-comment">// 给定block number b，返回所在的bitmap block number</span><br>  bp = bread(dev, BBLOCK(b, sb));<br>  <span class="hljs-comment">// 确定是bitmap里面的第几位</span><br>  <span class="hljs-comment">// 以下类似balloc</span><br>  <span class="hljs-comment">// 在bitmap中找到该块的对应位置，置0</span><br>  bi = b % BPB;<br>  m = <span class="hljs-number">1</span> &lt;&lt; (bi % <span class="hljs-number">8</span>);<br>  <span class="hljs-keyword">if</span>((bp-&gt;data[bi/<span class="hljs-number">8</span>] &amp; m) == <span class="hljs-number">0</span>)<br>    panic(<span class="hljs-string">&quot;freeing free block&quot;</span>);<br>  bp-&gt;data[bi/<span class="hljs-number">8</span>] &amp;= ~m;<br>  log_write(bp);<br>  brelse(bp);<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li>该函数会释放指定磁盘块, 即找到位图块中相应的位, 将其重新标记为 0.</li>
</ul>
</li>
</ul>
<h3 id="Inode-层">Inode 层</h3>
<p>在 Xv6 中, Inode 有两个含义: 一个是指磁盘上的数据结构, 另一个是指内存中的数据结构. 磁盘上的 Inode 包含了文件大小、数据块的位置等基本信息; 而内存中的 Inode 则是前者的一份副本, 还包含;了内核所需的额外信息.</p>
<p>磁盘上的 Inode 是磁盘上一块连续的区域, 这些块被称为 Inode Block, 每个 Inode 的大小是固定的.</p>
<p><strong>struct dinode 是磁盘上的 Inode 的数据结构定义</strong>, 如下所示:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// On-disk inode structure</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dinode</span> &#123;</span><br>  <span class="hljs-type">short</span> type;           <span class="hljs-comment">// File type, files, directories, or special files (devices)</span><br>                        <span class="hljs-comment">// 0 indicates dinode is free</span><br>  <span class="hljs-type">short</span> major;          <span class="hljs-comment">// Major device number (T_DEVICE only)</span><br>  <span class="hljs-type">short</span> minor;          <span class="hljs-comment">// Minor device number (T_DEVICE only)</span><br>  <span class="hljs-type">short</span> nlink;          <span class="hljs-comment">// Number of links to inode in file system</span><br>                        <span class="hljs-comment">// won’t free an inode if its link count is greater than 0</span><br>                        <span class="hljs-comment">// 统计指向这个inode的目录条目（硬链接数）</span><br>                        <span class="hljs-comment">// 用于指示何时磁盘上的inode和它对应的data blocks应该被释放</span><br>  uint size;            <span class="hljs-comment">// Size of file (bytes)</span><br>                        <span class="hljs-comment">// the number of bytes of content in the file</span><br>  uint addrs[NDIRECT+<span class="hljs-number">1</span>];   <span class="hljs-comment">// Data block addresses</span><br>                           <span class="hljs-comment">// records the block numbers of the disk blocks holding the file’s content.</span><br>  			               <span class="hljs-comment">// NDIRECT = 12, 12个直接块，第13个是一级间接块</span><br>                           <span class="hljs-comment">// 默认大小为(12+256)*BISZE = 268KB</span><br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li>type 指示该 Inode 的类型, 是文件、目录、设备还是未被使用.</li>
<li>nlink 表示有多少个目录项包含该 Inode. 对于文件来说, nlink 既是链接计数, 也是硬链接数; 对于目录来说, nlink 只是链接计数. nlink 用来指示这个 Inode 及其对应的数据块什么时候被释放.</li>
<li>size 表示文件大小 (以字节为单位).</li>
<li>addrs 指向 Inode 的数据块所在的位置 (磁盘块的块号).</li>
</ul>
<p><strong>struct inode 是内核在内存中维护的 Inode 的数据结构的定义</strong>, 如下所示:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// in-memory copy of an inode(struct dinode)</span><br><span class="hljs-comment">// kernel stores an inode in memory only if there are C pointers referring to that inode</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">inode</span> &#123;</span><br>  uint dev;           <span class="hljs-comment">// Device number</span><br>  uint inum;          <span class="hljs-comment">// Inode number</span><br>  <span class="hljs-type">int</span> ref;            <span class="hljs-comment">// Reference count</span><br>                      <span class="hljs-comment">// 在内存中指向该inode的指针数，注意区分和dinode的nlink</span><br>                      <span class="hljs-comment">// ref大于0，就会继续在icache中保存该inode，而且该缓存条目不会被置换成别的inode</span><br>                      <span class="hljs-comment">// ref为0时，内核就清除该inode在icache中的副本</span><br>                      <span class="hljs-comment">// nlink是硬链接，断电之后还会保存在磁盘里面</span><br>                      <span class="hljs-comment">// 而ref是内存里面的数据结构，断电之后就会消失</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sleeplock</span> <span class="hljs-title">lock</span>;</span> <span class="hljs-comment">// protects everything below here</span><br>                         <span class="hljs-comment">// ensures exclusive access to the inode’s fields as well as to the inode’s file or directory content blocks.</span><br>  <span class="hljs-type">int</span> valid;          <span class="hljs-comment">// inode has been read from disk?</span><br><br>  <span class="hljs-comment">//以下为struct dinode的成员</span><br>  <span class="hljs-type">short</span> type;         <span class="hljs-comment">// copy of disk inode</span><br>  <span class="hljs-type">short</span> major;<br>  <span class="hljs-type">short</span> minor;<br>  <span class="hljs-type">short</span> nlink;<br>  uint size;<br>  uint addrs[NDIRECT+<span class="hljs-number">1</span>];<br>&#125;;<br></code></pre></td></tr></table></figure>
<ul>
<li>该结构是在被使用的 On-disk Inode 的一份副本, 仅当存在指针指向内存中的某一 Inode 时, 内核才会保持该 Inode 的内存副本.</li>
<li>ref 指示有多少 C 指针指向该 Inode 的内存副本. 如果 ref 为 0, 则内核就会舍弃该 Inode 的内存副本.
<ul>
<li>ref 和 ninode 中的 nlink 的作用不同: ref 是内存指针计数, 只要 ref 大于 0, 内核就会将该 Inode 的副本保存在 icache 中; 而 nlink 是链接计数, 只要 nlink 大于 0, 文件系统就不会从磁盘中释放该 Inode 及其数据块.</li>
</ul>
</li>
<li>每个 Inode 拥有一把睡眠锁, 可以同步对这些 Inode 和它们的数据块的并发访问.</li>
</ul>
<p>和 Buffer Cache 类似, Inode 层也有一个<strong>Inode Cache</strong>, 其定义如下所示:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">spinlock</span> <span class="hljs-title">lock</span>;</span><br>  <span class="hljs-comment">// 这把自旋锁用于保护icache缓存区</span><br>  <span class="hljs-comment">// 每个inode的睡眠锁用于保护每个inode的信息</span><br>  <span class="hljs-comment">// 和bcache情况类似</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">inode</span> <span class="hljs-title">inode</span>[<span class="hljs-title">NINODE</span>];</span>  <span class="hljs-comment">// 最多50个inode同时被缓存</span><br>&#125; icache;<br></code></pre></td></tr></table></figure>
<ul>
<li>该缓存维护一个自旋锁来保证:
<ul>
<li>每个 Inode 在缓存中至多有一个副本.</li>
<li>每个 Inode 的缓存副本中, ref 代表了当前指向该 Inode 副本的指针数.</li>
</ul>
</li>
</ul>
<p>通过调用 iget 可以得到指向某一 struct inode 的指针, 该指针会一直有效, 直到对该 inode 调用 iput. 只要存在指向该 struct inode 的指针, 该 inode 的内存副本就不会被删除, 而且 icache 也不会释放该副本. iget 虽然需要持有 icache.lock 来同步并发的访问, 但是对于每个 inode, 并没有获取该 inode 的睡眠锁, 这意味着如果有多个 iget 调用, 且因此返回了多个指向同一个 inode 的指针, 可以不受限制地并发访问该 inode (多个进程可以同时拥有指向同一个 Inode 的指针, 但是只有持有该 Inode 的锁, 才能访问该 Inode 的数据).</p>
<p><strong>icache 的设计主要是为了同步多个进程对 inode 的访问</strong>, 而利用缓存的高速性只是次要目的, 因为如果一个 inode 经常被使用, 即使它不在 icache 中, Buffer Cache 也可能会缓存它.</p>
<p><strong>ialloc 的实现如下</strong>:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Inodes per block.</span><br><span class="hljs-comment">// 计算每个BLOCK有多少个inode</span><br><span class="hljs-comment">// IPB = 16</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IPB           (BSIZE / sizeof(struct dinode))</span><br><br><span class="hljs-comment">// Block containing inode i</span><br><span class="hljs-comment">// 计算给定的inode i在第几个block上</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IBLOCK(i, sb)     ((i) / IPB + sb.inodestart)</span><br><br><span class="hljs-comment">// Allocate an inode on device dev.</span><br><span class="hljs-comment">// Mark it as allocated by giving it type type.</span><br><span class="hljs-comment">// Returns an unlocked but allocated and referenced inode.</span><br><span class="hljs-keyword">struct</span> inode*<br><span class="hljs-title function_">ialloc</span><span class="hljs-params">(uint dev, <span class="hljs-type">short</span> type)</span><br>&#123;<br>  <span class="hljs-comment">// 注意和iget的区别</span><br>  <span class="hljs-comment">// ialloc每次调用时，都会找到一个磁盘上空闲的inode块(数据结构是dinode)</span><br>  <span class="hljs-comment">// 然后将其标记为已分配，分配完之后就会马上调用iget并将其缓存在icache中</span><br>  <span class="hljs-comment">// iget则是给定inode number，先看对应的inode是否已经被缓存了</span><br>  <span class="hljs-comment">// 如果没有，就分配缓存区中第一个空位来缓存该inode</span><br>  <br>  <span class="hljs-type">int</span> inum;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">buf</span> *<span class="hljs-title">bp</span>;</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dinode</span> *<span class="hljs-title">dip</span>;</span><br><br>  <span class="hljs-keyword">for</span>(inum = <span class="hljs-number">1</span>; inum &lt; sb.ninodes; inum++)&#123;<br>    <span class="hljs-comment">// 同样地，在bread的bget中隐含同步机制</span><br>    bp = bread(dev, IBLOCK(inum, sb));<br>    <span class="hljs-comment">// 给定inode的inode number，得到该inode在哪一个block上</span><br>    <span class="hljs-comment">// 读取对应的block上的data，这个block包含了多个inode，数量为IPB</span><br>    <span class="hljs-comment">// inum%IPB是block内的偏移量，加上偏移量之后则即读取block上第inum个inode</span><br>    <span class="hljs-comment">// 注意读取的bp是磁盘上的inode，所以数据结构类型为dinode</span><br>    dip = (<span class="hljs-keyword">struct</span> dinode*)bp-&gt;data + inum%IPB;<br>    <span class="hljs-comment">// 最终dip指向的是bp-&gt;data的某一部分，即相应的dinode</span><br>    <span class="hljs-comment">// 因此修改dip就是修改对应的dionde</span><br>    <span class="hljs-keyword">if</span>(dip-&gt;type == <span class="hljs-number">0</span>)&#123;  <span class="hljs-comment">// a free inode</span><br>      <span class="hljs-built_in">memset</span>(dip, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(*dip));<br>      dip-&gt;type = type;<br>      <span class="hljs-comment">// 缓存块bp被修改，写进log</span><br>      log_write(bp);   <span class="hljs-comment">// mark it allocated on the disk</span><br>      brelse(bp);<br>     <span class="hljs-comment">// 调用iget将inode缓存在icache中</span><br>      <span class="hljs-keyword">return</span> iget(dev, inum);<br>    &#125;<br>    brelse(bp);<br>  &#125;<br>  panic(<span class="hljs-string">&quot;ialloc: no inodes&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li>该函数用于创建一个新的 inode. 该函数和 balloc 类似, 在循环中遍历所有磁盘上的 inode, 找到处于空闲的一个, 然后更新该 inode 的 type 字段, 并在结尾时调用 iget 以将该 inode 缓存在 icache 中, 最终将返回一个指向该 inode 的缓存副本的指针.</li>
<li>该函数在并发情况下仍然能正常工作, 得益于下层 Buffer Cache 提供的同步机制.</li>
</ul>
<p><strong>iget 函数的实现如下</strong>:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Find the inode with number inum on device dev</span><br><span class="hljs-comment">// and return the in-memory copy. Does not lock</span><br><span class="hljs-comment">// the inode and does not read it from disk.</span><br><span class="hljs-comment">// iget() provides non-exclusive access to an inode, so that there can be many pointers to the same inode</span><br><span class="hljs-comment">// iget()不能对inode上锁的原因见dirlookup()</span><br><span class="hljs-type">static</span> <span class="hljs-keyword">struct</span> inode*<br><span class="hljs-title function_">iget</span><span class="hljs-params">(uint dev, uint inum)</span><br>&#123;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">inode</span> *<span class="hljs-title">ip</span>, *<span class="hljs-title">empty</span>;</span><br><br>  acquire(&amp;icache.lock);<br><br>  <span class="hljs-comment">// Is the inode already cached?</span><br>  empty = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span>(ip = &amp;icache.inode[<span class="hljs-number">0</span>]; ip &lt; &amp;icache.inode[NINODE]; ip++)&#123;<br>    <span class="hljs-comment">// 先在icache缓存中查找，看是否已经被缓存</span><br>    <span class="hljs-keyword">if</span>(ip-&gt;ref &gt; <span class="hljs-number">0</span> &amp;&amp; ip-&gt;dev == dev &amp;&amp; ip-&gt;inum == inum)&#123;<br>      ip-&gt;ref++;<br>      release(&amp;icache.lock);<br>      <span class="hljs-comment">// 返回一个新的inode指针，指向icache中的inode</span><br>      <span class="hljs-keyword">return</span> ip;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(empty == <span class="hljs-number">0</span> &amp;&amp; ip-&gt;ref == <span class="hljs-number">0</span>)    <span class="hljs-comment">// Remember empty slot.</span><br>      <span class="hljs-comment">// 找到icache中第一个为空的槽位</span><br>      empty = ip;<br>  &#125;<br><br>  <span class="hljs-comment">// Recycle an inode cache entry.</span><br>  <span class="hljs-keyword">if</span>(empty == <span class="hljs-number">0</span>)<br>    panic(<span class="hljs-string">&quot;iget: no inodes&quot;</span>);<br>  <span class="hljs-comment">// 遍历了当前所有icache中的inode，但是缓存没有命中</span><br>  <span class="hljs-comment">// empty是icache中第一个为空的槽位</span><br>  <span class="hljs-comment">// 初始化之后，返回指向该inode的指针</span><br>  ip = empty;<br>  ip-&gt;dev = dev;<br>  ip-&gt;inum = inum;<br>  ip-&gt;ref = <span class="hljs-number">1</span>;<br>  ip-&gt;valid = <span class="hljs-number">0</span>;<br>  release(&amp;icache.lock);<br><br>  <span class="hljs-keyword">return</span> ip;<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li>给定设备号和 inode 号, iget 可以查找 icache 中是否有相应 inode 的缓存副本. 如果有, 则直接返回一个新的 inode 指针; 如果没有, 那么就使用 icache 中第一个空的槽位, 或者回收一个 ref 为 0 的 inode, 从而将空间分配给新的 inode 缓存副本.</li>
<li><strong>当将某一个槽位分配给一个新的 inode 时, iget 只是简单地标记该槽位给新的 inode, 但是这个 inode 的缓存副本中还没有有效的内容, 需要在之后调用 ilock 时, 才能从磁盘中读取该 inode 的数据</strong>.</li>
</ul>
<p><strong>ilock 函数的实现如下</strong>:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Lock the given inode.</span><br><span class="hljs-comment">// Reads the inode from disk if necessary.</span><br><span class="hljs-comment">// The struct inode that iget returns may not have any useful content. </span><br><span class="hljs-comment">// In order to ensure it holds a copy of the on-disk inode, code must call ilock. </span><br><span class="hljs-comment">// This locks the inode (so that no other process can ilock it) and reads the inode from the disk, if it has not already been read.</span><br><span class="hljs-comment">// Multiple processes can hold a C pointer to an inode returned by iget, but only one process can lock the inode at a time.</span><br><span class="hljs-comment">// 在读取或修改inode的元数据和数据内容之前，首先应该调用ilock对inode上锁</span><br><span class="hljs-type">void</span><br><span class="hljs-title function_">ilock</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> inode *ip)</span><br>&#123;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">buf</span> *<span class="hljs-title">bp</span>;</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dinode</span> *<span class="hljs-title">dip</span>;</span><br><br>  <span class="hljs-keyword">if</span>(ip == <span class="hljs-number">0</span> || ip-&gt;ref &lt; <span class="hljs-number">1</span>)<br>    panic(<span class="hljs-string">&quot;ilock&quot;</span>);<br><br>  acquiresleep(&amp;ip-&gt;lock);<br><br>  <span class="hljs-comment">// 刚从iget得到的inode指针，其valid=0</span><br>  <span class="hljs-keyword">if</span>(ip-&gt;valid == <span class="hljs-number">0</span>)&#123;<br>    bp = bread(ip-&gt;dev, IBLOCK(ip-&gt;inum, sb));<br>    dip = (<span class="hljs-keyword">struct</span> dinode*)bp-&gt;data + ip-&gt;inum%IPB;<br>    ip-&gt;type = dip-&gt;type;<br>    ip-&gt;major = dip-&gt;major;<br>    ip-&gt;minor = dip-&gt;minor;<br>    ip-&gt;nlink = dip-&gt;nlink;<br>    ip-&gt;size = dip-&gt;size;<br>    memmove(ip-&gt;addrs, dip-&gt;addrs, <span class="hljs-keyword">sizeof</span>(ip-&gt;addrs));<br>    brelse(bp);<br>    ip-&gt;valid = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span>(ip-&gt;type == <span class="hljs-number">0</span>)<br>      panic(<span class="hljs-string">&quot;ilock: no type&quot;</span>);<br>  &#125;<br><br>  <span class="hljs-comment">// 这时还没有释放ip-&gt;lock,需要调用iunlock以释放</span><br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li>通过 iget 我们只能得到指向 inode 缓存副本的指针, 如果要使用该指针读取或修改 inode 副本的内容, 就必须要调用 ilock 函数.</li>
<li>该函数用于获取相应 inode 的睡眠锁, 从而同步所有线程对 inode 的并发访问. 如果该 inode 是刚刚被 ialloc 发配, 那么 valid 为 0, 表示需要从磁盘中读取 inode 的内容到缓存副本中.</li>
</ul>
<p><strong>iunlock 函数的实现如下</strong>:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Unlock the given inode.</span><br><span class="hljs-type">void</span><br><span class="hljs-title function_">iunlock</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> inode *ip)</span><br>&#123;<br>  <span class="hljs-keyword">if</span>(ip == <span class="hljs-number">0</span> || !holdingsleep(&amp;ip-&gt;lock) || ip-&gt;ref &lt; <span class="hljs-number">1</span>)<br>    panic(<span class="hljs-string">&quot;iunlock&quot;</span>);<br><br>  releasesleep(&amp;ip-&gt;lock);<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li>该函数和 ilock 对应, 用于释放 inode 的睡眠锁.</li>
</ul>
<p><strong>iput 函数的实现如下</strong>:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Drop a reference to an in-memory inode.</span><br><span class="hljs-comment">// If that was the last reference, the inode cache entry can</span><br><span class="hljs-comment">// be recycled.</span><br><span class="hljs-comment">// If that was the last reference and the inode has no links</span><br><span class="hljs-comment">// to it, free the inode (and its content) on disk.</span><br><span class="hljs-comment">// All calls to iput() must be inside a transaction in</span><br><span class="hljs-comment">// case it has to free the inode.</span><br><span class="hljs-comment">// release pointers to an inode, modifying the reference count</span><br><span class="hljs-comment">// xv6 won’t free an inode if its link count is greater than zero</span><br><span class="hljs-type">void</span><br><span class="hljs-title function_">iput</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> inode *ip)</span><br>&#123;<br>  acquire(&amp;icache.lock);<br><br>  <span class="hljs-comment">// 只有当ref=0且nlink=0，即既没有指针引用该inode，也没有目录条目引用该inode</span><br>  <span class="hljs-comment">// 释放在disk上的inode</span><br>  <span class="hljs-keyword">if</span>(ip-&gt;ref == <span class="hljs-number">1</span> &amp;&amp; ip-&gt;valid &amp;&amp; ip-&gt;nlink == <span class="hljs-number">0</span>)&#123;<br>    <span class="hljs-comment">// inode has no links and no other references: </span><br>    <span class="hljs-comment">// then the inode and its data blocks must be freed</span><br>    <span class="hljs-comment">// truncate and free.</span><br><br>    <span class="hljs-comment">// ip-&gt;ref == 1 means no other process can have ip locked,</span><br>    <span class="hljs-comment">// so this acquiresleep() won&#x27;t block (or deadlock).</span><br>    acquiresleep(&amp;ip-&gt;lock);<br><br>    release(&amp;icache.lock);<br><br>    itrunc(ip);<br>    ip-&gt;type = <span class="hljs-number">0</span>;<br>    iupdate(ip);<br>    ip-&gt;valid = <span class="hljs-number">0</span>;<br><br>    releasesleep(&amp;ip-&gt;lock);<br><br>    acquire(&amp;icache.lock);<br>  &#125;<br><br>  ip-&gt;ref--;<br>  <span class="hljs-comment">// 如果是最后一个指针，ref--后变为0，这时iget就能发现它，用它的位置给新的inode缓存</span><br>  <span class="hljs-comment">// 但是在硬盘上，目录的硬链接仍然存在，因为nlink!=0</span><br>  <span class="hljs-comment">// ref=0本质上只是icache不再缓存该inode，并不是释放了磁盘上的inode</span><br>  <span class="hljs-comment">// 之后还可以再次调用iget缓存该inode</span><br>  release(&amp;icache.lock);<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li>该函数和 iget 对应, 接收一个 inode 指针输入, 并将其 ref 计数减一. 如果该指针是最后一个对该 inode 的引用, 且该 inode 的链接计数 nlink 为 0, 那么就释放磁盘上对应的 inode 和相应的数据块. iput 通过调用 itrunc 来释放 inode, 然后标记 type 为空闲, 最后调用 ipudate 将新的 inode 元数据写回磁盘上.</li>
</ul>
<p><strong>iupdate 的实现如下</strong>:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Copy a modified in-memory inode to disk.</span><br><span class="hljs-comment">// Must be called after every change to an ip-&gt;xxx field</span><br><span class="hljs-comment">// that lives on disk, since i-node cache is write-through.</span><br><span class="hljs-comment">// Caller must hold ip-&gt;lock.</span><br><span class="hljs-comment">// The inode cache is write-through, which means that code that modifies a cached inode must immediately write it to disk with iupdate.</span><br><span class="hljs-type">void</span><br><span class="hljs-title function_">iupdate</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> inode *ip)</span><br>&#123;<br>  <span class="hljs-comment">// 每次更改icache中inode副本，都需要调用iupdate写入到磁盘</span><br><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">buf</span> *<span class="hljs-title">bp</span>;</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dinode</span> *<span class="hljs-title">dip</span>;</span><br><br>  bp = bread(ip-&gt;dev, IBLOCK(ip-&gt;inum, sb));<br>  dip = (<span class="hljs-keyword">struct</span> dinode*)bp-&gt;data + ip-&gt;inum%IPB;<br><br>  <span class="hljs-comment">// ip是新的inode缓存副本，dip是旧的磁盘inode</span><br>  dip-&gt;type = ip-&gt;type;<br>  dip-&gt;major = ip-&gt;major;<br>  dip-&gt;minor = ip-&gt;minor;<br>  dip-&gt;nlink = ip-&gt;nlink;<br>  dip-&gt;size = ip-&gt;size;<br>  memmove(dip-&gt;addrs, ip-&gt;addrs, <span class="hljs-keyword">sizeof</span>(ip-&gt;addrs));<br>  <span class="hljs-comment">// 此次更新写入log</span><br>  log_write(bp);<br>  brelse(bp);<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li>该函数将更新后的 inode 缓存副本写回磁盘上,</li>
</ul>
<p>可见 iupdate 中含有写入磁盘的操作, 由于 iput 中调用了 iupdate, 因此可以说 iput 含有写入磁盘的操作. 而只要是使用了文件系统的系统调用, 都会在其结尾调用 iput, 因此最终都<strong>可能</strong>引发写入磁盘的操作, 即使是像 read 这样只读的系统调用.</p>
<p>另外, 该设计还存在一定的隐患: 当一个文件的硬链接数 nlink 为 0, iput 并不会马上就删除并释放该文件, 因为在内存中可能还存在其它指向该文件的 inode 指针, 甚至有进程仍然在读写这个文件. 如果在最后一个进程关闭该文件的文件描述符、释放最后一个 inode 指针之前, 操作系统崩溃或者断电, 下次启动操作系统时, 该文件并不会被删除, 但是由于没有任何目录项包含它, 也没有任何内存中的 inode 指针指向它, 因此我们无法访问它, 这会导致磁盘空间的流失.</p>
<p>对于该问题, 文件系统有两种处理方案:</p>
<ul>
<li>在操作系统启动的恢复阶段, 文件系统扫描整个磁盘, 检查是否有文件标记被分配, 但是没有任何目录项包含它, 如果有, 就释放这些文件所占用的空间.</li>
<li>在磁盘的某个位置上 (例如超级块中), 记录硬链接数为 0, 而指向其的指针数不为 0 的文件的 inode 号. 如果该文件最后被删除了, 那么就从该记录列表中移除相应的 inode 号. 在操作系统启动的恢复阶段, 就不需要扫描整个磁盘, 而是简单地扫描该列表, 删除其中的文件即可.</li>
</ul>
<p>由于 xv6 不提供以上两种处理方案的实现, 因此, 可能会导致磁盘空间的流失.</p>
<p>下面分析 inode 的数据内容:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dinode</span>&#123;</span><br>  <span class="hljs-comment">// ...</span><br>  uint addrs[NDIRECT+<span class="hljs-number">1</span>];  <span class="hljs-comment">// 默认NDIRECT = 12</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>该 dinode 的数组 addrs 可以形象地用下图表示:<br>
<img src="/img/Pictures/20231219145450.png" srcset="/img/loading.gif" lazyload alt=""><br>
其中前 12 个是直接块, 即 addr[0] ~ addr[11] 中保存的是数据块的块号. addr[12] 中保存的是一个间接块块号, 而一个间接块中存放的又是一系列数据块的块号. 由于 xv6 中一个块的大小为 1KB, 而一个块号用数据类型 uint 表示 (占用 4B), 因此一个间接块中可以存放 256 个数据块块号.</p>
<p>这种映射方式对于磁盘来说是节省空间的好方法, 但是对于用户来说可能会有一点复杂. 因此 inode 层提供了一个接口 bmap. <strong>给定 inode 指针, bmap 就为我们找到文件的第 bn 块对应的数据块块号</strong>. 这为很多更高层的接口如 readi 和 writei 都提供了便利. 如果该数据块还未被分配, bmap 还会调用 balloc 为我们分配它.</p>
<p>bmap 的实现如下:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Bmap returns the disk block number of the bn’th data block for the inode ip.</span><br><span class="hljs-type">static</span> uint<br><span class="hljs-title function_">bmap</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> inode *ip, uint bn)</span><br>&#123;<br>  <span class="hljs-comment">// 给定文件的第bn个data block </span><br>  <span class="hljs-comment">// 0 &lt;= bn &lt; NDIRECT + NINDIRECT</span><br>  <span class="hljs-comment">// 返回在磁盘上对应的data block number</span><br>  uint addr, *a;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">buf</span> *<span class="hljs-title">bp</span>;</span><br><br>  <span class="hljs-comment">// 先查找直接块</span><br>  <span class="hljs-keyword">if</span>(bn &lt; NDIRECT)&#123;<br>    <span class="hljs-keyword">if</span>((addr = ip-&gt;addrs[bn]) == <span class="hljs-number">0</span>)<br>      <span class="hljs-comment">// 该直接块还没有被分配，因此分配一个新数据块</span><br>      ip-&gt;addrs[bn] = addr = balloc(ip-&gt;dev);<br>    <span class="hljs-keyword">return</span> addr;<br>  &#125;<br>  bn -= NDIRECT;<br><br>  <span class="hljs-comment">// 如果bn不是直接块，就查找间接块</span><br>  <span class="hljs-keyword">if</span>(bn &lt; NINDIRECT)&#123;<br>    <span class="hljs-comment">// Load indirect block, allocating if necessary.</span><br>    <span class="hljs-keyword">if</span>((addr = ip-&gt;addrs[NDIRECT]) == <span class="hljs-number">0</span>)<br>      <span class="hljs-comment">// 一级间接映射块是空的，先分配一个一级间接块</span><br>      ip-&gt;addrs[NDIRECT] = addr = balloc(ip-&gt;dev);<br>    bp = bread(ip-&gt;dev, addr);<br>    <span class="hljs-comment">// 在这里将a变为uint*形的指针，这样a的每次偏移都会增加一个sizeof(uint)</span><br>    a = (uint*)bp-&gt;data;<br>    <span class="hljs-comment">// a是一级间接块的数据，包含了256个uint，每个uint都指向一个实际的数据块</span><br>    <span class="hljs-keyword">if</span>((addr = a[bn]) == <span class="hljs-number">0</span>)&#123;<br>      <span class="hljs-comment">// 分配一个新数据块</span><br>      a[bn] = addr = balloc(ip-&gt;dev);<br>      <span class="hljs-comment">// balloc只会将新的位图写入日志中，而一级间接块现在被更新</span><br>      <span class="hljs-comment">// 所以要另外调用log_write将更新写入日志 中</span><br>      log_write(bp);<br>    &#125;<br>    brelse(bp);<br>    <span class="hljs-keyword">return</span> addr;<br>  &#125;<br>  <br>  panic(<span class="hljs-string">&quot;bmap: out of range&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li>首先检查直接块, 如果 bn 不是对应直接块, 那么检查间接块. 如果读出的内容是 0 而不是块号, 代表块还没有被分配. 如果直接块不存在, 那么就分配新的数据块; 如果间接块不存在, 那么先分配一个块给间接块, 后面再分配一个块给间接块指向的数据块. 这种按需分配的方式, 可以很大程度上节省磁盘空间.</li>
<li>另外, 这里只将对间接块中数据的更新写入日志, 如果因为分配了新的数据块导致 inode 的 addrs 发生变化, 应该由上层调用通过调用 iupdate 写入日志.</li>
</ul>
<p>itrunc 用于释放一个给定 inode 的所有数据块, 并且将 inode 长度截断为 0. 该函数实现如下:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Truncate inode (discard contents).</span><br><span class="hljs-comment">// Caller must hold ip-&gt;lock.</span><br><span class="hljs-type">void</span><br><span class="hljs-title function_">itrunc</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> inode *ip)</span><br>&#123;<br>  <span class="hljs-type">int</span> i, j;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">buf</span> *<span class="hljs-title">bp</span>;</span><br>  uint *a;<br><br>  <span class="hljs-comment">// truncate the file to zero bytes, freeing the data blocks</span><br>  <span class="hljs-comment">// sets the inode type to 0</span><br>  <span class="hljs-comment">// and writes the inode to disk (bfree会调用log_write)</span><br>  <span class="hljs-comment">// 整体结构和bmap相似，只是多了bfree和条目清0的操作</span><br><br>  <span class="hljs-comment">// 释放所有直接块</span><br>  <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; NDIRECT; i++)&#123;<br>    <span class="hljs-keyword">if</span>(ip-&gt;addrs[i])&#123;<br>      bfree(ip-&gt;dev, ip-&gt;addrs[i]);<br>      ip-&gt;addrs[i] = <span class="hljs-number">0</span>;<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-comment">// 释放所有间接块</span><br>  <span class="hljs-keyword">if</span>(ip-&gt;addrs[NDIRECT])&#123;<br>    bp = bread(ip-&gt;dev, ip-&gt;addrs[NDIRECT]);<br>    a = (uint*)bp-&gt;data;<br>    <span class="hljs-keyword">for</span>(j = <span class="hljs-number">0</span>; j &lt; NINDIRECT; j++)&#123;<br>      <span class="hljs-keyword">if</span>(a[j])<br>        <span class="hljs-comment">// 释放所有间接数据块</span><br>        bfree(ip-&gt;dev, a[j]);<br>    &#125;<br>    brelse(bp);<br>    <span class="hljs-comment">// 释放间接块</span><br>    bfree(ip-&gt;dev, ip-&gt;addrs[NDIRECT]);<br>    ip-&gt;addrs[NDIRECT] = <span class="hljs-number">0</span>;<br>  &#125;<br><br>  ip-&gt;size = <span class="hljs-number">0</span>;<br>  <span class="hljs-comment">// 更改了inode，因此要更新到磁盘上</span><br>  iupdate(ip);<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>readi 用于从 inode 中读取文件数据</strong>, 该函数实现如下:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Read data from inode.</span><br><span class="hljs-comment">// Caller must hold ip-&gt;lock.</span><br><span class="hljs-comment">// If user_dst==1, then dst is a user virtual address;</span><br><span class="hljs-comment">// otherwise, dst is a kernel address.</span><br><span class="hljs-type">int</span><br><span class="hljs-title function_">readi</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> inode *ip, <span class="hljs-type">int</span> user_dst, uint64 dst, uint off, uint n)</span><br>&#123;<br>  uint tot, m;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">buf</span> *<span class="hljs-title">bp</span>;</span><br><br>  <span class="hljs-keyword">if</span>(off &gt; ip-&gt;size || off + n &lt; off)<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">if</span>(off + n &gt; ip-&gt;size)<br>    <span class="hljs-comment">// 读取是合法的，但是字节数不能超过文件大小</span><br>    n = ip-&gt;size - off;<br><br>  <span class="hljs-keyword">for</span>(tot=<span class="hljs-number">0</span>; tot&lt;n; tot+=m, off+=m, dst+=m)&#123;<br>    bp = bread(ip-&gt;dev, bmap(ip, off/BSIZE));<br>    m = min(n - tot, BSIZE - off%BSIZE);<br>    <span class="hljs-keyword">if</span>(either_copyout(user_dst, dst, bp-&gt;data + (off % BSIZE), m) == <span class="hljs-number">-1</span>) &#123;<br>      brelse(bp);<br>      <span class="hljs-keyword">break</span>;<br>    &#125;<br>    brelse(bp);<br>  &#125;<br>  <span class="hljs-comment">// 返回读出的大小</span><br>  <span class="hljs-keyword">return</span> tot;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>writei 用于将文件数据写入 inode 中, 该函数实现如下:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Write data to inode.</span><br><span class="hljs-comment">// Caller must hold ip-&gt;lock.</span><br><span class="hljs-comment">// If user_src==1, then src is a user virtual address;</span><br><span class="hljs-comment">// otherwise, src is a kernel address.</span><br><span class="hljs-type">int</span><br><span class="hljs-title function_">writei</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> inode *ip, <span class="hljs-type">int</span> user_src, uint64 src, uint off, uint n)</span><br>&#123;<br>  uint tot, m;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">buf</span> *<span class="hljs-title">bp</span>;</span><br><br>  <span class="hljs-keyword">if</span>(off &gt; ip-&gt;size || off + n &lt; off)<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>  <span class="hljs-keyword">if</span>(off + n &gt; MAXFILE*BSIZE)<br>    <span class="hljs-comment">// off可以等于ip-&gt;size,这样就相当于增长文件，但off+n即期望文件总大小不能超过规定的</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br><br>  <span class="hljs-comment">// copies data into the buffers </span><br>  <span class="hljs-keyword">for</span>(tot=<span class="hljs-number">0</span>; tot&lt;n; tot+=m, off+=m, src+=m)&#123;<br>    bp = bread(ip-&gt;dev, bmap(ip, off/BSIZE));<br>    m = min(n - tot, BSIZE - off%BSIZE);<br>    <span class="hljs-keyword">if</span>(either_copyin(bp-&gt;data + (off % BSIZE), user_src, src, m) == <span class="hljs-number">-1</span>) &#123;<br>      brelse(bp);<br>      <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-comment">// 缓存块被修改，将更新写入日志</span><br>    log_write(bp);<br>    brelse(bp);<br>  &#125;<br><br>  <span class="hljs-keyword">if</span>(n &gt; <span class="hljs-number">0</span>)&#123;<br>    <span class="hljs-keyword">if</span>(off &gt; ip-&gt;size)<br>      ip-&gt;size = off;<br>    <span class="hljs-comment">// write the i-node back to disk even if the size didn&#x27;t change</span><br>    <span class="hljs-comment">// because the loop above might have called bmap() and added a new</span><br>    <span class="hljs-comment">// block to ip-&gt;addrs[].</span><br>    iupdate(ip);<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> n;<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li>在该函数中, 即便文件大小没有增长, 也需要调用 iupdate 将 inode 写入磁盘, 因为调用 bmap 时可能分配了新的数据块, 从而导致 inode 的 addrs 的变化.</li>
</ul>
<p>stati 能将 inode 的元数据拷贝到位于内存中的 struct stat 中, 为上层的用户进程提供访问该 inode 元数据的接口:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Copy stat information from inode.</span><br><span class="hljs-comment">// Caller must hold ip-&gt;lock.</span><br><span class="hljs-type">void</span><br><span class="hljs-title function_">stati</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> inode *ip, <span class="hljs-keyword">struct</span> stat *st)</span><br>&#123;<br>  st-&gt;dev = ip-&gt;dev;<br>  st-&gt;ino = ip-&gt;inum;<br>  st-&gt;type = ip-&gt;type;<br>  st-&gt;nlink = ip-&gt;nlink;<br>  st-&gt;size = ip-&gt;size;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="目录层">目录层</h3>
<p>目录实质上也是一种文件, 它的 inode 类型字段是 T_DIR, 其数据内容是一系列目录项. 在 xv6 中, 每个目录项的类型是 struct dirent, 该结构体如下所示:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// A directory &#x27;s inode has type T_DIR and its data is a sequence of directory entries.</span><br><span class="hljs-comment">// Directory entries with inode number zero are free.</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dirent</span> &#123;</span><br>  ushort inum;<br>  <span class="hljs-type">char</span> name[DIRSIZ];  <span class="hljs-comment">// DIRSIZ = 14</span><br>&#125;;<br></code></pre></td></tr></table></figure>
<p>每个目录项包含了一个用户可读名称和 inode 号. 用户可读名称最长为 14 个字符, 而 inum 为 0 的目录项是空闲的.</p>
<p>dirlookup 函数用于在目录中查找目录项:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Look for a directory entry in a directory.</span><br><span class="hljs-comment">// If found, set *poff to byte offset of entry.</span><br><span class="hljs-keyword">struct</span> inode*<br><span class="hljs-title function_">dirlookup</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> inode *dp, <span class="hljs-type">char</span> *name, uint *poff)</span><br>&#123;<br>  uint off, inum;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dirent</span> <span class="hljs-title">de</span>;</span><br><br>  <span class="hljs-keyword">if</span>(dp-&gt;type != T_DIR)<br>    panic(<span class="hljs-string">&quot;dirlookup not DIR&quot;</span>);<br><br>  <span class="hljs-keyword">for</span>(off = <span class="hljs-number">0</span>; off &lt; dp-&gt;size; off += <span class="hljs-keyword">sizeof</span>(de))&#123;<br>    <span class="hljs-keyword">if</span>(readi(dp, <span class="hljs-number">0</span>, (uint64)&amp;de, off, <span class="hljs-keyword">sizeof</span>(de)) != <span class="hljs-keyword">sizeof</span>(de))<br>      panic(<span class="hljs-string">&quot;dirlookup read&quot;</span>);<br>    <span class="hljs-keyword">if</span>(de.inum == <span class="hljs-number">0</span>)<br>      <span class="hljs-keyword">continue</span>;<br>    <span class="hljs-keyword">if</span>(namecmp(name, de.name) == <span class="hljs-number">0</span>)&#123;<br>      <span class="hljs-comment">// entry matches path element</span><br>      <span class="hljs-keyword">if</span>(poff)<br>        *poff = off;<br>      inum = de.inum;<br>      <span class="hljs-keyword">return</span> iget(dp-&gt;dev, inum);<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>上文中所说的 iget 不能给相应的 inode 上锁的原因便在此: 避免在路径名查找时发生死锁. 因为调用 dirlookup 的线程已经对当前目录 dp 上锁了, 而如果要查找的路径名是 “.”, 即当前目录, 那么就会发生死锁.</p>
<p>dirlink 函数用于在给定目录中创建一个新的目录项, 即创建一个新的硬链接:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Write a new directory entry (name, inum) into the directory dp.</span><br><span class="hljs-type">int</span><br><span class="hljs-title function_">dirlink</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> inode *dp, <span class="hljs-type">char</span> *name, uint inum)</span><br>&#123;<br>  <span class="hljs-type">int</span> off;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dirent</span> <span class="hljs-title">de</span>;</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">inode</span> *<span class="hljs-title">ip</span>;</span><br><br>  <span class="hljs-comment">// Check that name is not present.</span><br>  <span class="hljs-keyword">if</span>((ip = dirlookup(dp, name, <span class="hljs-number">0</span>)) != <span class="hljs-number">0</span>)&#123;<br>    <span class="hljs-comment">// the name already exists</span><br>    iput(ip);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>  &#125;<br><br>  <span class="hljs-comment">// Look for an empty dirent.</span><br>  <span class="hljs-keyword">for</span>(off = <span class="hljs-number">0</span>; off &lt; dp-&gt;size; off += <span class="hljs-keyword">sizeof</span>(de))&#123;<br>    <span class="hljs-keyword">if</span>(readi(dp, <span class="hljs-number">0</span>, (uint64)&amp;de, off, <span class="hljs-keyword">sizeof</span>(de)) != <span class="hljs-keyword">sizeof</span>(de))<br>      panic(<span class="hljs-string">&quot;dirlink read&quot;</span>);<br>    <span class="hljs-keyword">if</span>(de.inum == <span class="hljs-number">0</span>)<br>      <span class="hljs-keyword">break</span>;<br>  &#125;<br><br>  <span class="hljs-comment">// 如果没找到空的，off=dp-&gt;size</span><br>  <span class="hljs-comment">// 往该inode中继续写入，其size会继续增大</span><br>  <span class="hljs-built_in">strncpy</span>(de.name, name, DIRSIZ);<br>  de.inum = inum;<br>  <span class="hljs-comment">// adds a new entry to the directory by writing at offset off</span><br>  <span class="hljs-keyword">if</span>(writei(dp, <span class="hljs-number">0</span>, (uint64)&amp;de, off, <span class="hljs-keyword">sizeof</span>(de)) != <span class="hljs-keyword">sizeof</span>(de))<br>    panic(<span class="hljs-string">&quot;dirlink&quot;</span>);<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>现在已经讨论了文件系统的四层结构, 现在开始完善之前使用日志系统的代码框架:</p>
<p>原本 Buffer Cache 的框架如下:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c">begin_op();<br><span class="hljs-comment">// ...</span><br>bp = bread(...);      <span class="hljs-comment">// read out bp</span><br>bp-&gt;data[...] = ...;  <span class="hljs-comment">// modify bp-&gt;data[]</span><br>log_write(bp);        <span class="hljs-comment">// bp has been modified, so put it in log</span><br>brelse(bp);           <span class="hljs-comment">// release bp</span><br><span class="hljs-comment">// ...</span><br>end_op();<br></code></pre></td></tr></table></figure>
<p>原本 inode 的框架如下:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c">begin_op();<br><span class="hljs-comment">// ...</span><br>ilock(f-&gt;ip);<br>r = writei(f-&gt;ip, ...);  <span class="hljs-comment">// modify file&#x27;s inode, one or more bitmap blocks, and some data blocks</span><br>iunlock(f-&gt;ip);<br><span class="hljs-comment">// ...</span><br>end_op();<br></code></pre></td></tr></table></figure>
<p>一个更完整的框架如下:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c">begin_op();<br><span class="hljs-comment">// ...</span><br>ip = iget(dev, inum);<br>ilock(ip);<br>bp = bread(ip);<br>bp-&gt;data[...] = ...  <span class="hljs-comment">// modify bp-&gt;data[], i.e. modify ip</span><br>log_write(bp);<br>brelse(bp);<br>iupdate(ip);<br><span class="hljs-comment">// ...</span><br>iunlock(ip);<br>iput(ip);<br><span class="hljs-comment">// ...</span><br>end_op();<br></code></pre></td></tr></table></figure>
<h3 id="路径名层">路径名层</h3>
<p>现在, 我们关注完整的路径名查找过程, 这个过程需要调用一连串的 dirlookup.</p>
<p>namei 和 nameiparent 就负责这样的路径名查找:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">struct</span> inode*<br><span class="hljs-title function_">namei</span><span class="hljs-params">(<span class="hljs-type">char</span> *path)</span><br>&#123;<br>  <span class="hljs-type">char</span> name[DIRSIZ];<br>  <span class="hljs-comment">//evaluates path and returns the corresponding inode</span><br>  <span class="hljs-keyword">return</span> namex(path, <span class="hljs-number">0</span>, name);<br>&#125;<br><br><span class="hljs-keyword">struct</span> inode*<br><span class="hljs-title function_">nameiparent</span><span class="hljs-params">(<span class="hljs-type">char</span> *path, <span class="hljs-type">char</span> *name)</span><br>&#123;<br>  <span class="hljs-comment">// 这里name不是临时buffer，调用者提供name来装载它，因为调用者还需要它</span><br>  <span class="hljs-keyword">return</span> namex(path, <span class="hljs-number">1</span>, name);<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li>它们都接收完整的路径名作为输入, 返回相关的 inode. 不同之处在于: namei 返回路径名中最后一个元素的 inode; 而 nameiparent 返回最后一个元素的父目录的 inode, 并且将最后一个元素的名称复制到调用者指定的位置 *name 中.</li>
<li>这两个函数都调用 namex 完成路径名查找的工作.</li>
</ul>
<p>namex 通过 skipelem 函数来解析路径名. skipelem 函数实现如下:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Copy the next path element from path into name.</span><br><span class="hljs-comment">// Return a pointer to the element following the copied one.</span><br><span class="hljs-comment">// The returned path has no leading slashes,</span><br><span class="hljs-comment">// so the caller can check *path==&#x27;\0&#x27; to see if the name is the last one.</span><br><span class="hljs-comment">// If no name to remove, return 0.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// Examples:</span><br><span class="hljs-comment">//   skipelem(&quot;a/bb/c&quot;, name) = &quot;bb/c&quot;, setting name = &quot;a&quot;</span><br><span class="hljs-comment">//   skipelem(&quot;///a//bb&quot;, name) = &quot;bb&quot;, setting name = &quot;a&quot;</span><br><span class="hljs-comment">//   skipelem(&quot;a&quot;, name) = &quot;&quot;, setting name = &quot;a&quot;</span><br><span class="hljs-comment">//   skipelem(&quot;&quot;, name) = skipelem(&quot;////&quot;, name) = 0</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// skipelem将下个path element拷贝到name中，返回跟在下个path element的后续路径</span><br><span class="hljs-comment">// 如果skipelem返回&#x27;\0&#x27;，表示提取出的path element已经是最后一个</span><br><span class="hljs-comment">// 如果path是&#x27;\0&#x27;，那么skipelem返回0</span><br><span class="hljs-type">static</span> <span class="hljs-type">char</span>*<br><span class="hljs-title function_">skipelem</span><span class="hljs-params">(<span class="hljs-type">char</span> *path, <span class="hljs-type">char</span> *name)</span><br>&#123;<br>  <span class="hljs-type">char</span> *s;<br>  <span class="hljs-type">int</span> len;<br><br>  <span class="hljs-keyword">while</span>(*path == <span class="hljs-string">&#x27;/&#x27;</span>)<br>    path++;<br>  <span class="hljs-keyword">if</span>(*path == <span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>  s = path;<br>  <span class="hljs-keyword">while</span>(*path != <span class="hljs-string">&#x27;/&#x27;</span> &amp;&amp; *path != <span class="hljs-number">0</span>)<br>    path++;<br>  len = path - s;<br>  <span class="hljs-keyword">if</span>(len &gt;= DIRSIZ)<br>    memmove(name, s, DIRSIZ);<br>  <span class="hljs-keyword">else</span> &#123;<br>    memmove(name, s, len);<br>    name[len] = <span class="hljs-number">0</span>;<br>  &#125;<br>  <span class="hljs-keyword">while</span>(*path == <span class="hljs-string">&#x27;/&#x27;</span>)<br>    path++;<br>  <span class="hljs-keyword">return</span> path;<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li>skipelem 能提取出路径中的下一个元素, 并赋值给 name, 然后返回下一个元素之后的路径. 注释中给出了简单的示例.</li>
</ul>
<p>namex 函数用于路径名查找:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Look up and return the inode for a path name.</span><br><span class="hljs-comment">// If parent != 0, return the inode for the parent and copy the final</span><br><span class="hljs-comment">// path element into name, which must have room for DIRSIZ bytes.</span><br><span class="hljs-comment">// Must be called inside a transaction since it calls iput().</span><br><span class="hljs-comment">// if an invocation of namex by one kernel thread is blocked on a disk I/O, </span><br><span class="hljs-comment">// another kernel thread looking up a different pathname can proceed concurrently.</span><br><span class="hljs-type">static</span> <span class="hljs-keyword">struct</span> inode*<br><span class="hljs-title function_">namex</span><span class="hljs-params">(<span class="hljs-type">char</span> *path, <span class="hljs-type">int</span> nameiparent, <span class="hljs-type">char</span> *name)</span><br>&#123;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">inode</span> *<span class="hljs-title">ip</span>, *<span class="hljs-title">next</span>;</span><br><br>  <span class="hljs-comment">// 决定从哪里开始找，如果有&#x27;/&#x27;就从根目录开始，否则从当前目录开始</span><br>  <span class="hljs-keyword">if</span>(*path == <span class="hljs-string">&#x27;/&#x27;</span>)<br>    ip = iget(ROOTDEV, ROOTINO);<br>  <span class="hljs-keyword">else</span><br>    ip = idup(myproc()-&gt;cwd);<br><br>  <span class="hljs-comment">// uses skipelem to consider each element of the path in turn</span><br>  <span class="hljs-keyword">while</span>((path = skipelem(path, name)) != <span class="hljs-number">0</span>)&#123;<br>    <span class="hljs-comment">// skipelem将下个path element拷贝到name中，返回跟在下个path element的后续路径</span><br>    <span class="hljs-comment">// 如果*path==&#x27;\0&#x27;就表示提取出的path element已经是最后一个</span><br>    <span class="hljs-comment">// 例: 最开始path = &#x27;/a/b&#x27;，b可以是文件也可以是目录，当前目录ip为根目录&#x27;/&#x27;</span><br>    <span class="hljs-comment">// 1、path = /b,name = a,next = name = a,ip = next = a</span><br>    <span class="hljs-comment">// 2、path = &quot;\0&quot;,name = b,(如果是nameiparent就在这一步停止并返回ip = a,name = b),</span><br>    <span class="hljs-comment">// next = name = b,ip = next = b</span><br>    <span class="hljs-comment">// 3、path = 0,name = b,ip = b,namei在跳出循环后返回ip = b</span><br>    ilock(ip);<br>    <span class="hljs-comment">// 检查当前结点ip是否为目录类型</span><br>    <span class="hljs-keyword">if</span>(ip-&gt;type != T_DIR)&#123;<br>      iunlockput(ip);<br>      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(nameiparent &amp;&amp; *path == <span class="hljs-string">&#x27;\0&#x27;</span>)&#123;<br>      <span class="hljs-comment">// path=&#x27;\0&#x27;表示name已经是最后一个元素</span><br>      iunlock(ip);<br>      <span class="hljs-comment">// 调用者为nameiparent，当前ip就是最后一个元素的父目录</span><br>      <span class="hljs-comment">// 最后一个元素的名称在skipelem中已被复制到name</span><br>      <span class="hljs-keyword">return</span> ip;<br>    &#125;<br>    <span class="hljs-comment">// 在当前目录结点ip下，找name，也就是找下一个path element</span><br>    <span class="hljs-keyword">if</span>((next = dirlookup(ip, name, <span class="hljs-number">0</span>)) == <span class="hljs-number">0</span>)&#123;<br>      <span class="hljs-comment">// 在当前目录结点下找不到</span><br>      iunlockput(ip);<br>      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    iunlockput(ip);<br>    <span class="hljs-comment">// 释放ip，为下一次循环做准备</span><br>    <span class="hljs-comment">// 当查找&#x27;.&#x27;时，next和ip相同，若在释放ip的锁之前给next上锁就会发生死锁</span><br>    <span class="hljs-comment">// 因此namex在下一个循环中获取next的锁之前，在这里要先释放ip的锁，从而避免死锁</span><br>    ip = next;<br>  &#125;<br>  <span class="hljs-keyword">if</span>(nameiparent)&#123;<br>    <span class="hljs-comment">// 正常情况下nameiparent应该在主循环中就返回</span><br>    <span class="hljs-comment">// 如果运行到了这里，说明nameiparent失败，因此namex返回0</span><br>    iput(ip);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>  &#125;<br>  <span class="hljs-comment">// When the loop runs out of path elements, it returns</span><br>  <span class="hljs-keyword">return</span> ip;<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li>首先, namex 决定从哪里开始查找路径, 如果路径名 path 以 “/” 开头, 那么就从根目录开始; 否则从当前工作目录开始. 之后 namex 就使用 skipelem 来解析当前路径名 path.</li>
<li>在 <code>while</code> 循环中, 必须先释放 ip 的锁, 然后在下次循环开始重新获取锁. 这是为了防止死锁. 例如, 如果 path 为 “./a”, 不在 <code>while</code> 循环末释放 ip 的锁, 就会发生死锁.</li>
<li>namex 的设计很谨慎, 它同一时间只对一个目录上锁, 然后调用 dirlookup 查找该目录. 因此, 就算有多个内核线程调用 namex, 只要 dirlookup 查找的目录是不同的, 我们就可以并发地进行路径名查找.</li>
</ul>
<h3 id="文件描述符层">文件描述符层</h3>
<p>UNIX 操作系统实现了很好的抽象 — 一切皆文件, 无论底层是普通文件、目录、还是控制台、管道等设备, 用户都可以将它们看成是文件.</p>
<p>在 xv6 中, 每个打开文件可以用一个 struct file 类型表示, 该结构体定义如下:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Each call to open creates a new open file(a new struct file)</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file</span> &#123;</span><br>  <span class="hljs-class"><span class="hljs-keyword">enum</span> &#123;</span> FD_NONE, FD_PIPE, FD_INODE, FD_DEVICE &#125; type;<br>  <span class="hljs-type">int</span> ref; <span class="hljs-comment">// reference count</span><br>  <span class="hljs-type">char</span> readable;<br>  <span class="hljs-type">char</span> writable;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pipe</span> *<span class="hljs-title">pipe</span>;</span> <span class="hljs-comment">// FD_PIPE</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">inode</span> *<span class="hljs-title">ip</span>;</span>  <span class="hljs-comment">// FD_INODE and FD_DEVICE</span><br>  uint off;          <span class="hljs-comment">// FD_INODE</span><br>  <span class="hljs-type">short</span> major;       <span class="hljs-comment">// FD_DEVICE</span><br>&#125;;<br></code></pre></td></tr></table></figure>
<ul>
<li>每次调用 open 时, 都会创建一个新的打开文件, 即创建一个新的 struct file 实例. 因此, 如果有多个进程同时打开同一个文件, 它们的 struct file 实例是不同的, 即它们会有不同的偏移量.</li>
<li>相同的 struct file 实例, 可以多次出现在一个或多个进程的打开文件表中.
<ul>
<li>例如使用 open 打开文件之后, 又调用了 dup 或 fork 等系统调用.</li>
</ul>
</li>
<li>ref 字段跟踪该 struct file 被引用了多少次.</li>
</ul>
<p>xv6 使用了一个全局的打开文件表, 称为 ftable, 如下所示:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">spinlock</span> <span class="hljs-title">lock</span>;</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file</span> <span class="hljs-title">file</span>[<span class="hljs-title">NFILE</span>];</span>  <span class="hljs-comment">// NFILE = 100</span><br>&#125; ftable;<br></code></pre></td></tr></table></figure>
<ul>
<li>系统中所有的打开文件都会存放在这个 ftable 中, 因此 xv6 最多可以同时打开 100 个文件.</li>
</ul>
<p>此外, 每个 xv6 进程都有一个打开文件表 ofile, 如下所示:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span>&#123;</span><br>  <span class="hljs-comment">// ...</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file</span> *<span class="hljs-title">ofile</span>[<span class="hljs-title">NOFILE</span>];</span>  <span class="hljs-comment">// Open files, NOFILE = 16</span><br>  <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li>每个用户进程最多同时打开 16 个文件, 即用户进程的文件描述符号范围是从 0 到 15.</li>
</ul>
<p>filealloc 用于分配一个新的打开文件:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Allocate a file structure.</span><br><span class="hljs-keyword">struct</span> file*<br><span class="hljs-title function_">filealloc</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file</span> *<span class="hljs-title">f</span>;</span><br><br>  acquire(&amp;ftable.lock);<br>  <span class="hljs-keyword">for</span>(f = ftable.file; f &lt; ftable.file + NFILE; f++)&#123;<br>    <span class="hljs-keyword">if</span>(f-&gt;ref == <span class="hljs-number">0</span>)&#123;<br>      f-&gt;ref = <span class="hljs-number">1</span>;<br>      release(&amp;ftable.lock);<br>      <span class="hljs-keyword">return</span> f;<br>    &#125;<br>  &#125;<br>  release(&amp;ftable.lock);<br>  <span class="hljs-comment">// don&#x27;t panic when run out of files</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li>该函数扫描打开文件表, 找到第一个空闲的槽位, 然后返回新的引用.</li>
<li>当打开文件数达到上限时, filealloc 只返回 0, 并不会使 xv6 陷入 panic.</li>
</ul>
<p>filedup 用于创建一个打开文件的副本:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Increment ref count for file f.</span><br><span class="hljs-keyword">struct</span> file*<br><span class="hljs-title function_">filedup</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> file *f)</span><br>&#123;<br>  acquire(&amp;ftable.lock);<br>  <span class="hljs-keyword">if</span>(f-&gt;ref &lt; <span class="hljs-number">1</span>)<br>    panic(<span class="hljs-string">&quot;filedup&quot;</span>);<br>  f-&gt;ref++;<br>  release(&amp;ftable.lock);<br>  <span class="hljs-keyword">return</span> f;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>fileclose 用于减少打开的文件的引用计数:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Close file f.  (Decrement ref count, close when reaches 0.)</span><br><span class="hljs-type">void</span><br><span class="hljs-title function_">fileclose</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> file *f)</span><br>&#123;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file</span> <span class="hljs-title">ff</span>;</span><br><br>  acquire(&amp;ftable.lock);<br>  <span class="hljs-keyword">if</span>(f-&gt;ref &lt; <span class="hljs-number">1</span>)<br>    panic(<span class="hljs-string">&quot;fileclose&quot;</span>);<br>  <span class="hljs-keyword">if</span>(--f-&gt;ref &gt; <span class="hljs-number">0</span>)&#123;<br>    release(&amp;ftable.lock);<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br>  ff = *f;<br>  f-&gt;ref = <span class="hljs-number">0</span>;<br>  f-&gt;type = FD_NONE;<br>  release(&amp;ftable.lock);<br><br>  <span class="hljs-comment">// Releases the underlying pipe or inode, according to the type.</span><br>  <span class="hljs-keyword">if</span>(ff.type == FD_PIPE)&#123;<br>    pipeclose(ff.pipe, ff.writable);<br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(ff.type == FD_INODE || ff.type == FD_DEVICE)&#123;<br>    begin_op();<br>    iput(ff.ip);<br>    end_op();<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li>当 ref 大于 1 时, 直接将 ref 减 1 即可返回; 当 ref 等于 1 时, 代表对该打开文件的最后一个引用也将删除, fileclose 就更改该打开文件的类型为 FD_NONE, 然后再检查该打开文件下层资源的类型, 如果是 pipe 、inode 或设备, 那么还需要调用对应的 pipeclose 或 iput 来关闭和释放这些底层资源.</li>
</ul>
<p>filestat 利用 inode 层的 stati 接口, 为系统调用 fstat 提供服务:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Get metadata about file f.</span><br><span class="hljs-comment">// addr is a user virtual address, pointing to a struct stat.</span><br><span class="hljs-type">int</span><br><span class="hljs-title function_">filestat</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> file *f, uint64 addr)</span><br>&#123;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">p</span> =</span> myproc();<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">stat</span> <span class="hljs-title">st</span>;</span><br>  <br>  <span class="hljs-keyword">if</span>(f-&gt;type == FD_INODE || f-&gt;type == FD_DEVICE)&#123;<br>    ilock(f-&gt;ip);<br>    stati(f-&gt;ip, &amp;st);<br>    iunlock(f-&gt;ip);<br>    <span class="hljs-keyword">if</span>(copyout(p-&gt;pagetable, addr, (<span class="hljs-type">char</span> *)&amp;st, <span class="hljs-keyword">sizeof</span>(st)) &lt; <span class="hljs-number">0</span>)<br>      <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br><br>uint64<br><span class="hljs-title function_">sys_fstat</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file</span> *<span class="hljs-title">f</span>;</span><br>  uint64 st; <span class="hljs-comment">// user pointer to struct stat</span><br><br>  <span class="hljs-keyword">if</span>(argfd(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, &amp;f) &lt; <span class="hljs-number">0</span> || argaddr(<span class="hljs-number">1</span>, &amp;st) &lt; <span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>  <span class="hljs-keyword">return</span> filestat(f, st);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>fileread 根据不同的底层文件类型, 调用不同的方法来读取这些资源, 为系统调用 read 提供服务:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Read from file f.</span><br><span class="hljs-comment">// addr is a user virtual address.</span><br><span class="hljs-type">int</span><br><span class="hljs-title function_">fileread</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> file *f, uint64 addr, <span class="hljs-type">int</span> n)</span><br>&#123;<br>  <span class="hljs-type">int</span> r = <span class="hljs-number">0</span>;<br><br>  <span class="hljs-keyword">if</span>(f-&gt;readable == <span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br><br>  <span class="hljs-keyword">if</span>(f-&gt;type == FD_PIPE)&#123;<br>    <span class="hljs-comment">// Pipes have no concept of offset</span><br>    r = piperead(f-&gt;pipe, addr, n);<br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(f-&gt;type == FD_DEVICE)&#123;<br>    <span class="hljs-keyword">if</span>(f-&gt;major &lt; <span class="hljs-number">0</span> || f-&gt;major &gt;= NDEV || !devsw[f-&gt;major].read)<br>      <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    r = devsw[f-&gt;major].read(<span class="hljs-number">1</span>, addr, n);<br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(f-&gt;type == FD_INODE)&#123;<br>    ilock(f-&gt;ip);<br>    <span class="hljs-keyword">if</span>((r = readi(f-&gt;ip, <span class="hljs-number">1</span>, addr, f-&gt;off, n)) &gt; <span class="hljs-number">0</span>)<br>      <span class="hljs-comment">// If the file represents an inode,fileread and filewrite use the I/O offset as the offset for the operation and then advance it</span><br>      <span class="hljs-comment">// offset的更新也受到inode锁的保护，因此不会发生竞争问题</span><br>      f-&gt;off += r;<br>    iunlock(f-&gt;ip);<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    panic(<span class="hljs-string">&quot;fileread&quot;</span>);<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> r;<br>&#125;<br><br>uint64<br><span class="hljs-title function_">sys_read</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file</span> *<span class="hljs-title">f</span>;</span><br>  <span class="hljs-type">int</span> n;<br>  uint64 p;<br><br>  <span class="hljs-keyword">if</span>(argfd(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, &amp;f) &lt; <span class="hljs-number">0</span> || argint(<span class="hljs-number">2</span>, &amp;n) &lt; <span class="hljs-number">0</span> || argaddr(<span class="hljs-number">1</span>, &amp;p) &lt; <span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>  <span class="hljs-keyword">return</span> fileread(f, p, n);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>filewrite 和 fileread 类似, 它为系统调用 write 提供服务:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Write to file f.</span><br><span class="hljs-comment">// addr is a user virtual address.</span><br><span class="hljs-type">int</span><br><span class="hljs-title function_">filewrite</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> file *f, uint64 addr, <span class="hljs-type">int</span> n)</span><br>&#123;<br>  <span class="hljs-type">int</span> r, ret = <span class="hljs-number">0</span>;<br><br>  <span class="hljs-keyword">if</span>(f-&gt;writable == <span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br><br>  <span class="hljs-keyword">if</span>(f-&gt;type == FD_PIPE)&#123;<br>    ret = pipewrite(f-&gt;pipe, addr, n);<br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(f-&gt;type == FD_DEVICE)&#123;<br>    <span class="hljs-keyword">if</span>(f-&gt;major &lt; <span class="hljs-number">0</span> || f-&gt;major &gt;= NDEV || !devsw[f-&gt;major].write)<br>      <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    ret = devsw[f-&gt;major].write(<span class="hljs-number">1</span>, addr, n);<br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(f-&gt;type == FD_INODE)&#123;<br>    <span class="hljs-comment">// write a few blocks at a time to avoid exceeding</span><br>    <span class="hljs-comment">// the maximum log transaction size, including</span><br>    <span class="hljs-comment">// i-node, indirect block, allocation blocks,</span><br>    <span class="hljs-comment">// and 2 blocks of slop for non-aligned writes.</span><br>    <span class="hljs-comment">// this really belongs lower down, since writei()</span><br>    <span class="hljs-comment">// might be writing a device like the console.</span><br>    <span class="hljs-type">int</span> max = ((MAXOPBLOCKS<span class="hljs-number">-1</span><span class="hljs-number">-1</span><span class="hljs-number">-2</span>) / <span class="hljs-number">2</span>) * BSIZE;<br>    <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(i &lt; n)&#123;<br>      <span class="hljs-type">int</span> n1 = n - i;<br>      <span class="hljs-keyword">if</span>(n1 &gt; max)<br>        n1 = max;<br><br>      begin_op();<br>      ilock(f-&gt;ip);<br>      <span class="hljs-keyword">if</span> ((r = writei(f-&gt;ip, <span class="hljs-number">1</span>, addr + i, f-&gt;off, n1)) &gt; <span class="hljs-number">0</span>)<br>        f-&gt;off += r;<br>      iunlock(f-&gt;ip);<br>      end_op();<br><br>      <span class="hljs-keyword">if</span>(r &lt; <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">break</span>;<br>      <span class="hljs-keyword">if</span>(r != n1)<br>        panic(<span class="hljs-string">&quot;short filewrite&quot;</span>);<br>      i += r;<br>    &#125;<br>    ret = (i == n ? n : <span class="hljs-number">-1</span>);<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    panic(<span class="hljs-string">&quot;filewrite&quot;</span>);<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> ret;<br>&#125;<br><br>uint64<br><span class="hljs-title function_">sys_write</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file</span> *<span class="hljs-title">f</span>;</span><br>  <span class="hljs-type">int</span> n;<br>  uint64 p;<br><br>  <span class="hljs-keyword">if</span>(argfd(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, &amp;f) &lt; <span class="hljs-number">0</span> || argint(<span class="hljs-number">2</span>, &amp;n) &lt; <span class="hljs-number">0</span> || argaddr(<span class="hljs-number">1</span>, &amp;p) &lt; <span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br><br>  <span class="hljs-keyword">return</span> filewrite(f, p, n);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>注意到, fileread 和 filewrite 中都使用了 ilock 的锁机制, 读取和写入的偏移量都将会原子地更新, 因此对同一文件的多次写入不会覆盖彼此的数据, 对同一文件的多次读也不会读出重复的数据. 因此我们不需要在 struct file 中额外添加锁来保护 off.</p>
<p>fdalloc 根据给定的 ftable 中的打开文件 f, 在用户进程的打开文件表 ofile 中记录 f, 并且分配一个文件描述符:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Allocate a file descriptor for the given file.</span><br><span class="hljs-comment">// Takes over file reference from caller on success.</span><br><span class="hljs-type">static</span> <span class="hljs-type">int</span><br><span class="hljs-title function_">fdalloc</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> file *f)</span><br>&#123;<br>  <span class="hljs-type">int</span> fd;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">p</span> =</span> myproc();<br><br>  <span class="hljs-keyword">for</span>(fd = <span class="hljs-number">0</span>; fd &lt; NOFILE; fd++)&#123;<br>    <span class="hljs-keyword">if</span>(p-&gt;ofile[fd] == <span class="hljs-number">0</span>)&#123;<br>      p-&gt;ofile[fd] = f;<br>      <span class="hljs-keyword">return</span> fd;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="文件系统调用">文件系统调用</h2>
<p>sys_link 为给定的 inode 创建新的目录项, 即创建新的硬链接:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Create the path new as a link to the same inode as old.</span><br>uint64<br><span class="hljs-title function_">sys_link</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>  <span class="hljs-comment">//creates a new name for an existing inode</span><br>  <span class="hljs-type">char</span> name[DIRSIZ], new[MAXPATH], old[MAXPATH];<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">inode</span> *<span class="hljs-title">dp</span>, *<span class="hljs-title">ip</span>;</span><br><br>  <span class="hljs-comment">// a0传进旧名称，a1传进新名称</span><br>  <span class="hljs-keyword">if</span>(argstr(<span class="hljs-number">0</span>, old, MAXPATH) &lt; <span class="hljs-number">0</span> || argstr(<span class="hljs-number">1</span>, new, MAXPATH) &lt; <span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br><br>  begin_op();<br>  <span class="hljs-keyword">if</span>((ip = namei(old)) == <span class="hljs-number">0</span>)&#123;<br>    end_op();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>  &#125;<br><br>  ilock(ip);<br>  <span class="hljs-keyword">if</span>(ip-&gt;type == T_DIR)&#123;<br>    iunlockput(ip);<br>    end_op();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>  &#125;<br><br>  <span class="hljs-comment">// old exists and is not a directory</span><br>  <span class="hljs-comment">// 硬链接数加1</span><br>  ip-&gt;nlink++;<br>  iupdate(ip);<br>  iunlock(ip);<br><br>  <span class="hljs-comment">// find the parent directory and final path element of new</span><br>  <span class="hljs-comment">// The new parent directory must exist and be on the same device as the existing inode</span><br>  <span class="hljs-keyword">if</span>((dp = nameiparent(new, name)) == <span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">goto</span> bad;<br>  ilock(dp);<br>  <span class="hljs-comment">// creates a new directory entry pointing at old’s inode</span><br>  <span class="hljs-keyword">if</span>(dp-&gt;dev != ip-&gt;dev || dirlink(dp, name, ip-&gt;inum) &lt; <span class="hljs-number">0</span>)&#123;<br>    iunlockput(dp);<br>    <span class="hljs-keyword">goto</span> bad;<br>  &#125;<br>  iunlockput(dp);<br>  iput(ip);<br><br>  end_op();<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>bad:<br>  ilock(ip);<br>  ip-&gt;nlink--;<br>  iupdate(ip);<br>  iunlockput(ip);<br>  end_op();<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li>sys_link 从寄存器获取参数, 寄存器 a0 中存放的是旧路径名, 寄存器 a1 中存放的是是新路径名.</li>
<li>该函数通过 nameiparent 得到新路径名中最后一个元素的父目录的 inode, 此时必须保证父目录和旧路径名位于同一个设备, 因为 inode 号只在同一个设备上有效.</li>
</ul>
<p>sys_unlink 和 sys_link 类似:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs c">uint64<br><span class="hljs-title function_">sys_unlink</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">inode</span> *<span class="hljs-title">ip</span>, *<span class="hljs-title">dp</span>;</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dirent</span> <span class="hljs-title">de</span>;</span><br>  <span class="hljs-type">char</span> name[DIRSIZ], path[MAXPATH];<br>  uint off;<br><br>  <span class="hljs-keyword">if</span>(argstr(<span class="hljs-number">0</span>, path, MAXPATH) &lt; <span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br><br>  begin_op();<br>  <span class="hljs-keyword">if</span>((dp = nameiparent(path, name)) == <span class="hljs-number">0</span>)&#123;<br>    end_op();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>  &#125;<br>  <br>  ilock(dp);<br>  <br>  <span class="hljs-comment">// Cannot unlink &quot;.&quot; or &quot;..&quot;.</span><br>  <span class="hljs-keyword">if</span>(namecmp(name, <span class="hljs-string">&quot;.&quot;</span>) == <span class="hljs-number">0</span> || namecmp(name, <span class="hljs-string">&quot;..&quot;</span>) == <span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">goto</span> bad;<br><br>  <span class="hljs-keyword">if</span>((ip = dirlookup(dp, name, &amp;off)) == <span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">goto</span> bad;<br>  ilock(ip);<br><br>  <span class="hljs-keyword">if</span>(ip-&gt;nlink &lt; <span class="hljs-number">1</span>)<br>    panic(<span class="hljs-string">&quot;unlink: nlink &lt; 1&quot;</span>);<br>  <span class="hljs-keyword">if</span>(ip-&gt;type == T_DIR &amp;&amp; !isdirempty(ip))&#123;<br>    iunlockput(ip);<br>    <span class="hljs-keyword">goto</span> bad;<br>  &#125;<br>  <br>  <span class="hljs-built_in">memset</span>(&amp;de, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(de));<br>  <span class="hljs-keyword">if</span>(writei(dp, <span class="hljs-number">0</span>, (uint64)&amp;de, off, <span class="hljs-keyword">sizeof</span>(de)) != <span class="hljs-keyword">sizeof</span>(de))<br>    panic(<span class="hljs-string">&quot;unlink: writei&quot;</span>);<br>  <span class="hljs-keyword">if</span>(ip-&gt;type == T_DIR)&#123;<br>    dp-&gt;nlink--;<br>    iupdate(dp);<br>  &#125;<br>  iunlockput(dp);<br><br>  ip-&gt;nlink--;<br>  iupdate(ip);<br>  iunlockput(ip);<br><br>  end_op();<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>bad:<br>  iunlockput(dp);<br>  end_op();<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>create 根据给定的路径名, 创建一个全新的 inode:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 以下三种情况会用到create</span><br><span class="hljs-comment">// open with the O_CREATE flag makes a new ordinary file</span><br><span class="hljs-comment">// mkdir makes a new directory  </span><br><span class="hljs-comment">// mkdev makes a new device file</span><br><span class="hljs-type">static</span> <span class="hljs-keyword">struct</span> inode*<br><span class="hljs-title function_">create</span><span class="hljs-params">(<span class="hljs-type">char</span> *path, <span class="hljs-type">short</span> type, <span class="hljs-type">short</span> major, <span class="hljs-type">short</span> minor)</span><br>&#123;<br>  <span class="hljs-comment">// creates a new name for a new inode</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">inode</span> *<span class="hljs-title">ip</span>, *<span class="hljs-title">dp</span>;</span><br>  <span class="hljs-type">char</span> name[DIRSIZ];<br><br>  <span class="hljs-comment">// get the inode of the parent directory</span><br>  <span class="hljs-keyword">if</span>((dp = nameiparent(path, name)) == <span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>  ilock(dp);<br><br>  <span class="hljs-comment">// check whether the name already exists</span><br>  <span class="hljs-keyword">if</span>((ip = dirlookup(dp, name, <span class="hljs-number">0</span>)) != <span class="hljs-number">0</span>)&#123;<br>    <span class="hljs-comment">// name does exists</span><br>    iunlockput(dp);<br>    ilock(ip);<br>    <span class="hljs-keyword">if</span>(type == T_FILE &amp;&amp; (ip-&gt;type == T_FILE || ip-&gt;type == T_DEVICE))<br>      <span class="hljs-keyword">return</span> ip;<br>    iunlockput(ip);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>  &#125;<br><br>  <span class="hljs-comment">// If the name does not already exist,create now allocates a new inode with ialloc</span><br>  <span class="hljs-keyword">if</span>((ip = ialloc(dp-&gt;dev, type)) == <span class="hljs-number">0</span>)<br>    panic(<span class="hljs-string">&quot;create: ialloc&quot;</span>);<br><br>  ilock(ip);<br>  <span class="hljs-comment">// 从这里开始，create同时持有ip和dp的锁</span><br>  <span class="hljs-comment">// There is no possibility of deadlock </span><br>  <span class="hljs-comment">// because the inode ip is freshly allocated</span><br>  <span class="hljs-comment">// thus no other process in the system will hold ip’s lock and then try to lock dp</span><br>  ip-&gt;major = major;<br>  ip-&gt;minor = minor;<br>  ip-&gt;nlink = <span class="hljs-number">1</span>;<br>  iupdate(ip);<br><br>  <span class="hljs-keyword">if</span>(type == T_DIR)&#123;  <br>    <span class="hljs-comment">// If the new inode is a directory,create initializes it with . and .. entries.</span><br>    <span class="hljs-comment">// Create . and .. entries.</span><br>    dp-&gt;nlink++;  <span class="hljs-comment">// for &quot;..&quot;</span><br>    iupdate(dp);<br>    <span class="hljs-comment">// No ip-&gt;nlink++ for &quot;.&quot;: avoid cyclic ref count.</span><br>    <span class="hljs-comment">// If the new inode is a directory,create initializes it with . and .. entries</span><br>    <span class="hljs-keyword">if</span>(dirlink(ip, <span class="hljs-string">&quot;.&quot;</span>, ip-&gt;inum) &lt; <span class="hljs-number">0</span> || dirlink(ip, <span class="hljs-string">&quot;..&quot;</span>, dp-&gt;inum) &lt; <span class="hljs-number">0</span>)<br>      panic(<span class="hljs-string">&quot;create dots&quot;</span>);<br>  &#125;<br><br>  <span class="hljs-comment">// now that the data is initialized properly</span><br>  <span class="hljs-comment">// link it into the parent directory</span><br>  <span class="hljs-keyword">if</span>(dirlink(dp, name, ip-&gt;inum) &lt; <span class="hljs-number">0</span>)<br>    panic(<span class="hljs-string">&quot;create: dirlink&quot;</span>);<br><br>  iunlockput(dp);<br><br>  <span class="hljs-keyword">return</span> ip;<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li>有三种情况会用到 create:
<ul>
<li>open 使用 O_CREATE 模式创建一个新文件.</li>
<li>mkdir 创建一个新目录.</li>
<li>mkdev 创建一个新设备文件.</li>
</ul>
</li>
<li>create 会通过 dirlookup 查找要创建的 inode 的文件名是否已经存在于路径中. 如果存在, 则会根据语义的不同, 做出不同的处理:
<ul>
<li>如果 create 的上层调用是 open, 而且已存在的是普通文件或设备文件, 从 open 的定义来说这是合法的, 所以 create 将这种情况视作成功, 并直接返回已经存在的 inode.</li>
<li>如果 create 的上层调用是 mkdir 或 mkdev, 那么 create 将直接返回错误.</li>
</ul>
</li>
<li>该函数中虽然同时持有 dp 和 ip 的锁, 但是不会发生死锁, 因为 ip 是刚刚分配的, 除了当前调用 create 的线程, 没有其他线程会持有或是请求 ip 的锁.</li>
</ul>
<p>利用 create 很容易就能实现上层的 sys_open、sys_mkdir 和 sys_mknod 等系统调用接口.</p>
<p>sys_open 函数用于打开文件:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><code class="hljs c">uint64<br><span class="hljs-title function_">sys_open</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>  <span class="hljs-type">char</span> path[MAXPATH];<br>  <span class="hljs-type">int</span> fd, omode;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file</span> *<span class="hljs-title">f</span>;</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">inode</span> *<span class="hljs-title">ip</span>;</span><br>  <span class="hljs-type">int</span> n;<br><br>  <span class="hljs-keyword">if</span>((n = argstr(<span class="hljs-number">0</span>, path, MAXPATH)) &lt; <span class="hljs-number">0</span> || argint(<span class="hljs-number">1</span>, &amp;omode) &lt; <span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br><br>  begin_op();<br><br>  <span class="hljs-comment">// If open is passed the O_CREATE flag, it calls create</span><br>  <span class="hljs-keyword">if</span>(omode &amp; O_CREATE)&#123;<br>    ip = create(path, T_FILE, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">if</span>(ip == <span class="hljs-number">0</span>)&#123;<br>      end_op();<br>      <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// Otherwise, it calls namei</span><br>    <span class="hljs-keyword">if</span>((ip = namei(path)) == <span class="hljs-number">0</span>)&#123;<br>      end_op();<br>      <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-comment">// Create returns a locked inode, but namei does not, so sys_open must lock the inode itself.  </span><br>    ilock(ip);<br>    <span class="hljs-comment">// This provides a convenient place to check that directories are only opened for reading, not writing.</span><br>    <span class="hljs-keyword">if</span>(ip-&gt;type == T_DIR &amp;&amp; omode != O_RDONLY)&#123;<br>      iunlockput(ip);<br>      end_op();<br>      <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-keyword">if</span>(ip-&gt;type == T_DEVICE &amp;&amp; (ip-&gt;major &lt; <span class="hljs-number">0</span> || ip-&gt;major &gt;= NDEV))&#123;<br>    iunlockput(ip);<br>    end_op();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>  &#125;<br><br>  <span class="hljs-comment">// allocates a file and a file descriptor</span><br>  <span class="hljs-comment">// no other process can access the partially initialized file since it is only in the current process’s table.</span><br>  <span class="hljs-keyword">if</span>((f = filealloc()) == <span class="hljs-number">0</span> || (fd = fdalloc(f)) &lt; <span class="hljs-number">0</span>)&#123;<br>    <span class="hljs-keyword">if</span>(f)<br>      fileclose(f);<br>    iunlockput(ip);<br>    end_op();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>  &#125;<br><br>  <span class="hljs-keyword">if</span>(ip-&gt;type == T_DEVICE)&#123;<br>    f-&gt;type = FD_DEVICE;<br>    f-&gt;major = ip-&gt;major;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    f-&gt;type = FD_INODE;<br>    f-&gt;off = <span class="hljs-number">0</span>;<br>  &#125;<br>  f-&gt;ip = ip;<br>  f-&gt;readable = !(omode &amp; O_WRONLY);<br>  f-&gt;writable = (omode &amp; O_WRONLY) || (omode &amp; O_RDWR);<br><br>  <span class="hljs-keyword">if</span>((omode &amp; O_TRUNC) &amp;&amp; ip-&gt;type == T_FILE)&#123;<br>    itrunc(ip);<br>  &#125;<br><br>  iunlock(ip);<br>  end_op();<br><br>  <span class="hljs-keyword">return</span> fd;<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li>对于 sys_open, 如果调用 open 时设置了 O_CREATE 模式, 那么将调用 create; 否则, open 默认打开一个现有的文件, 因此调用 namei.</li>
<li>create 返回上锁的 inode, 而 namei 返回的 inode 并不上锁, 所以还需要显式地调用 ilock.</li>
<li>无论 ip 是由 create 新分配的, 还是用 namei 打开的, sys_open 都会调用 filealloc 分配一个打开文件, 然后调用 fdalloc 分配一个文件描述符.</li>
</ul>
<p>sys_pipe 用于创建管道:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c">uint64<br><span class="hljs-title function_">sys_pipe</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>  uint64 fdarray; <span class="hljs-comment">// user pointer to array of two integers</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file</span> *<span class="hljs-title">rf</span>, *<span class="hljs-title">wf</span>;</span><br>  <span class="hljs-type">int</span> fd0, fd1;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">p</span> =</span> myproc();<br><br>  <span class="hljs-comment">// int p[2]</span><br>  <span class="hljs-comment">// pipe(p)，a0寄存器是数组p[2]</span><br>  <span class="hljs-keyword">if</span>(argaddr(<span class="hljs-number">0</span>, &amp;fdarray) &lt; <span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>  <span class="hljs-keyword">if</span>(pipealloc(&amp;rf, &amp;wf) &lt; <span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>  fd0 = <span class="hljs-number">-1</span>;<br>  <span class="hljs-comment">// 分配两个新的文件描述符fd0和fd1</span><br>  <span class="hljs-keyword">if</span>((fd0 = fdalloc(rf)) &lt; <span class="hljs-number">0</span> || (fd1 = fdalloc(wf)) &lt; <span class="hljs-number">0</span>)&#123;<br>    <span class="hljs-comment">// 异常处理</span><br>    <span class="hljs-keyword">if</span>(fd0 &gt;= <span class="hljs-number">0</span>)<br>      p-&gt;ofile[fd0] = <span class="hljs-number">0</span>;<br>    fileclose(rf);<br>    fileclose(wf);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>  &#125;<br>  <span class="hljs-comment">// 将两个文件描述符fd0和fd1拷贝回数组p[2]中</span><br>  <span class="hljs-keyword">if</span>(copyout(p-&gt;pagetable, fdarray, (<span class="hljs-type">char</span>*)&amp;fd0, <span class="hljs-keyword">sizeof</span>(fd0)) &lt; <span class="hljs-number">0</span> ||<br>     copyout(p-&gt;pagetable, fdarray+<span class="hljs-keyword">sizeof</span>(fd0), (<span class="hljs-type">char</span> *)&amp;fd1, <span class="hljs-keyword">sizeof</span>(fd1)) &lt; <span class="hljs-number">0</span>)&#123;<br>    p-&gt;ofile[fd0] = <span class="hljs-number">0</span>;<br>    p-&gt;ofile[fd1] = <span class="hljs-number">0</span>;<br>    fileclose(rf);<br>    fileclose(wf);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li>调用该函数时, 需要传入一个容纳两个整型的数组作为参数 (用于保存生成的管道的读写端的文件描述符).</li>
<li>在该函数中, 会调用 pipealloc 创建一个新的管道并创建和初始化代表管道读写端的打开文件结构 rf 和 wf.</li>
</ul>
<p>sys_pipe 中所调用的 pipealloc 函数实现如下:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span><br><span class="hljs-title function_">pipealloc</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> file **f0, <span class="hljs-keyword">struct</span> file **f1)</span><br>&#123;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pipe</span> *<span class="hljs-title">pi</span>;</span><br><br>  pi = <span class="hljs-number">0</span>;<br>  *f0 = *f1 = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">if</span>((*f0 = filealloc()) == <span class="hljs-number">0</span> || (*f1 = filealloc()) == <span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">goto</span> bad;<br>  <span class="hljs-keyword">if</span>((pi = (<span class="hljs-keyword">struct</span> pipe*)kalloc()) == <span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">goto</span> bad;<br>  pi-&gt;readopen = <span class="hljs-number">1</span>;<br>  pi-&gt;writeopen = <span class="hljs-number">1</span>;<br>  pi-&gt;nwrite = <span class="hljs-number">0</span>;<br>  pi-&gt;nread = <span class="hljs-number">0</span>;<br>  initlock(&amp;pi-&gt;lock, <span class="hljs-string">&quot;pipe&quot;</span>);<br>  (*f0)-&gt;type = FD_PIPE;<br>  (*f0)-&gt;readable = <span class="hljs-number">1</span>;<br>  (*f0)-&gt;writable = <span class="hljs-number">0</span>;<br>  (*f0)-&gt;pipe = pi;<br>  (*f1)-&gt;type = FD_PIPE;<br>  (*f1)-&gt;readable = <span class="hljs-number">0</span>;<br>  (*f1)-&gt;writable = <span class="hljs-number">1</span>;<br>  (*f1)-&gt;pipe = pi;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br> bad:<br>  <span class="hljs-keyword">if</span>(pi)<br>    kfree((<span class="hljs-type">char</span>*)pi);<br>  <span class="hljs-keyword">if</span>(*f0)<br>    fileclose(*f0);<br>  <span class="hljs-keyword">if</span>(*f1)<br>    fileclose(*f1);<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="现代文件系统">现代文件系统</h2>
<p>现代操作系统的 Buffer Cache 比 xv6 的要更复杂, 但有两个理念是相同的: 缓存和同步. xv6 的缓存维护和换出策略是 LRU, 然而还有更多的复杂策略, 每种策略都在某种工作负载上有不错的表现. 一个更有效率的 LRU 缓存不使用链表, 而是使用哈希表和堆来完成查找和换出. 更常见的缓存类型是将虚拟内存页面和文件系统页面集成到统一页面缓存中, 以便支持内存映射文件.</p>
<p>xv6 的日志系统存在不少缺陷:</p>
<ul>
<li>xv6 中使用数据日志, 而数据日志往往不够高效, 因为数据和元数据都要被写入磁盘两次.</li>
<li>xv6 在执行系统调用时就不能提交日志, 这限制了程序的并发性.</li>
<li>在 xv6 中, 即使只有几个字节需要更新, 也要将整个数据块写入日志.</li>
<li>在 xv6 中, 写入日志和加检查点时, 一次只能将一个块写入磁盘, 而每次写入磁盘都需要寻道, 从而导致高定位成本.</li>
</ul>
<p>现代操作系统的日志系统更为高效和完善, 解决了上述缺陷.</p>
<p>xv6 的文件系统是类 UNIX 文件系统, 它的磁盘布局和 UNIX 的非常相似. BSD 的 UFS 和FFS、Linux 的 ext2 和 ext3 都以这种布局和相关数据结构为基础. 但是 UNIX 文件系统因为目录结构导致效率较低.</p>
<ul>
<li>例如: 每次在目录中查找文件 / 目录时, 需要线性地扫描一遍所有目录项. 如果目录只有很少条目, 这并不会导致多大的问题, 但是对于一个拥有很多文件的目录来说, 这显然需要一定的时间成本.</li>
</ul>
<p>因此, Windows 的 NTFS、Mac OS X 的 HFS、Solaris 的 ZFS 等文件系统, 使用 B 树这种数据结构来构建目录层次结构, 这虽然会增加程序的复杂度, 但是查找目录时只需要对数级别的时间复杂度.</p>
<p>xv6 对于磁盘错误的处理过于简单, 它只会陷入 panic. 这种方式是否合理, 取决于底层硬件. 如果操作系统是在特殊硬件 (如 RAID) 上构建的, 那么即使偶尔会出现磁盘错误, 操作系统也能利用冗余备份进行一些恢复操作; 而在普通磁盘上构建的操作系统, 这会影响文件系统正常部分的使用.</p>
<p>xv6 的文件系统只挂载在一个磁盘设备上, 且大小是固定的. 这种设计无法满足数据库、多媒体文件驱动器等存储量大的实例的需求. 一种基本的思想是: 将多个磁盘组合成一个逻辑磁盘. 虽然 RAID 是目前最热门的硬件解决方案, 但是发展趋势是使用软件来解决, 例如通过动态添加或删除磁盘来增大或缩小逻辑设备, 此时文件系统动态地调整各个组件 (如 inode 块、数据块等) 的大小.</p>
<p>xv6 的文件系统缺少很多现代文件系统具备的特性, 如磁盘快照、定期备份等.</p>
<p>现代的 UNIX 文件系统允许系统调用像访问本地磁盘一样, 访问更多类型的资源如命名管道、网络套接字、网络文件系统、监视和控制接口等, 它们为打开文件提供一系列的函数指针, 利用这些函数指针可以调用各个子系统的功能.</p>
<h2 id="Reference">Reference</h2>
<section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>MIT 6.S081 Operating System Engineering: <a target="_blank" rel="noopener" href="https://pdos.csail.mit.edu/6.S081/2020/schedule.html">https://pdos.csail.mit.edu/6.S081/2020/schedule.html</a>
<a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span>xv6: a simple, Unix-like teaching operating system: <a target="_blank" rel="noopener" href="https://pdos.csail.mit.edu/6.S081/2020/xv6/book-riscv-rev1.pdf">https://pdos.csail.mit.edu/6.S081/2020/xv6/book-riscv-rev1.pdf</a>
<a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:3" class="footnote-text"><span>Chapter 8: File System Ⅰ: <a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/353830216">https://zhuanlan.zhihu.com/p/353830216</a>
<a href="#fnref:3" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:4" class="footnote-text"><span>Chapter 8: File System Ⅱ: <a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/354099893">https://zhuanlan.zhihu.com/p/354099893</a>
<a href="#fnref:4" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:5" class="footnote-text"><span>Chapter 8: File System Ⅲ: <a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/353830885">https://zhuanlan.zhihu.com/p/353830885</a>
<a href="#fnref:5" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:6" class="footnote-text"><span>Chapter 8: File System Ⅳ: <a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/356030867">https://zhuanlan.zhihu.com/p/356030867</a>
<a href="#fnref:6" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:7" class="footnote-text"><span>Chapter 8: File System Ⅴ: <a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/357513530">https://zhuanlan.zhihu.com/p/357513530</a>
<a href="#fnref:7" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:8" class="footnote-text"><span>Linux/Unix 系统编程手册
<a href="#fnref:8" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>
                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/%E7%AC%94%E8%AE%B0/" class="category-chain-item">笔记</a>
  
  
    <span>></span>
    
  <a href="/categories/%E7%AC%94%E8%AE%B0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" class="category-chain-item">操作系统</a>
  
  

  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/MIT-6-S081/" class="print-no-link">#MIT 6.S081</a>
      
        <a href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" class="print-no-link">#操作系统</a>
      
        <a href="/tags/Xv6/" class="print-no-link">#Xv6</a>
      
    </div>
  
</div>


              

              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2024/07/04/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/" title="系统调用">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">系统调用</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2024/07/04/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E9%94%81/" title="锁">
                        <span class="hidden-mobile">锁</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  


  
  








    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
