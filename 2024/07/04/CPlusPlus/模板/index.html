

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=light>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/bg/3.png">
  <link rel="icon" href="/img/bg/3.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Wangrd">
  <meta name="keywords" content="">
  
    <meta name="description" content="模板 类模板 类模板是 C++ 中一种通用的类定义形式, 允许创建可以适用于多种数据类型的类, 这些类型参数可以在类实例化时被指定为具体的数据类型. 类模板的定义形式如下所示: 1234template &lt;typename T&gt;class ClassName &#123;	...&#125;  在上述定义中, T 是一个类型参数, 可以在类中用于表示一个通用的数据类型. 当我们实例化类">
<meta property="og:type" content="article">
<meta property="og:title" content="C++ 模板">
<meta property="og:url" content="http://example.com/2024/07/04/CPlusPlus/%E6%A8%A1%E6%9D%BF/index.html">
<meta property="og:site_name" content="Wangrd&#39;s Blog">
<meta property="og:description" content="模板 类模板 类模板是 C++ 中一种通用的类定义形式, 允许创建可以适用于多种数据类型的类, 这些类型参数可以在类实例化时被指定为具体的数据类型. 类模板的定义形式如下所示: 1234template &lt;typename T&gt;class ClassName &#123;	...&#125;  在上述定义中, T 是一个类型参数, 可以在类中用于表示一个通用的数据类型. 当我们实例化类">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2024-07-04T10:58:11.000Z">
<meta property="article:modified_time" content="2024-09-16T05:07:29.124Z">
<meta property="article:author" content="Wangrd">
<meta property="article:tag" content="C++">
<meta name="twitter:card" content="summary_large_image">
  
  
  
  <title>C++ 模板 - Wangrd&#39;s Blog</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.9.7","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 7.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Wangrd&#39;s Blog</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/bg/1.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="C++ 模板"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2024-07-04 18:58" pubdate>
          2024年7月4日 晚上
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          7.4k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          62 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">C++ 模板</h1>
            
            
              <div class="markdown-body">
                
                <h1>模板</h1>
<h2 id="类模板">类模板</h2>
<p>类模板是 C++ 中一种通用的类定义形式, 允许创建可以适用于多种数据类型的类, 这些类型参数可以在类实例化时被指定为具体的数据类型.</p>
<p>类模板的定义形式如下所示:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ClassName</span> &#123;<br>	...<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li>在上述定义中, <code>T</code> 是一个类型参数, 可以在类中用于表示一个通用的数据类型. 当我们实例化类模板时, <strong>需要指定 <code>T</code> 的具体数据类型</strong>, 这样编译器会根据指定的类型生成一个具体的类.</li>
</ul>
<p>例如:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">complex</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>	<span class="hljs-built_in">complex</span> (T r = <span class="hljs-number">0</span>, T i = <span class="hljs-number">0</span>)<br>		: <span class="hljs-built_in">re</span> (r), <span class="hljs-built_in">im</span> (i)<br>	&#123; &#125;<br>	complex&amp; <span class="hljs-keyword">operator</span> += (<span class="hljs-type">const</span> complex&amp;);<br>	<span class="hljs-function">T <span class="hljs-title">real</span> <span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> re; &#125;<br>	<span class="hljs-function">T <span class="hljs-title">imag</span> <span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> im; &#125;<br><span class="hljs-keyword">private</span>:<br>	T re, im;<br><br>	<span class="hljs-keyword">friend</span> complex&amp; __doapl (complex*, <span class="hljs-type">const</span> complex&amp;);<br>&#125;;<br><br>&#123;<br>	...<br>	<span class="hljs-function">complex&lt;<span class="hljs-type">double</span>&gt; <span class="hljs-title">c1</span><span class="hljs-params">(<span class="hljs-number">2.5</span>, <span class="hljs-number">1.5</span>)</span></span>;<br>	<span class="hljs-function">complex&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">c2</span><span class="hljs-params">(<span class="hljs-number">2</span>, <span class="hljs-number">6</span>)</span></span>;<br>	...<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="typename">typename</h3>
<p><code>typename</code> 是C++ 中的一个关键字. 在用于泛型编程时是另一术语 <code>class</code> 的同义词. <strong>这个关键字用于指出模板声明 (或定义) 中的非独立名称是类型名, 而非变量名</strong>.</p>
<p><strong>由来</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fun</span><span class="hljs-params">(<span class="hljs-type">const</span> T&amp; proto)</span></span>&#123;<br>	<span class="hljs-function">T::const_iterator <span class="hljs-title">it</span><span class="hljs-params">(proto.begin())</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li>以上代码无法通过编译, 因为在模板实例化之前, 编译器不知道 <code>T::const_iterator</code> 是一个类型还是一个变量.</li>
</ul>
<p>为了解决上述问题, 引入了关键字 <code>typename</code>.</p>
<p><strong>用法</strong><br>
对于<strong>用模板定义的依赖于模板参数的名称</strong>, 只有在实例化后的参数中存在这个类型名, 或者这个名称前使用了 <code>typename</code> 关键字来修饰, 编译器才会将该名称当成是一个类型.</p>
<p>所以对于上述代码, 只需要在 <code>T::const_iterator</code> 之前用 <code>typename</code> 修饰即可:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">typename</span> T::const_iterator <span class="hljs-title">it</span><span class="hljs-params">(proto.begin())</span></span>;<br></code></pre></td></tr></table></figure>
<ul>
<li>这样编译器就可以确定 <code>T::const_iterator</code> 是一个类型, 而不再需要等到实例化, 因此解决了前面的问题.</li>
</ul>
<h2 id="函数模板">函数模板</h2>
<p>函数模板是 C++ 中一种通用的函数定义形式, 允许创建可以适用于多种数据类型的函数. 它允许在函数中使用一个或多个类型参数, 这些类型参数可以在函数调用时被指定为具体的数据类型.</p>
<p>函数模板的定义形式如下所示:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-function">return_type <span class="hljs-title">function_name</span><span class="hljs-params">(parameters)</span> </span>&#123;<br>	...<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li>在上述定义中, <code>T</code> 是一个类型参数, 可以在函数中用于表示一个通用的数据类型. 当我们调用函数模板时, <strong>不需要指定 <code>T</code> 的具体数据类型</strong>, 编译器会对函数模板进行引数推导 (arguement deduction).</li>
</ul>
<p>例如:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">stone</span> &#123;<br> <span class="hljs-keyword">public</span>:<br>	<span class="hljs-built_in">stone</span> (<span class="hljs-type">int</span> w, <span class="hljs-type">int</span> h, <span class="hljs-type">int</span> we)<br>		: _w(w), _h(h), _weight(we)<br>		&#123; &#125;<br><br>	<span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span> &lt; (<span class="hljs-type">const</span> stone&amp; rhs) <span class="hljs-type">const</span> &#123; <span class="hljs-keyword">return</span> _weight &lt; rhs._weight; &#125;<br><br> <span class="hljs-keyword">private</span>:<br>	<span class="hljs-type">int</span> _w, _h, _weight;<br>&#125;;<br><br><span class="hljs-comment">// 函数模板定义</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-function"><span class="hljs-keyword">inline</span></span><br><span class="hljs-function"><span class="hljs-type">const</span> T&amp; <span class="hljs-title">min</span><span class="hljs-params">(<span class="hljs-type">const</span> T&amp; a, <span class="hljs-type">const</span> T&amp; b)</span> </span>&#123;<br>	<span class="hljs-keyword">return</span> b &lt; a ? b : a;<br>&#125;<br><br>&#123;<br>	...<br>	<span class="hljs-function">stone <span class="hljs-title">r1</span><span class="hljs-params">(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">10</span>)</span>, <span class="hljs-title">r2</span><span class="hljs-params">(<span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-number">14</span>)</span>, r3</span>;<br>	r3 = <span class="hljs-built_in">min</span>(r1, r2); <span class="hljs-comment">// 调用函数模板</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>此外, 需要注意的是, <strong>函数模板的定义 (实现) 通常是需要放在头文件中的</strong>. 因为 C++ 的编译过程是基于翻译单元的, 每个 <code>.cpp</code> 文件是一个独立的翻译单元. 如果模板的定义 (实现) 只放在源文件中, 那么其他翻译单元在使用这个模板时将无法看到模板的定义. 而模板是在<strong>编译时</strong>实例化的, 编译器必须看到模版的完整定义, 才能根据具体类型实例化模板.</p>
<h2 id="成员模板">成员模板</h2>
<p>任意类 (模板或非模板) 可以拥有本身为类模板或函数模板的成员, 这种成员称为成员模板.</p>
<h3 id="定义成员模板">定义成员模板</h3>
<p>例如:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> _Tp&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">shared_ptr</span> : <span class="hljs-keyword">public</span> __shared_ptr&lt;_Tp&gt; &#123;<br>    ...<br><br>    <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> _Tp1&gt;<br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">shared_ptr</span><span class="hljs-params">(_Tp1* __p)</span></span><br><span class="hljs-function">        : __shared_ptr&lt;_Tp&gt;(__p)</span><br><span class="hljs-function">    &#123;</span> &#125;<br>    <br>    ...<br>&#125;;<br></code></pre></td></tr></table></figure>
<ul>
<li>这段代码是 C++ 标准库中 <code>shared_ptr</code> 类模板的部分实现.</li>
<li>这个类模板的构造函数使用模板参数 <code>_Tp1</code> 表示接受任何类型指针作为参数, 并将其转换为 <code>shared_ptr&lt;_Tp&gt;</code> 类型.</li>
</ul>
<h3 id="在类外部定义成员模板">在类外部定义成员模板</h3>
<p>像非模板成员一样, 成员模板可以定义在包含它的类或类模板定义的内部或外部.</p>
<p>例如:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt; <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Queue</span> &#123;<br> <span class="hljs-keyword">public</span>:<br>	<span class="hljs-comment">// 定义在类内部的成员模板</span><br>	<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">It</span>&gt;<br>    <span class="hljs-built_in">Queue</span>(It beg, It end)<br>	    : <span class="hljs-built_in">head</span>(<span class="hljs-number">0</span>), <span class="hljs-built_in">tail</span>(<span class="hljs-number">0</span>) <br>	&#123; <span class="hljs-built_in">copy_elems</span>(beg, end); &#125;<br><br>	<span class="hljs-comment">// 定义在类外部的成员模板</span><br>    <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">It</span>&gt; <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">assign</span><span class="hljs-params">(It, It)</span></span>;<br> <br> <span class="hljs-keyword">private</span>:<br>	<span class="hljs-comment">// 定义在类外部的成员模板</span><br>    <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">It</span>&gt; <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">copy_elems</span><span class="hljs-params">(It, It)</span></span>;<br>&#125;;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt; <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">It</span>&gt;  <br><span class="hljs-type">void</span> Queue&lt;T&gt;::<span class="hljs-built_in">assign</span>(It beg, It end) &#123;<br>    <span class="hljs-built_in">destroy</span>();<br>    <span class="hljs-built_in">copy_elems</span>(beg, end); <br>&#125;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt; <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">It</span>&gt;  <br><span class="hljs-type">void</span> Queue&lt;T&gt;::<span class="hljs-built_in">copy_elems</span>(It beg, It end) &#123; <br>	<span class="hljs-keyword">while</span> (beg != end) &#123;  <br>       <span class="hljs-built_in">push</span>(*beg);  <br>       ++beg;  <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li>当成员模板是类模板的成员时, 它的定义必须包含类模板形参以及自己的模板形参. 首先是类模板形参表, 后面接着成员自己的模板形参表, 例如上面的 <code>assign</code> 的 <code>template &lt;class T&gt; template &lt;class Iter&gt;</code></li>
</ul>
<p><strong>成员模板函数不能为虚函数</strong><br>
成员模板函数并不支持虚函数的特性. 原因如下:</p>
<p>虚函数的实现依赖于虚函数表, 该表在编译时生成, 并包含类的所有虚函数的指针. 每个对象都有一个指向对应虚函数表的指针, 用于在运行时决定调用哪个具体的虚函数, 这种动态绑定机制要求所有虚函数在编译时已经确定其签名. 而模板函数是泛型的, 在编译时并没有实际的函数代码, 而是一个模板定义. 只有在使用特定类型实例化模板时, 编译器才会生成相应的函数代码.</p>
<p>如果允许成员模板函数是虚函数, 每个类模板实例化 (使用不同类型参数时) 都会导致:</p>
<ul>
<li>不同的成员函数实现, 因为模板类型参数不同, 函数的具体实现也会不同.</li>
<li>不同的虚函数表项, 每个不同的成员模板函数可能需要在虚函数表中有单独的指针.</li>
</ul>
<p>这会导致以下问题:</p>
<ul>
<li>虚函数表的膨胀: 对于每个不同的模板实例化, 都可能需要生成不同的虚函数表项. 这将导致类的每个实例化版本都有自己的一套虚函数表, 这样会显著增加虚函数表的大小和复杂度.</li>
<li>维护难度: 编译器需要处理大量不同的虚函数表及其指针. 每个实例化的类都必须维护自己的一组虚函数表, 而不是共享通用的虚函数表, 这极大增加了管理的复杂性.</li>
</ul>
<p>从语言设计角度看, 这种复杂性和开销是不值得的, 尤其考虑到虚函数的主要目的是<strong>动态多态</strong>, 而模板的主要目的是<strong>编译期多态</strong>, 两者本质上服务于不同的目的.</p>
<p><strong>成员模板函数可以拥有默认模板参数</strong><br>
定义带有默认模板参数的成员函数模板时, 可以为其中的某些模板参数指定默认值. 这样, 当调用成员函数模板时, 如果没有显式地指定这些模板参数的值, 编译器会使用默认值来实例化模板函数.</p>
<p>例如:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 成员函数模板, 带有默认模板参数</span><br>    <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T = <span class="hljs-type">int</span>&gt;<br>    <span class="hljs-type">void</span> <span class="hljs-built_in">Print</span>(T value) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Value: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    MyClass obj;<br><br>    <span class="hljs-comment">// 使用默认模板参数 `int`</span><br>    obj.<span class="hljs-built_in">Print</span>();     <span class="hljs-comment">// 实例化为 void Print&lt;int&gt;(int value)</span><br><br>    <span class="hljs-comment">// 显式指定模板参数为 double</span><br>    obj.<span class="hljs-built_in">Print</span>(<span class="hljs-number">3.14</span>); <span class="hljs-comment">// 实例化为 void Print&lt;double&gt;(double value)</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="模板实例化">模板实例化</h2>
<p>模板的实例化指函数模板 (类模板) 生成模板函数 (模板类) 的过程. 对于函数模板而言, 模板实例化之后, 会生成一个真正的函数. 而类模板经过实例化之后, 只是完成了类的定义, 模板类的成员函数需要到调用时才会被初始化.</p>
<ul>
<li><strong>当你定义一个类模板并进行实例化后, 编译器只会生成类的框架和结构, 包括成员变量和成员函数的声明, 但实际的函数代码并不会立即被生成. 只有当你通过创建对象并调用类的成员函数时, 编译器才会根据实际的调用情况来生成相应的函数代码</strong>; 如果你只是对模板类进行实例化而没有调用其中的成员函数, 那么这些成员函数的具体定义不会被生成, 从而减少了不必要的编译时间和可执行文件大小.</li>
</ul>
<p><strong>无论是模板类的实例化还是模板函数的实例化, 都是发生在编译阶段.</strong> 在编译阶段, 编译器根据实际的模板参数类型, 生成特定类型的代码. 这些代码会被编译成目标代码, 并在链接阶段与其他代码一起构建最终的可执行文件.</p>
<p>模板的实例化分为隐式实例化和显示实例化:</p>
<ul>
<li><strong>隐式实例化</strong>: 这是相对于模板显示实例化而言. 在使用模板函数和模板类时, 不存在指定类型的模板函数和模板类的实体时, 由编译器根据指定类型参数隐式生成模板函数或者模板类的实体称之为模板的隐式实例化.
<ul>
<li><strong>函数模板隐式实例化</strong>: 函数模板隐式实例化指的是在发生函数调用的时候, 如果没有发现相匹配的函数存在, 编译器就会寻找同名函数模板, 如果可以成功进行参数类型推演, 就对函数模板进行实例化; 还有一种简介调用函数的情况, 也可以完成函数模板的实例化. 所谓的简介调用是指将函数入口地址传给一个函数指针, 通过函数指针完成函数调用. 如果传递给函数指针不是一个真正的函数, 那么编译器就会寻找同名的函数模板进行参数推演, 进而完成函数模板的实例化. 例如:  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(T t)</span> </span>&#123;<br>	cout &lt;&lt; t &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">invoke</span><span class="hljs-params">(<span class="hljs-type">void</span> (*p)(<span class="hljs-type">int</span>))</span> </span>&#123;<br>	<span class="hljs-type">int</span> num = <span class="hljs-number">10</span>;<br>	<span class="hljs-built_in">p</span>(num);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>	<span class="hljs-built_in">invoke</span>(func); <span class="hljs-comment">// 函数模板隐式实例化</span><br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><strong>类模板隐式实例化</strong>: 类模板隐式实例化指的是在使用模板类时才将模板实例化. 例如:  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123;<br> <span class="hljs-keyword">public</span>:<br>	<span class="hljs-built_in">A</span>(T input)<br>		: <span class="hljs-built_in">num</span>(input)<br>	&#123; &#125;<br><br>	<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>		cout &lt;&lt; num &lt;&lt; endl;<br>	&#125;<br><br> <span class="hljs-keyword">private</span>:<br>	T num;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>	<span class="hljs-function">A&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">a</span><span class="hljs-params">(<span class="hljs-number">5</span>)</span></span>; <span class="hljs-comment">// 类模板隐式实例化</span><br>	a.<span class="hljs-built_in">print</span>();<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><strong>显示实例化</strong>: 显示实例化也称为外部实例化. 在不发生函数调用的时候将函数模板实例化或者在不使用类模板的时候将类模板实例化称之为模板显示实例化.
<ul>
<li><strong>函数模板的显示实例化</strong>: 对于函数模板而言, 不管是否发生函数调用, 都可以通过显示实例化声明将函数模板实例化. 例如:  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> <span class="hljs-type">void</span> <span class="hljs-built_in">func</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-type">const</span> <span class="hljs-type">int</span>&amp;);<br></code></pre></td></tr></table></figure>
</li>
<li><strong>类模板的显示实例化</strong>: 对于类模板而言, 不管是否生成一个模板类的对象, 都可以直接通过显示实例化声明将类模板实例化. 例如:  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">theClass</span>&lt;<span class="hljs-type">int</span>&gt;;<br></code></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<p>对函数模板而言, 分为两种调用方式, 一种是显示模板实参调用 (显示调用), 一种是隐式模板实参调用 (隐式调用):</p>
<ul>
<li><strong>隐式模板实参调用</strong>: 在发生函数模板的调用时, 不显示给出模板参数而经过参数推演, 称之为函数模板的隐式模板实参调用. 例如:  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(T t)</span> </span>&#123;<br>	cout &lt;&lt; t &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>	<span class="hljs-built_in">func</span>(<span class="hljs-number">5</span>); <span class="hljs-comment">// 隐式模板实参调用</span><br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><strong>显式模板实参调用</strong>: 在发生函数模板的调用时, 显示给出模板参数而不需要经过参数推演, 称之为函数模板的显示模板实参调用. 例如:  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function">T <span class="hljs-title">myMax</span><span class="hljs-params">(<span class="hljs-type">const</span> T&amp; t1, <span class="hljs-type">const</span> T&amp; t2)</span> </span>&#123;<br>	<span class="hljs-keyword">return</span> (t1 &gt; t2) ? t1 : t2;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>	<span class="hljs-type">int</span> i = <span class="hljs-number">5</span>;<br>	cout &lt;&lt; <span class="hljs-built_in">myMax</span>&lt;<span class="hljs-type">int</span>&gt;(i, <span class="hljs-string">&#x27;A&#x27;</span>) &lt;&lt; endl; <span class="hljs-comment">// 显示模板实参调用</span><br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li>直接采用函数调用 <code>myMax(i, 'A')</code> 会产生编译错误, 因为 <code>i</code> 和 <code>A</code> 具有不同的数据类型, 无法根据这两个参数进行类型推演. 而采用 <code>myMax&lt;int&gt;(i, 'A')</code> 调用后, 函数模板的实例化不需要经过参数推演, 而函数的第二个实参也可以由 <code>char</code> 转换为 <code>int</code> 型, 从而成功完成函数调用.</li>
</ul>
</li>
</ul>
<p>对于类模板而言, 没有隐式模板实参和显式模板实参调用的说法, 因为类模板的使用必须显示指明模板实参.</p>
<h2 id="模板特化">模板特化</h2>
<p>模板特化 (Template Specialization) 不同于模板的实例化, <strong>模板参数在某种特定类型下的具体实现称为模板特化</strong>. 模板特化有时也称之为模板的具体化, 分别有函数模板特化和类模板特化.</p>
<h3 id="函数模板特化">函数模板特化</h3>
<p>函数模板特化指函数模板在模板参数为特定类型下的特定实现. 例如:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt; </span><br><span class="hljs-function">T <span class="hljs-title">myMax</span><span class="hljs-params">(T t1, T t2)</span> </span>&#123;<br>	<span class="hljs-keyword">return</span> (t1 &gt; t2) ? t1 : t2;<br>&#125;<br><br><span class="hljs-comment">/* 函数模板特化 */</span><br><span class="hljs-keyword">template</span>&lt;&gt; <br>string <span class="hljs-built_in">myMax</span>&lt;string&gt;(string s1, string s2) &#123;<br>	<span class="hljs-keyword">return</span> s1.<span class="hljs-built_in">compare</span>(s2) ? s1 : s2;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>	<span class="hljs-comment">// 隐式调用函数模板</span><br>	<span class="hljs-type">int</span> i = <span class="hljs-built_in">myMax</span>(<span class="hljs-number">10</span>, <span class="hljs-number">5</span>);<br>	<br>	<span class="hljs-comment">// 显式调用特化版本</span><br>	string p = <span class="hljs-built_in">myMax</span>&lt;string&gt;(<span class="hljs-string">&quot;very&quot;</span>, <span class="hljs-string">&quot;good&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li>在上面的程序中, 如果不给出函数模板在 <code>T</code> 为 <code>string</code> 时的特化版本, 那么在比较两个字符串的大小时, 比较的是字符串的起始地址的大小, 而不是字符串的内容在字典序中的先后次序.</li>
</ul>
<p>除了定义函数模板特化版本外, 还可以直接给出模板函数在特定类型下的重载形式. 使用函数重载可以实现函数模板特化的功能, 也可以避免函数模板的特定实例的失效. 例如, 把上面的模板特化可以改成如下重载函数:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">string <span class="hljs-title">myMax</span><span class="hljs-params">(string s1, string s2)</span> </span>&#123;<br>	<span class="hljs-keyword">return</span> s1.<span class="hljs-built_in">compare</span>(s2) ? s1 : s2;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>但是, 使用普通函数重载和使用模板特化有不同之处:</p>
<ol>
<li>如果使用普通重载函数, 那么不管是否发生实际的函数调用, 都会在目标文件中生成该函数的二进制代码; 而如果使用模板的特化版本, 除非发生函数调用, 否则不会在目标文件中包含特化模板函数的二进制代码. 这符合函数模板的 “惰性实例化” 准则.</li>
<li>如果使用普通重载函数, 那么在分离编译模式下, 需要在各个源文件中包含重载函数的申明, 否则在某些源文件中就会使用模板函数, 而不是重载函数.</li>
</ol>
<h3 id="类模板特化">类模板特化</h3>
<p>类模板特化类似于函数模板的特化, 即类模板参数在某种特定类型下的具体实现. 例如:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123;<br> <span class="hljs-keyword">public</span>:<br>	<span class="hljs-built_in">A</span>(T input)<br>		: <span class="hljs-built_in">num</span>(input)<br>	&#123; &#125;<br><br>	<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>		cout &lt;&lt; <span class="hljs-string">&quot;A normal definition: &quot;</span> &lt;&lt; num &lt;&lt; endl;<br>	&#125;<br><br> <span class="hljs-keyword">private</span>:<br>	T num;<br>&#125;;<br><br><span class="hljs-comment">/* 类模板特化 */</span><br><span class="hljs-keyword">template</span> &lt;&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>&lt;string&gt; &#123;<br> <span class="hljs-keyword">public</span>:<br>	<span class="hljs-built_in">A</span>(string input)<br>		: <span class="hljs-built_in">num</span>(input)<br>	&#123; &#125;<br><br>	<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>		cout &lt;&lt; <span class="hljs-string">&quot;A special definition: &quot;</span> &lt;&lt; num &lt;&lt; endl;<br>	&#125;<br><br> <span class="hljs-keyword">private</span>:<br>	string num;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>	<span class="hljs-function">A&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">a1</span><span class="hljs-params">(<span class="hljs-number">4</span>)</span></span>; <span class="hljs-comment">//类模板隐式实例化</span><br>	a1.<span class="hljs-built_in">print</span>();   <span class="hljs-comment">// 输出: A normal definition: 4</span><br><br>	<span class="hljs-function">A&lt;string&gt; <span class="hljs-title">a2</span><span class="hljs-params">(<span class="hljs-string">&quot;hi&quot;</span>)</span></span>; <span class="hljs-comment">// 使用特化的类模板</span><br>	a2.<span class="hljs-built_in">print</span>();         <span class="hljs-comment">// 输出: A special definition: hi</span><br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="模板偏特化">模板偏特化</h2>
<p>模板偏特化 (Template Partitial Specialization) 是模板特化的一种特殊情况, 指显示指定部分模板参数而非全部模板参数 (从指定多个模板参数到指定部分模板参数, 指定的模板参数的个数减小, 这是一种 “偏”) 或者指定模板参数的部分特性而非全部特性 (模板参数的范围从大范围到小范围, 如原来可以是任意类型, 现在缩小到指针类型, 这也是一种 “偏”), 也称为模板部分特化. 与模板偏特化相对的是模板全特化, 指对所有模板参数进行特化. 模板全特化与模板偏特化共同组成模板特化.</p>
<p>模板偏特化主要分为两种: 一种是指对部分模板参数进行全特化, 另一种是对模板参数特性进行特化, 包括将模板参数特化为指针、引用或是另外一个模板类.</p>
<p>函数模板不允许偏特化. 例如, 下面的声明会报错:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 模板函数</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T1</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">T2</span>&gt;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span> </span>&#123; &#125;<br><br><span class="hljs-comment">// 偏特化模板函数 (编译错误)</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T2</span>&gt;<br><span class="hljs-type">void</span> <span class="hljs-built_in">f</span>&lt;<span class="hljs-type">int</span>, T2&gt;() &#123; &#125;<br></code></pre></td></tr></table></figure>
<p>但函数允许重载, 声明另一个函数模板即可替代偏特化的需要:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 新的函数模板</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T2</span>&gt;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span> </span>&#123; &#125;<br></code></pre></td></tr></table></figure>
<h3 id="类模板偏特化">类模板偏特化</h3>
<p>类模板的偏特化如下所示:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span> </span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">// 类模板</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">class</span> <span class="hljs-title class_">N</span>&gt; <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TestClass</span> &#123;<br> <span class="hljs-keyword">public</span>:<br>	<span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">bool</span> <span class="hljs-title">comp</span><span class="hljs-params">(T num1, N num2)</span> </span>&#123;<br>		cout &lt;&lt; <span class="hljs-string">&quot;Standard class template&quot;</span> &lt;&lt; endl;<br>		<span class="hljs-keyword">return</span> (num1 &lt; num2) ? <span class="hljs-literal">true</span> : <span class="hljs-literal">false</span>;<br>	&#125;<br>&#125;;<br><br><span class="hljs-comment">// 对部分模板参数进行特化</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">N</span>&gt; <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TestClass</span>&lt;<span class="hljs-type">int</span>, N&gt; &#123;<br> <span class="hljs-keyword">public</span>:<br>	<span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">bool</span> <span class="hljs-title">comp</span><span class="hljs-params">(<span class="hljs-type">int</span> num1, N num2)</span> </span>&#123;<br>		cout &lt;&lt; <span class="hljs-string">&quot;Partitial specialization&quot;</span> &lt;&lt; endl;<br>		<span class="hljs-keyword">return</span> (num1 &lt; num2) ? <span class="hljs-literal">true</span> : <span class="hljs-literal">false</span>;<br>	&#125;<br>&#125;;<br><br><span class="hljs-comment">// 将模板参数特化为指针</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">class</span> <span class="hljs-title class_">N</span>&gt; <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TestClass</span>&lt;T*, N*&gt; &#123;<br> <span class="hljs-keyword">public</span>:<br>	<span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">bool</span> <span class="hljs-title">comp</span><span class="hljs-params">(T* num1, N* num2)</span> </span>&#123;<br>		cout &lt;&lt; <span class="hljs-string">&quot;New partitial specialization&quot;</span> &lt;&lt; endl;<br>		<span class="hljs-keyword">return</span> (*num1 &lt; *num2) ? <span class="hljs-literal">true</span> : <span class="hljs-literal">false</span>;<br>	&#125;<br>&#125;;<br><br><span class="hljs-comment">// 将模板参数特化为另一个模板类</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">class</span> <span class="hljs-title class_">N</span>&gt; <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TestClass</span>&lt;vector&lt;T&gt;,vector&lt;N&gt;&gt; &#123;<br> <span class="hljs-keyword">public</span>:<br>	<span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">bool</span> <span class="hljs-title">comp</span><span class="hljs-params">(<span class="hljs-type">const</span> vector&lt;T&gt;&amp; vecLeft, <span class="hljs-type">const</span> vector&lt;N&gt;&amp; vecRight)</span> </span>&#123;<br>		cout &lt;&lt; <span class="hljs-string">&quot;To vector partitial specialization&quot;</span> &lt;&lt; endl;<br>		<span class="hljs-keyword">return</span> (vecLeft.<span class="hljs-built_in">size</span>() &lt; vecRight.<span class="hljs-built_in">size</span>()) ? <span class="hljs-literal">true</span> : <span class="hljs-literal">false</span>;<br>	&#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>	<span class="hljs-comment">// 调用非偏特化版本</span><br>	cout &lt;&lt; TestClass&lt;<span class="hljs-type">char</span>, <span class="hljs-type">char</span>&gt;::<span class="hljs-built_in">comp</span>(<span class="hljs-string">&#x27;0&#x27;</span>, <span class="hljs-string">&#x27;1&#x27;</span>) &lt;&lt; endl;	<br>	<br>	<span class="hljs-comment">// 调用部分模板参数偏特化版本</span><br>	cout &lt;&lt; TestClass&lt;<span class="hljs-type">int</span>,<span class="hljs-type">char</span>&gt;::<span class="hljs-built_in">comp</span>(<span class="hljs-number">30</span>, <span class="hljs-string">&#x27;1&#x27;</span>) &lt;&lt; endl;		<br><br>	<span class="hljs-comment">// 调用模板参数偏特化为指针版本</span><br>	<span class="hljs-type">int</span> a = <span class="hljs-number">30</span>;<br>	<span class="hljs-type">char</span> c = <span class="hljs-string">&#x27;1&#x27;</span>;<br>	cout &lt;&lt; TestClass&lt;<span class="hljs-type">int</span>*, <span class="hljs-type">char</span>*&gt;::<span class="hljs-built_in">comp</span>(&amp;a, &amp;c) &lt;&lt; endl;<br><br>	<span class="hljs-comment">// 调用模板参数特化为另一个模板类的偏特化版本</span><br>	vector&lt;<span class="hljs-type">int</span>&gt; vecLeft&#123;<span class="hljs-number">0</span>&#125;;<br>	vector&lt;<span class="hljs-type">int</span>&gt; vecRight&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;;<br>	cout &lt;&lt; TestClass&lt;vector&lt;<span class="hljs-type">int</span>&gt;, vector&lt;<span class="hljs-type">int</span>&gt;&gt;::<span class="hljs-built_in">comp</span>(vecLeft,vecRight) &lt;&lt; endl;	<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="模板类调用优先级">模板类调用优先级</h2>
<p>对主版本模板类、全特化类、偏特化类的调用优先级从高到低进行排序是: 全特化类 &gt; 偏特化类 &gt; 主版本模板类. 这样的优先级顺序对性能也是最好的. 但是模板特化并不只是为了性能优化, 更多是为了让模板函数能够正常工作.</p>
<h2 id="模板模板参数">模板模板参数</h2>
<p>模板模板参数是一种高级模板技术, 它允许你在模板参数中传递另一个模板作为参数.</p>
<p>通常, 我们在模板中使用类、基本数据类型或其他模板类作为模板参数. 但是, 有时我们希望传递的参数本身是一个模板, 而不是一个具体的类型.</p>
<p>以 <code>Stack</code> 类为例, 为了使用不同的内部容器, 必须两次指定元素类型, 即传递容器类型和它的元素类型:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">Stack&lt;<span class="hljs-type">int</span>, std::vector&lt;<span class="hljs-type">int</span>&gt;&gt; vStack;<br></code></pre></td></tr></table></figure>
<p>使用模板作为模板参数可以仅指定容器类型而不需要再次指定元素类型:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">Stack&lt;<span class="hljs-type">int</span>, std::vector&gt; vStack;<br></code></pre></td></tr></table></figure>
<p>为此必须指定第二个模板参数为模板:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T, <br>	<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Elem, <span class="hljs-keyword">typename</span> ALLOC = std::allocator&lt;ELEM&gt;&gt; <br>	<span class="hljs-keyword">class</span> Count = std::deque<br>	&gt;<br><span class="hljs-keyword">class</span> Stack &#123;<br> <span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">void</span> <span class="hljs-built_in">push</span>(<span class="hljs-type">const</span> T&amp;);<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">const</span> T&amp; <span class="hljs-title">top</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> elems.<span class="hljs-built_in">empty</span>();   <br>    &#125;<br>    ...<br><br> <span class="hljs-keyword">private</span>:<br>	Cont&lt;T&gt; elems;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>其中 <code>template &lt;typename Elem, typename ALLOC = std::allocator&lt;ELEM&gt;&gt; class Cont</code> 由第一个模板参数进行实例化:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">Cont&lt;T&gt; elems;<br></code></pre></td></tr></table></figure>
<p>第一个模板参数用于第二个模板参数的实例化仅仅是特例, 可以用类模板内的任何类型来实例化模板的模板参数</p>
<p>在 C++17 之后, 允许用关键字 <code>typename</code> 来代替 <code>class</code> 用于声明模板的模板参数:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T,<br>	<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Elem, <span class="hljs-keyword">typename</span> ALLOC = std::allocator&lt;ELEM&gt;&gt;<br>	<span class="hljs-keyword">typename</span> Cont = std::deque<br>	&gt;	<br><span class="hljs-keyword">class</span> Stack &#123;<br>	...<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>由于 <code>Cont</code> 模板的模板参数没有被使用, 所以可以不使用它的名字:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T,<br>	<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span>, <span class="hljs-keyword">typename</span> = std::alloctor&lt;T&gt;&gt;<br>	<span class="hljs-keyword">class</span> Cont = std::deque<br>	&gt;<br><span class="hljs-keyword">class</span> Stack &#123;<br>	...<br>&#125;;<br><br><span class="hljs-comment">// 类外成员函数定义</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T, <br>	<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span>, <span class="hljs-keyword">typename</span> = std::alloctor&lt;T&gt;&gt;<br>	<span class="hljs-keyword">class</span> Cont = std::deque<br>	&gt;<br><span class="hljs-type">void</span> Stack&lt;T, Cont&gt;::<span class="hljs-built_in">push</span>(<span class="hljs-type">const</span> T&amp; elem) &#123;<br>	elems.<span class="hljs-built_in">push_back</span>(elem);<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="可变参数模板">可变参数模板</h2>
<p>可变参数模板是支持任意数量的参数的模板类或模板函数.</p>
<p>可变数目的参数被称为参数包. 存在两种参数包:</p>
<ul>
<li><strong>模板参数包</strong>, 用于保存一组类型. 它的主要作用是定义和存储类型, 而不直接涉及到值.</li>
<li><strong>函数参数包</strong>, 包含一组实际的参数值. 在函数定义中, 函数参数包与模板参数包相对应, 并在实际调用时接收对应类型的值.</li>
</ul>
<p>可变参数模板以两种方式使用省略号 (…) .  <strong>在参数名称的左侧, 表示 “参数包”; 在参数名称的右侧, 表示将参数包扩展为单独的名称.</strong></p>
<p>例如:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span>... Args&gt;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">(<span class="hljs-type">const</span> Args&amp;... args)</span></span>;<br></code></pre></td></tr></table></figure>
<ul>
<li><code>foo</code> 是一个可变参数函数模板, 其中 <code>... Args</code> 表示 <code>Args</code> 是一个模板参数包.</li>
<li><code>const Args&amp;... args</code> 这里发生了两件事情:
<ul>
<li>扩展 <code>Args</code>: <code>Args</code> 是一个模板参数包, 由于 <code>...</code> 位于其右边, 表示将其扩展为参数列表.</li>
<li>打包 <code>args</code>: 由于 <code>...</code> 在 <code>args</code> 的左边, 所以表明 <code>args</code> 是一个函数参数包, 此时会将传入的参数打包成一个函数参数包 <code>args</code>.</li>
</ul>
</li>
</ul>
<p>编译器从函数的实参推断模板参数类型. 对于一个可变参数模板, 编译器还会推断包中的参数的数目. 例如:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br><span class="hljs-type">double</span> d = <span class="hljs-number">3.14</span>;<br>string s = <span class="hljs-string">&quot;hello&quot;</span>;<br><span class="hljs-built_in">foo</span>(i, s, <span class="hljs-number">42</span>, d);   <span class="hljs-comment">// 包中有四个参数</span><br><span class="hljs-built_in">foo</span>(s, <span class="hljs-number">42</span>, <span class="hljs-string">&quot;hi&quot;</span>);   <span class="hljs-comment">// 包中有三个参数</span><br><span class="hljs-built_in">foo</span>(d, s);          <span class="hljs-comment">// 包中有两个参数</span><br></code></pre></td></tr></table></figure>
<p>通过修改可变参数函数模板定义, 还可以要求至少有一个参数:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span>... Args&gt;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">(<span class="hljs-type">const</span> T&amp; first, <span class="hljs-type">const</span> Args&amp;... rest)</span></span>;<br></code></pre></td></tr></table></figure>
<p>当我们需要知道包中有多少元素时, 可以使用 <code>sizeof…()</code> 运算符. 例如:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span>... Args&gt;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">(Args... args)</span> </span>&#123;<br>    cout &lt;&lt; <span class="hljs-keyword">sizeof</span>...(Args) &lt;&lt; endl;    <span class="hljs-comment">// 类型参数的数目</span><br>    cout &lt;&lt; <span class="hljs-keyword">sizeof</span>...(args) &lt;&lt; endl;    <span class="hljs-comment">// 函数参数的数目</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">foo</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2.0</span>, <span class="hljs-number">3.0</span>, <span class="hljs-string">&quot;hi&quot;</span>);   <span class="hljs-comment">// 4, 4</span><br>    <span class="hljs-built_in">foo</span>(<span class="hljs-string">&quot;hi&quot;</span>, <span class="hljs-string">&quot;hello&quot;</span>);       <span class="hljs-comment">// 2, 2</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="递归展开包">递归展开包</h3>
<p>参数包可以使用递归来展开. 假设我们要定义一个 <code>print</code> 函数, 它将实参列表的内容打印到一个给定流上. 为了终止递归, 我们还需要定义一个非可变参数的 <code>print</code> 函数, 它接受一个流和一个对象:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 用来终止递归并打印最后一个元素的函数</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function">ostream&amp; <span class="hljs-title">print</span><span class="hljs-params">(ostream&amp; os, <span class="hljs-type">const</span> T&amp; t)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> os &lt;&lt; t;<br>&#125;<br><br><span class="hljs-comment">// 包中除了最后一个元素之外的其他元素都会调用这个版本的 `print`</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span>... Args&gt;<br><span class="hljs-function">ostream&amp; <span class="hljs-title">print</span><span class="hljs-params">(ostream&amp; os, <span class="hljs-type">const</span> T&amp; t, <span class="hljs-type">const</span> Args&amp;... rest)</span> </span>&#123;<br>    os &lt;&lt; t &lt;&lt; <span class="hljs-string">&quot;,&quot;</span> &lt;&lt; endl;     <span class="hljs-comment">// 打印第一个实参</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">print</span>(os, rest...);  <span class="hljs-comment">// 递归调用, 打印其他实参</span><br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="逗号表达式展开包">逗号表达式展开包</h3>
<p>参数包展开还可以使用逗号表达式来展开. 例如:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print_item</span><span class="hljs-params">(T arg)</span> </span>&#123;<br>    std::cout &lt;&lt; arg &lt;&lt; <span class="hljs-string">&quot;, &quot;</span>;<br>&#125;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span>... T&gt;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">expand</span><span class="hljs-params">(T... args)</span> </span>&#123;<br>    <span class="hljs-type">int</span> arr[] = &#123;(<span class="hljs-built_in">print_item</span>(args), <span class="hljs-number">0</span>)...&#125;; <span class="hljs-comment">// 逗号表达式</span><br>    std::cout &lt;&lt; std::endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">expand</span>(<span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-string">&quot;ddd&quot;</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>回顾一下逗号表达式 <code>a = (b = c, d)</code>, 表达式的执行顺序是: 先进行 <code>b = c</code> 的赋值, 接着括号中的逗号表达式返回 <code>d</code>, 因此最终 <code>a</code> 等于 <code>d</code>.</p>
<p>所以上面的例子中, <code>int arr[] = &#123; (print_item(args), 0)... &#125;;</code> 语句, 其实核心部分是这一句 <code>(print_item(args), 0)</code>, 先指定 <code>print_item()</code> 函数, 然后逗号表达式返回 <code>0</code>; 然后利用初始化列表来初始化一个初值都是 <code>0</code> 、大小为 <code>sizeof...(args)</code> 的数组 (这个数组 <code>arr[]</code> 只是用来驱动 <code>print_item</code> 的调用, 并且数组的内容在这个场景下无关紧要). 通过初始化列表, 最终展开为:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> arr[] = &#123;<br>    (<span class="hljs-built_in">print_item</span>(args0), <span class="hljs-number">0</span>),<br>    (<span class="hljs-built_in">print_item</span>(args1), <span class="hljs-number">0</span>),<br>    (<span class="hljs-built_in">print_item</span>(args2), <span class="hljs-number">0</span>),<br>    ...<br>&#125;;<br></code></pre></td></tr></table></figure>
<h3 id="折叠表达式">折叠表达式</h3>
<p>之前提到的展开参数包的方式过于繁琐, 为了能够更好地解包, 在 C++17 标准中引入了折叠表达式.</p>
<p>折叠表达式有 4 种语法形式:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp">(pack op ...) <span class="hljs-comment">// 一元右折叠</span><br><br>(... op pack) <span class="hljs-comment">// 一元左折叠</span><br><br>(pack op ... op init) <span class="hljs-comment">// 二元右折叠</span><br><br>(init op ... op pack) <span class="hljs-comment">// 二元左折叠</span><br><br></code></pre></td></tr></table></figure>
<ul>
<li><code>op</code> 指运算符, 折叠表达式支持以下 32 个二元运算符:  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">`+`, `-`, `*`, `/`, `%`, `^`, `&amp;`, `|`, `=`, `&lt;`, `&gt;`, `&lt;&lt;`, `&gt;&gt;`, `+=`, `-=`, `*=`, `/=`, `%=`, `^=`, `&amp;=`, `|=`, `&lt;&lt;=`, `&gt;&gt;=`, `==`, `!=`, `&lt;=`, `&gt;=`, `&amp;&amp;`, `||`, `,`, `.*`, `-&gt;*`<br></code></pre></td></tr></table></figure>
且所有 <code>op</code> 操作符必须相同.</li>
<li><code>pack</code> 含有未展开的参数包, 且在顶层不含优先级低于转型表达式的运算符的表达式.</li>
<li><code>init</code> 不含未展开的参数包, 且在顶层不含优先级低于转型表达式的运算符的表达式.</li>
<li><code>...</code> 是折叠标记.</li>
</ul>
<h4 id="一元折叠">一元折叠</h4>
<p>一元折叠分为一元右折叠和一元左折叠.</p>
<p>假设表达式是 <code>E</code> (包含参数包), 操作符是 <code>op</code>:</p>
<ul>
<li>一元右折叠<br>
形如 <code>(E op ...)</code> 的折叠表达式称为一元右折叠, 一元右折叠展开之后的含义是 <code>(E1 op (... op (En-1 op En)))</code>.</li>
<li>一元左折叠<br>
形如 <code>(... op E)</code> 的折叠表达式称为一元左折叠, 一元左折叠展开之后的含义是 <code>(((E1 op E2) op ...) op En)</code>.</li>
</ul>
<p>最简单的折叠表达式是一个求和函数:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 一元右折叠</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span>... T&gt;<br><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">sumR</span><span class="hljs-params">(T... args)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> (args + ...);<br>&#125;<br><br><span class="hljs-comment">// 一元左折叠</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span>... T&gt;<br><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">sumL</span><span class="hljs-params">(T... args)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> (... + args);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::cout &lt;&lt; <span class="hljs-built_in">sumR</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>) &lt;&lt; std::endl; <span class="hljs-comment">// 输出: 15</span><br>    std::cout &lt;&lt; <span class="hljs-built_in">sumL</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>) &lt;&lt; std::endl; <span class="hljs-comment">// 输出: 15</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li><code>sumR(1, 2, 3, 4, 5)</code> 右折叠展开后等价于 <code>1 + (2 + (3 + (4 + 5)))</code>.</li>
<li><code>sumL(1, 2, 3, 4, 5)</code> 左折叠展开后等价于 <code>(((1 + 2) + 3) + 4) + 5</code>.</li>
</ul>
<p>在这个例子中, 左右折叠对于加法和乘法的结果都是相等的; 但是有些情况下, 比如减法和除法, 左右折叠展开的结果是不同的, 要谨慎使用.</p>
<p>现在, 可以对上文中的例子可以用折叠表达式进行改写:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 一元右折叠</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span>... T&gt;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printR</span><span class="hljs-params">(T... args)</span> </span>&#123;<br>    ((std::cout &lt;&lt; args &lt;&lt; <span class="hljs-string">&quot;, &quot;</span>), ...) &lt;&lt; std::endl;<br>&#125;<br><br><span class="hljs-comment">// 一元左折叠</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span>... T&gt;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printL</span><span class="hljs-params">(T... args)</span> </span>&#123;<br>    (..., (std::cout &lt;&lt; args &lt;&lt; <span class="hljs-string">&quot;, &quot;</span>)) &lt;&lt; std::endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">printR</span>(<span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-string">&quot;ddd&quot;</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>);<br>    <span class="hljs-built_in">printL</span>(<span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-string">&quot;ddd&quot;</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>
<ul>
<li>在这个例子中, <code>op</code> 是逗号, <code>E</code> 是输出语句 <code>std::cout &lt;&lt; args &lt;&lt; &quot;, &quot;</code>, 所以其实是一个逗号表达式的折叠表达式.</li>
</ul>
<h4 id="二元折叠">二元折叠</h4>
<p>二元折叠分为二元右折叠和二元左折叠.</p>
<p>假设表达式是 <code>E</code> (包含参数包), 操作符是 <code>op</code> , 初值是 <code>I</code>:</p>
<ul>
<li>二元右折叠<br>
形如 <code>(E op ... op I)</code> 的折叠表达式称为二元右折叠, 二元右折叠展开之后的含义是 <code>(E1 op (... op (En-1 op (En op I))))</code>.</li>
<li>二元左折叠<br>
形如 <code>(I op ... op E)</code> 的折叠表达式称为二元左折叠, 二元左折叠展开之后的含义是<code>((((I op E1) op E2) op ...) op En)</code>.</li>
</ul>
<p>再看一下前面通过一元折叠表达式实现的累加函数, 这种实现已经可以满足大多数情况了, 但是有一种情况没法满足, 就是函数传递了空参数. 如果非要用一元折叠表达式实现, 且支持传递空参数, 那么需要对模板进行特化:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 一元右折叠</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span>... T&gt;<br><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">sumR</span><span class="hljs-params">(T... args)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> (args + ...);<br>&#125;<br><br><span class="hljs-keyword">template</span> &lt;&gt;<br><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">sumR</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; &#125;<br><br><span class="hljs-comment">// 一元左折叠</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span>... T&gt;<br><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">sumL</span><span class="hljs-params">(T... args)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> (... + args);<br>&#125;<br><br><span class="hljs-keyword">template</span> &lt;&gt;<br><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">sumL</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; &#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::cout &lt;&lt; <span class="hljs-built_in">sumR</span>() &lt;&lt; std::endl; <span class="hljs-comment">// 输出: 0</span><br>    std::cout &lt;&lt; <span class="hljs-built_in">sumL</span>() &lt;&lt; std::endl; <span class="hljs-comment">// 输出: 0</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>虽然可行, 但是还需要实现特化版本, 还是比较麻烦的. 更简单的方式是使用二元折叠表达式给定初值:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 二元右折叠表达式</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span>... T&gt;<br><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">sumR</span><span class="hljs-params">(T... args)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> (args + ... + <span class="hljs-number">0</span>);<br>&#125;<br><br><span class="hljs-comment">// 二元左折叠表达式</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span>... T&gt;<br><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">sumL</span><span class="hljs-params">(T... args)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> (<span class="hljs-number">0</span> + ... + args);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::cout &lt;&lt; <span class="hljs-built_in">sumR</span>() &lt;&lt; std::endl; <span class="hljs-comment">// 输出: 0</span><br>    std::cout &lt;&lt; <span class="hljs-built_in">sumL</span>() &lt;&lt; std::endl; <span class="hljs-comment">// 输出: 0</span><br>    std::cout &lt;&lt; <span class="hljs-built_in">sumR</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>) &lt;&lt; std::endl; <span class="hljs-comment">// 输出: 15</span><br>    std::cout &lt;&lt; <span class="hljs-built_in">sumL</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>) &lt;&lt; std::endl; <span class="hljs-comment">// 输出: 15</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>如此一来, 只需要定义一个模板函数即可, 不需要定义特化版本, 就可以实现传空参数的累加求和.</p>
<h2 id="Reference">Reference</h2>
<section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>STL和泛型编程 (侯捷): <a target="_blank" rel="noopener" href="https://www.youtube.com/playlist?list=PLTcwR9j5y6W2Bf4S-qi0HBQlHXQVFoJrP">https://www.youtube.com/playlist?list=PLTcwR9j5y6W2Bf4S-qi0HBQlHXQVFoJrP</a>
<a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span>深入理解特化与偏特化: <a target="_blank" rel="noopener" href="https://sg-first.gitbooks.io/cpp-template-tutorial/content/jie_te_hua_yu_pian_te_hua.html">https://sg-first.gitbooks.io/cpp-template-tutorial/content/jie_te_hua_yu_pian_te_hua.html</a>
<a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:3" class="footnote-text"><span>C++17折叠表达式: <a target="_blank" rel="noopener" href="https://zhxilin.github.io/post/tech_stack/1_programming_language/modern_cpp/cpp17/fold_expressions/">https://zhxilin.github.io/post/tech_stack/1_programming_language/modern_cpp/cpp17/fold_expressions/</a>
<a href="#fnref:3" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>
                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/%E7%AC%94%E8%AE%B0/" class="category-chain-item">笔记</a>
  
  
    <span>></span>
    
  <a href="/categories/%E7%AC%94%E8%AE%B0/CPlusPlus/" class="category-chain-item">CPlusPlus</a>
  
  

  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/C/" class="print-no-link">#C++</a>
      
    </div>
  
</div>


              

              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2024/07/04/CPlusPlus/%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/" title="C++ 强制类型转换">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">C++ 强制类型转换</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2024/07/04/CPlusPlus/%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4/" title="C++ 命名空间">
                        <span class="hidden-mobile">C++ 命名空间</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
