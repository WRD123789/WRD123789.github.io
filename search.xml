<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>并发</title>
    <url>/2024/07/03/%E5%B9%B6%E5%8F%91/</url>
    <content><![CDATA[<h1>并发</h1>
<h2 id="Pthreads-API">Pthreads API</h2>
<p>Pthreads 是 POSIX 标准定义的线程创建与同步 API, 它是线程行为的规范, 而不是实现. 但大多数操作系统都实现了这个线程规范, 并为用户级别的线程同步提供了互斥锁、条件变量、读写锁等接口实现, 我们只需要在用户程序中包含 <strong>pthread.h</strong> 这个库, 就可以方便地使用这些接口.</p>
<ul>
<li>
<p>以下是一个用户级多线程程序, 对于 Pthreads 程序, 独立线程是通过特定函数执行的 (这里为 runner 函数), 原来进程只有一个执行线程, 在 main 中创建了第二个线程, 该线程就从 runner 开始执行, 两个线程共享全局数据:</p>
  <figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-type">int</span> sum; <span class="hljs-comment">/* this data is shared by the thread(s)*/</span><br><span class="hljs-function"><span class="hljs-type">void</span> *<span class="hljs-title">runner</span><span class="hljs-params">(<span class="hljs-type">void</span> *param)</span></span>; <span class="hljs-comment">/* threads call this function */</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-type">pthread_t</span> tid; <span class="hljs-comment">/* the thread identifier */</span><br>	<span class="hljs-type">pthread_attr_t</span> attr; <span class="hljs-comment">/* set of thread attributes */</span><br><br>	<span class="hljs-comment">/* set the default attributes of the thread */</span><br>	<span class="hljs-built_in">pthread_attr_init</span>(&amp;attr);<br>	<span class="hljs-comment">/* create the thread */</span><br>	<span class="hljs-built_in">pthread_create</span>(&amp;tid, &amp;attr, runner, argv[<span class="hljs-number">1</span>]);<br>	<span class="hljs-comment">/* wait for the thread to exit */</span><br>	<span class="hljs-built_in">pthread_join</span>(tid, <span class="hljs-literal">NULL</span>);<br><br>	<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;sum = %d\n&quot;</span>, sum);<br>&#125;<br><br><span class="hljs-comment">/* The thread will execute in this function */</span><br><span class="hljs-function"><span class="hljs-type">void</span> *<span class="hljs-title">runner</span><span class="hljs-params">(<span class="hljs-type">void</span> *param)</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-type">int</span> i, upper = <span class="hljs-built_in">atoi</span>(param);<br>	sum = <span class="hljs-number">0</span>;<br><br>	<span class="hljs-keyword">for</span> (i = <span class="hljs-number">1</span>; i &lt;= upper; i++)<br>	&#123;<br>		sum += i;<br>	&#125;<br>	<span class="hljs-built_in">pthread_exit</span>(<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li>pthread_t 时线程的标识符类型, 和进程标识符类型相似, 每个线程都对应一个.</li>
<li>pthread_attr_t 是线程属性类型, 通常我们使用默认属性即可.</li>
<li>pthread_create 创建了一个新的线程, 从左往右传递的四个参数分别是: 线程标识符、线程属性、执行函数名、执行函数的参数 (可以打包更多的参数, 通过结构体传入).</li>
<li>在执行完 pthread_create 后, 原进程中有两个执行线程, 一个是原始线程 (也称主线程) main, 另一个是新的执行线程 (也称子线程) runner. 主线程通过 pthread_join 原地阻塞地等待子线程工作的完成, 子线程调用 pthread_exit 终止自身. 默认情况下 pthread_exit 不会释放子线程的资源, 而是由主线程的 pthread_join 回收子线程资源. 当然, 子线程也可以自己调用 pthread_detach 使它与主线程分离, 之后子线程再通过 pthread_exit 退出时, 资源会自动回收, 此时主线程不再需要阻塞地等待子线程.</li>
</ul>
</li>
<li>
<p>我们也可以创建多个线程:</p>
  <figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> NUM_THREADS 10</span><br><br><span class="hljs-comment">/* an array of threads to be joined upon */</span><br><span class="hljs-type">pthread_t</span> workers[NUM_THREADS];<br><br><span class="hljs-type">pthread_attr_t</span> attr;<br>pthread_attr_init(&amp;attr);<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; NUM_THREADS; i++)<br>  pthread_create(&amp;workers[i], &amp;attr, runner, <span class="hljs-literal">NULL</span>);<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; NUM_THREADS; i++)<br>  pthread_join(workers[i], <span class="hljs-literal">NULL</span>);<br><br><span class="hljs-type">void</span> *<span class="hljs-title function_">runner</span><span class="hljs-params">()</span>&#123; &#125;<br></code></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="条件变量">条件变量</h2>
<p>在很多情况下,  线程需要检查某一条件满足之后,  才能继续运行. 最简单的方法是,  使用一个共享变量,  让线程在循环中检查该变量,  直到满足条件时继续执行. 显然该线程会自旋地检查,  浪费 CPU 资源,  因此我们希望,  在线程需要的某个条件不满足时,  有某种方式能让该线程睡眠,  直到等待的条件满足,  再将其唤醒.</p>
<p>线程可以使用<strong>条件变量</strong>,  来等待一个条件变为真. 条件变量是一个显式队列,  当某些执行状态不满足时,  线程可以将自己加入该队列并睡眠；当其它线程改变了该执行状态,  使得条件变为满足,  那么就可以唤醒一个或者多个在队列中等待的线程,  从而让它们继续执行.</p>
<ul>
<li>我们依然用 Pthreads API 来演示,  我们前面只演示了使用该 API 进行多线程编程,  现在我们展示其互斥锁、条件变量接口的使用:  <figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-type">int</span> done = <span class="hljs-number">0</span>;<br><span class="hljs-type">pthread_mutex_t</span> m = PTHREAD_MUTEX_INITIALIZER;  <br><span class="hljs-comment">// 初始化, 也可以用pthread_mutex_init(&amp;m,  NULL)</span><br>pthread_cond_c c = PTHREAD_COND_INITIALIZER;    <br><span class="hljs-comment">// 初始化, 也可以用pthread_cond_init(&amp;c,  NULL)</span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">thr_exit</span><span class="hljs-params">()</span>&#123;<br>  pthread_mutex_lock(&amp;m);<br>  done = <span class="hljs-number">1</span>;<br>  pthread_cond_signal(&amp;c);<br>  pthread_mutex_unlock(&amp;m);<br>&#125;<br><br><span class="hljs-type">void</span> *<span class="hljs-title function_">child</span><span class="hljs-params">()</span>&#123;<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;child\n&quot;</span>);<br>  thr_exit();<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">thr_join</span><span class="hljs-params">()</span>&#123;<br>  pthread_mutex_lock(&amp;m);<br>  <span class="hljs-keyword">while</span>(done == <span class="hljs-number">0</span>)<br>    pthread_cond_wait(&amp;c,  &amp;m);<br>  pthread_mutex_unlock(&amp;m);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;parent: begin\n&quot;</span>);<br>  <span class="hljs-type">pthread_t</span> p;<br>  pthread_create(&amp;p,  <span class="hljs-literal">NULL</span>,  child,  <span class="hljs-literal">NULL</span>);<br>  thr_join();<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;parent: end\n&quot;</span>);<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li><strong>条件变量应该配合互斥锁使用</strong>,  我们用 pthread_mutex_t 声明了一个互斥锁,  用 pthread_cond_t 声明了一个条件变量. 条件变量有两种操作,  wait 和 signal. 线程通过调用 wait 睡眠; 另一个线程通过 signal 唤醒某个睡眠的线程.</li>
<li>pthread_cond_wait 需要传入互斥锁 m 和条件变量 c. 它假定在调用该函数时, 锁 m 已经被该线程持有. 那么 wait 做的事情就是释放锁 m, 然后让调用线程睡眠. 当线程被唤醒时, wait 为该线程重新获取锁 m, 再从 wait 返回到调用者.</li>
<li>pthread_cond_signal 传入条件变量 c, 唤醒等待线程.</li>
<li>上述程序可能有两种执行顺序:
<ol>
<li>主线程创建了子线程之后, 首先运行 thr_join, 发现条件 done 不满足后, 调用 wait 睡眠, 稍后子线程运行并完成工作后, 条件 done 满足, 调用 thr_exit 从而调用 signal 唤醒主线程; 主线程被唤醒, 从 wait 调用返回并且持有锁, 然后运行后释放锁.</li>
<li>子线程被创建后首先运行, 条件 done 满足, 调用 signal 唤醒其它线程 (这里没有其它线程, 并不会失败, 只是照常返回), 然后子线程结束; 主线程运行, 调用 thr_join 发现条件 done 满足, 于是直接返回.</li>
</ol>
</li>
<li>上述程序中状态变量 done 时必须的. 假设去掉状态变量 done:  <figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">thr_exit</span><span class="hljs-params">()</span>&#123;<br>  pthread_mutex_lock(&amp;m);<br>  pthread_cond_signal(&amp;c);<br>  pthread_mutex_unlock(&amp;m);<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">thr_join</span><span class="hljs-params">()</span>&#123;<br>  pthread_mutex_lock(&amp;m);<br>  pthread_cond_wait(&amp;c, &amp;m);<br>  pthread_mutex_unlock(&amp;m);<br>&#125;<br></code></pre></td></tr></table></figure>
假设子线程被创建后立刻执行, 因此调用 thr_exit, 子线程调用 signal 发送信号给条件变量 c 来唤醒其他线程, 由于没有其他线程在 c 上睡眠, 所以直接返回; 然后主线程调用 thr_join, 调用 wait 睡眠, 由于没有其他线程会唤醒它, 主线程将一直处于睡眠状态.</li>
<li>互斥锁是必须的, 假设去掉互斥锁:  <figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">thr_exit</span><span class="hljs-params">()</span>&#123;<br>  done = <span class="hljs-number">1</span>;<br>  pthread_cond_signal(&amp;c);<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">thr_join</span><span class="hljs-params">()</span>&#123;<br>  <span class="hljs-keyword">while</span>(done == <span class="hljs-number">0</span>)<br>    pthread_cond_wait(&amp;c, &amp;m);<br>&#125;<br></code></pre></td></tr></table></figure>
这里会产生竞争条件: 假设主线程先调用 thr_join, 由于检测到 done 不满足, 因此准备调用 wait 睡眠, 在调用 wait 之前时间片耗尽, 此时子线程开始执行, 子线程修改 done, 然后调用 signal, 由于没有线程在 c 上睡眠, 所以子线程直接返回, 然后主线程继续执行, 调用 wait, 由于没有其他线程唤醒它, 它将一直处于睡眠状态. 所以在使用条件变量时, 调用 signal 和 wait 时都要持有锁 (虽然有时候调用 signal 时不一定要持有锁, 但是应当尽量持有锁以保证程序的正确性).</li>
<li>条件变量 signal 应该唤醒多少线程? 考虑一种情况: 当前没有空闲内存可供分配, 线程 A 希望分配 100 个单位的内存, 而线程 B 只希望分配 10 个单位的内存, 它们检查了条件不满足之后, 都在同一个条件变量上睡眠. 这时, 假设线程 C 释放了 50 个单位的内存, 然后调用 signal 发信号准备唤醒等待线程. 此时可能先唤醒 A, 发现内存不足后继续睡眠, 而 B 则一直睡眠. 所以只唤醒一个等待线程是不可取的. 可以用 pthread_cond_broadcast 代替 pthread_cond_signal 来唤醒所有的等待线程. 这样确保了所有应该被唤醒的线程都被唤醒, 但是这可能会影响性能. 这种条件变量被称为<strong>覆盖条件</strong>, 因为它能覆盖所有需要唤醒线程的场景, 这显然是一种相当保守的策略. 一般有更好的方法 (例如使用多个条件变量), 所以如果你发现你的代码只有改成广播信号才能正确工作时, 可能是程序存在缺陷.</li>
<li>在唤醒线程中, cond_signal 和 unlock 的顺序其实可以互换, 但是由于性能, 在 Linux 环境下编程时推荐 cond_signal 放在 unlock 之前.</li>
</ul>
</li>
</ul>
<h2 id="信号量">信号量</h2>
<p><strong>信号量</strong>是一个有整数值的对象, 和条件变量类似, 可以用两个函数 wait 和 signal 来操作它, 而我们使用 POSIX 标准的命名: sem_wait 和 sem_post.</p>
<ul>
<li>创建一个信号量:  <figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;semaphore.h&gt;</span></span><br><span class="hljs-type">sem_t</span> s;<br>sem_init(&amp;s, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure>
<ul>
<li>创建一个信号量只需要调用 sem_init, 向其传入信号量指针、共享级别的标志和信号量的初始值即可. 第二个参数我们设置为 0, 表示信号量在同一进程的多个线程之间是共享的. 初始值设置为 1, 表示这是一个二值信号量 (二值信号量类似于互斥锁, 在没有提供互斥锁的操作系统上, 我们可以用二值信号量来提供互斥).</li>
</ul>
</li>
<li>下面用伪代码来展示 sem_wait 和 sem_post 的行为:  <figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">sem_wait</span><span class="hljs-params">(<span class="hljs-type">sem_t</span> *s)</span>&#123;<br>  s-&gt;value--;<br>  <span class="hljs-keyword">if</span>(s-&gt;value &lt; <span class="hljs-number">0</span>)&#123;<br>    add this thread/process to S-&gt;<span class="hljs-built_in">list</span>;<br>    block() or <span class="hljs-title function_">sleep</span><span class="hljs-params">()</span><br>  &#125;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">sem_post</span><span class="hljs-params">(<span class="hljs-type">sem_t</span> *s)</span>&#123;<br>  s-&gt;value++;<br>  <span class="hljs-keyword">if</span>(S-&gt;<span class="hljs-built_in">list</span>)  <span class="hljs-comment">// 有一个或多个进程/线程在等待</span><br>  &#123;<br>    remove a thread/process P from S-&gt;<span class="hljs-built_in">list</span><br>    <span class="hljs-title function_">wakeup</span><span class="hljs-params">(P)</span>; <br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li>sem_wait 要么立刻返回 (调用时 S <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≥</mo></mrow><annotation encoding="application/x-tex">\geq</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719em;vertical-align:-0.136em;"></span><span class="mrel">≥</span></span></span></span> 1), 要么会让调用线程睡眠 (调用时 S &lt; 1), 直到之后的一个 sem_post 操作</li>
<li>sem_post 直接增加信号量的值, 如果有线程在队列中等待, 就唤醒其中一个. 当 S 为负数时, |S| 就是在队列中等待线程的数量.</li>
</ul>
</li>
</ul>
<p><strong>用信号量构建条件变量</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;semaphore.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-type">sem_t</span> c;<br><br><span class="hljs-type">void</span> *<span class="hljs-title function_">child</span><span class="hljs-params">()</span>&#123;<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;child\n&quot;</span>);<br>  sem_post(&amp;c);<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br>  sem_init(&amp;c, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);  <span class="hljs-comment">// 信号量初始值为0</span><br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;parent:begin\n&quot;</span>);<br>  <span class="hljs-type">pthread_t</span> p;<br>  pthread_create(&amp;p, <span class="hljs-literal">NULL</span>, child, <span class="hljs-literal">NULL</span>);<br>  sem_wait(&amp;c);<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;parent:end\n&quot;</span>);<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li>此例中信号量实际上充当条件变量的作用, 而且还省去了定义全局状态变量的需要.</li>
<li>此程序有两种运行顺序:
<ol>
<li>创建子线程后, 子线程先运行, 打印 child 并调用 sem_post 使得 S = 1, 然后退出. 主线程调用 sem_wait 时由于 S = 1, 所以继续执行.</li>
<li>主线程先执行, 调用 sem_wait 时由于 S = 0, 所以 S = -1, 主线程睡眠; 子线程执行, 答应 child 并调用 sem_post 使 S = 0 并唤醒主线程, 主线程继续执行.</li>
</ol>
</li>
</ul>
<p>同样可以<strong>用互斥锁和条件变量来实现信号量</strong>:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sem_t</span>&#123;</span><br>  <span class="hljs-type">int</span> value;<br>  <span class="hljs-type">pthread_cond_t</span> cond;<br>  <span class="hljs-type">pthread_mutex_t</span> lock;<br>&#125;<span class="hljs-type">sem_t</span><br><br><span class="hljs-comment">// 只能由一个线程来初始化</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">sem_init</span><span class="hljs-params">(<span class="hljs-type">sem_t</span> *s, <span class="hljs-type">int</span> value)</span>&#123;<br>  s-&gt;value = value<br>  pthread_cond_init(&amp;s-&gt;cond, <span class="hljs-literal">NULL</span>)<br>  pthread_mutex_init(&amp;s-&gt;lock, <span class="hljs-literal">NULL</span>)<br>&#125;<br><br><span class="hljs-type">void</span> sem_wait(<span class="hljs-type">sem_t</span> *s)&#123;<br>  pthread_mutex_lock(&amp;s-&gt;lock);<br>  <span class="hljs-keyword">while</span>(s-&gt;value &lt;= <span class="hljs-number">0</span>)<br>    pthread_cond_wait(&amp;s-&gt;cond, &amp;s-&gt;lock);<br>  s-&gt;value--;<br>  pthread_mutex_unlock(&amp;s-&gt;lock);<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">sem_post</span><span class="hljs-params">(<span class="hljs-type">sem_t</span> *s)</span>&#123;<br>  pthread_mutex_lock(&amp;s-&gt;lock);<br>  s-&gt;value++;<br>  pthread_cond_signal(&amp;s-&gt;cond);<br>  pthread_mutex_unlock(&amp;s-&gt;lock);<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="同步示例">同步示例</h2>
<h3 id="有界缓冲区问题">有界缓冲区问题</h3>
<p>假设我们有一个缓冲池, 它是有界的, 一共有 n 个缓冲区, 每个缓冲区可存一个数据项, 现在有大量的生产者和消费者进程 (或线程), 它们会不间断地、并发地访问这个缓冲池, 以写入新数据或取走旧数据, 我们要保证整个并发的过程有序地运行.</p>
<p>对于该问题有两种解决方案 (我们的解决方案是基于同一个进程内多个线程的并发模型来实现的):</p>
<ul>
<li><strong>使用条件变量 + 互斥锁实现</strong>  <figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;pthread.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-type">int</span> buffer[MAX];<br><span class="hljs-type">int</span> fill_ptr = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> use_ptr = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> count = <span class="hljs-number">0</span>;<br><br><span class="hljs-type">pthread_cond_t</span> empty, fill;<br><span class="hljs-type">pthread_mutex_t</span> mutex;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">put</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span>&#123;<br>  buffer[fill_ptr] = value;<br>  fill_ptr = (fill_ptr + <span class="hljs-number">1</span>) % MAX;<br>  count++;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">get</span><span class="hljs-params">()</span>&#123;<br>  <span class="hljs-type">int</span> tmp = buffer[use_ptr];<br>  use_ptr = (use_ptr + <span class="hljs-number">1</span>) % MAX;<br>  count--;<br>  <span class="hljs-keyword">return</span> tmp;<br>&#125;<br><br><span class="hljs-type">void</span> *<span class="hljs-title function_">producer</span><span class="hljs-params">()</span>&#123;<br>  <span class="hljs-type">int</span> i;<br>  <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; loops; i++)&#123;<br>    pthread_mutex_lock(&amp;mutex);<br>    <span class="hljs-keyword">while</span>(count == MAX)<br>      pthread_cond_wait(&amp;empty, &amp;mutex);<br>    put(i);<br>    pthread_cond_signal(&amp;fill);<br>    pthread_mutex_unlock(&amp;mutex);<br>  &#125; <br>&#125;<br><br><span class="hljs-type">void</span> *<span class="hljs-title function_">consumer</span><span class="hljs-params">()</span>&#123;<br>  <span class="hljs-type">int</span> i;<br>  <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; loops; i++)&#123;<br>    pthread_mutex_lock(&amp;mutex);<br>    <span class="hljs-keyword">while</span>(count == <span class="hljs-number">0</span>)<br>      pthread_cond_wait(&amp;fill, &amp;mutex);<br>    <span class="hljs-type">int</span> tmp = get();<br>    pthread_cond_signal(&amp;empty);<br>    pthread_mutex_unlock(&amp;mutex);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,tmp)<br>  &#125; <br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br>  <span class="hljs-comment">// ...</span><br>  pthread_mutex_init(&amp;mutex, <span class="hljs-literal">NULL</span>);<br>  pthread_cond_init(&amp;empty, <span class="hljs-literal">NULL</span>);<br>  pthread_cond_init(&amp;fill, <span class="hljs-literal">NULL</span>);<br>  <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><strong>使用信号量实现</strong>  <figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;semaphore.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-type">int</span> buffer[MAX];<br><span class="hljs-type">int</span> fill = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> use = <span class="hljs-number">0</span>;<br><br><span class="hljs-type">sem_t</span> empty;<br><span class="hljs-type">sem_t</span> full;<br><span class="hljs-type">sem_t</span> mutex;<br> <br><span class="hljs-type">void</span> <span class="hljs-title function_">put</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span>&#123;<br>  buffer[fill] = value;<br>  fill = (fill + <span class="hljs-number">1</span>) % MAX;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">get</span><span class="hljs-params">()</span>&#123;<br>  <span class="hljs-type">int</span> tmp = buffer[use];<br>  use = (use + <span class="hljs-number">1</span>) % MAX;<br>  <span class="hljs-keyword">return</span> tmp;<br>&#125;<br><br><span class="hljs-type">void</span> *<span class="hljs-title function_">producer</span><span class="hljs-params">()</span>&#123;<br>  <span class="hljs-type">int</span> i;<br>  <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; loops; i++)&#123;<br>    sem_wait(&amp;empty);<br>    sem_wait(&amp;mutex);<br>    put(i);<br>    sem_post(&amp;mutex);<br>    sem_post(&amp;full);<br>  &#125;<br>&#125;<br><span class="hljs-type">void</span> *<span class="hljs-title function_">consumer</span><span class="hljs-params">()</span>&#123;<br>  <span class="hljs-type">int</span> i;<br>  <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; loops; i++)&#123;<br>    sem_wait(&amp;full);<br>    sem_wait(&amp;mutex);<br>    <span class="hljs-type">int</span> tmp = get();<br>    sem_post(&amp;mutex);<br>    sem_post(&amp;empty);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, tmp);<br>  &#125;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br>  <span class="hljs-comment">// ...</span><br>  sem_init(&amp;empty, <span class="hljs-number">0</span>, MAX);<br>  sem_init(&amp;full, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>  sem_init(&amp;mutex, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>);<br>  <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="读者-写者问题">读者/写者问题</h3>
<p>对某种并发访问的数据结构, 有的进程只需要读取, 而有的进程需要修改. 显然, 多个读取操作可以同时在临界区中执行, 但每次只能有一个写操作在临界区中执行.</p>
<p>对于这个问题, 一种简单的解决方案如下:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">rwlock_t</span>&#123;</span><br>  <span class="hljs-type">sem_t</span> lock;  <span class="hljs-comment">// 二值信号量，位于读写锁外的锁</span><br>  <span class="hljs-type">sem_t</span> writelock;  <span class="hljs-comment">// 二值信号量，保护临界区的锁</span><br>  <span class="hljs-type">int</span> readers;  <span class="hljs-comment">// 表示当前有多少个读者在临界区中</span><br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">rwlock_init</span><span class="hljs-params">(<span class="hljs-type">rwlock_t</span> *rw)</span>&#123;<br>  rw-&gt;readers = <span class="hljs-number">0</span>;<br>  sem_init(&amp;rw-&gt;lock, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>);<br>  sem_init(&amp;rw-&gt;writelock, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">acquire_readlock</span><span class="hljs-params">(<span class="hljs-type">rwlock_t</span> *rw)</span>&#123;<br>  sem_wait(&amp;rw-&gt;lock);<br>  rw-&gt;readers++;<br>  <span class="hljs-keyword">if</span>(rw-&gt;readers == <span class="hljs-number">1</span>)<br>    sem_wait(&amp;rw-&gt;writelock);  <span class="hljs-comment">// 第一个进入临界区的读者获取读写锁</span><br>  sem_post(&amp;rw-&gt;lock);<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">release_readlock</span><span class="hljs-params">(<span class="hljs-type">rwlock_t</span> *rw)</span>&#123;<br>  sem_wait(&amp;rw-&gt;lock);<br>  rw-&gt;readers--;<br>  <span class="hljs-keyword">if</span>(rw-&gt;readers == <span class="hljs-number">0</span>)<br>    sem_post(&amp;rw-&gt;writelock);  <span class="hljs-comment">// 最后一个离开临界区的读者释放读写锁</span><br>  sem_post(&amp;rw-&gt;lock);<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">acquire_writelock</span><span class="hljs-params">(<span class="hljs-type">rwlock_t</span> *rw)</span>&#123;<br>  sem_wait(&amp;rw-&gt;writelock);<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">release_writelock</span><span class="hljs-params">(<span class="hljs-type">rwlock_t</span> *rw)</span>&#123;<br>  sem_post(&amp;rw-&gt;writelock);<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li>该解决方案可能导致写者饥饿, 因为只要有一个线程在访问共享资源, 那么写者就没法写入共享资源.</li>
</ul>
<h3 id="哲学家就餐问题">哲学家就餐问题</h3>
<p>假设 5 个哲学家围着一个圆桌, 每 2 位哲学家之间有一根筷子. 哲学家只进行思考和吃饭. 当他在思考时, 不需要筷子进食；当他感到饥饿需要进食时, 会试图拿起他旁边的两根筷子, 但是一次只能拿起一根, 而且不能从其他哲学家手上抢走筷子. 一个饥饿的哲学家同时拥有了两根筷子之后, 才能进餐；进餐完毕后, 他会放下两根筷子, 继续思考.</p>
<p><img src="/img/Pictures/20230415211302.png" alt=""></p>
<p>最简单的方法是: 每个哲学家首先拿起左边的筷子, 然后再拿起右边的筷子. 显然, 这会导致死锁. 我们有几种补救的措施:</p>
<ul>
<li>最后一个哲学家拿起右边的筷子, 从而打破死锁.</li>
<li>使用非对称解决方案. 单号哲学家先拿起左边的筷子, 再拿起右边的筷子; 双号哲学家则相反.</li>
</ul>
<p>以下是一个用多线程实现的无死锁解决方案, 但是不能完全保证无饥饿:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;pthread.h&gt;</span></span><br><br><span class="hljs-class"><span class="hljs-keyword">enum</span> &#123;</span>THINKING, HUNGRY, EATING&#125; state[<span class="hljs-number">5</span>];<br><span class="hljs-type">pthread_mutex_t</span> pickup_lock;<br><span class="hljs-type">pthread_mutex_t</span> test_lock;<br><span class="hljs-type">pthread_mutex_t</span> return_lock;<br><span class="hljs-type">pthread_cond_t</span> cond_var[<span class="hljs-number">5</span>];<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">pickup_forks</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span><br>&#123;<br>  pthread_mutex_lock(&amp;pickup_lock);<br>  state[i] = HUNGRY;<br>  <span class="hljs-comment">// Philosopher i is hungry</span><br>  test(i);<br>  <span class="hljs-keyword">if</span>(state[i] != EATING)<br>  &#123;<br>    <span class="hljs-keyword">while</span>(state[i] != EATING)<br>    &#123;<br>      <span class="hljs-comment">// Philosopher i is hungry, but he&#x27;s waiting</span><br>      pthread_cond_wait(&amp;cond_var[i],&amp;pickup_lock);<br>    &#125;<br>  &#125;<br>  pthread_mutex_unlock(&amp;pickup_lock);<br>  <span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">return_forks</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span><br>&#123;<br>  pthread_mutex_lock(&amp;return_lock);<br>  state[i] = THINKING;<br>  <span class="hljs-comment">// Philosopher i &#x27;s eating is done, back to thinking</span><br>  test((i + <span class="hljs-number">4</span>) % <span class="hljs-number">5</span>);<br>  test((i + <span class="hljs-number">1</span>) % <span class="hljs-number">5</span>);<br>  pthread_mutex_unlock(&amp;return_lock);<br>  <span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span><br>&#123;<br>  pthread_mutex_lock(&amp;test_lock);<br>  <span class="hljs-keyword">if</span>((state[(i+<span class="hljs-number">4</span>)%<span class="hljs-number">5</span>]!=EATING)&amp;&amp;(state[i]==HUNGRY)&amp;&amp;(state[(i+<span class="hljs-number">1</span>)%<span class="hljs-number">5</span>]!=EATING))<br>  &#123;<br>    state[i] = EATING;<br>    pthread_cond_signal(&amp;cond_var[i]);<br>  &#125;<br>  pthread_mutex_unlock(&amp;test_lock);<br>  <span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-type">void</span> *<span class="hljs-title function_">dph</span><span class="hljs-params">(<span class="hljs-type">void</span> *param)</span><br>&#123;<br>  <span class="hljs-type">int</span>* i =(<span class="hljs-type">int</span>*)param;<br>  <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)<br>  &#123;<br>    <span class="hljs-comment">// Philosopher i is thinking</span><br>    <span class="hljs-comment">// ...</span><br>    pickup_forks(*i);<br>    <span class="hljs-comment">// Philosopher i is eating</span><br>    <span class="hljs-comment">// ...</span><br>    return_forks(*i);<br>  &#125;<br>  pthread_exit(<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li>该程序可能导致饥饿的情况: 假设只有 n、n - 1 和 n + 1 三位哲学家会 Hungry, 其他哲学家不会陷入 Hungry. 那么假设 n - 1 和 n + 1 号哲学家同时陷入 Eating, 此时 n 号哲学家没法陷入 Eating. 此时 n - 1 和 n + 1 号哲学家只要有一个陷入 Eating, n 号哲学家就没法陷入 Eating, 所以只要保证 n - 1 号哲学家和 n + 1 号哲学家有一个陷入 Eating, 那么 n 号哲学家就永远无法陷入 Eating.</li>
<li>当然可以完善上述方案来防止饥饿: 当 n 号哲学家陷入饥饿时, n - 1 号和 n + 1 号哲学家不能同时陷入 Eating. 这样就可以防止饥饿, 但是这就降低了并发程序. 所以想要保证无死锁的同时又防止饥饿, 就可能带来并发程序的损失, 大多数时候你需要权衡利弊.</li>
</ul>
<h2 id="Reference">Reference</h2>
<section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>Chapter 6.5: More Tools, Examples and Deadlocks: <a href="https://zhuanlan.zhihu.com/p/353400345">https://zhuanlan.zhihu.com/p/353400345</a>
<a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
      <categories>
        <category>笔记</category>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
        <tag>Xv6</tag>
      </tags>
  </entry>
  <entry>
    <title>about</title>
    <url>/about/index.html</url>
    <content><![CDATA[<p>主要涉及技术：<br>
QT、C++<br>
个人学习过程中的笔记, 自用.</p>
]]></content>
  </entry>
</search>
